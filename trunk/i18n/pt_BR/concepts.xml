<!-- $Id: concepts.xml 333 2007-10-21 17:20:54Z danieldk $ -->

<chapter id="concepts"> <?dbhtml filename="concepts.html"?>
  <title>Conteitos gerais</title>

  <para>
    Este capítulo introduz alguns conceitos gerais sobre UNIX e GNU/Linux. 
    É importante ler este capítulo cuidadosamente se você não tem nenhuma 
    experiência com estes sistemas. Muitos conceitos vistos aqui são usados 
    neste livro e no GNU/Linux.
  </para>

  <sect1 id="concepts-multitasking">
    <title>Multitarefa</title>

    <sect2 id="concepts-multitasking-intro">
      <title>Introdução</title>

      <para>
        Uma das principais vantagens dos sistemas UNIX é ser multitarefa. 
        Isso quer dizer que vários programas podem rodar ao mesmo tempo. 
        Talvez você não saiba o quão isto é importante, porque a 
        maioria das pessoas usam apenas uma aplicação por vez. Isto 
        é uma necessidade vital para sistemas UNIX e derivados. Mesmo que 
        você não tenha iniciado nenhuma aplicação, existem programas que 
        rodam em segundo plano. Por exemplo, alguns programas provêm serviços 
        de rede, enquanto outros mostram a tela de autenticação e esperam até que 
        o usuário se autentique em um terminal (virtual). Programas que 
        rodam em segundo plano muitas vezes são chamados de 
        <emphasis>daemon</emphasis>
        <footnote>
          <para>
	    A palavra <emphasis>daemon</emphasis> não deve ser confundida com 
	    a palavra <emphasis>demon</emphasis>, a palavra <emphasis>daemon</emphasis> 
	    refere-se à seres sobrenaturais da mitologia grega.
          </para>
        </footnote>.
      </para>
    </sect2>

    <sect2 id="concepts-multitasking-procsthreads">
      <title>Processos e threads</title>

      <para>
        Depois que o programa é carregado da mídia de armazenamento, 
        uma instância do programa é iniciado. Esta instância é 
        chamada de <emphasis>processo</emphasis>. Um processo têm o 
        seu próprio espaço na memória, conhecido como 
        <emphasis>espaço de endereçamento da memória</emphasis>.
        Este espaço possui duas áreas importantes: a área de 
        <emphasis>texto</emphasis> e a área de 
        <emphasis>dados</emphasis>. A área de <emphasis>texto</emphasis>
        é o código do programa. É usada para dizer ao sistema o que fazer. 
        Já a área de <emphasis>dados</emphasis> é usada guardar constantes 
        e dados de tempo de execução. O sistema operacional dá a cada 
        processo um tempo para executar. Em sistemas com um único 
        processador, os processos não rodam simultaneamente. Na verdade 
        um pequeno gerenciador no kernel divide o tempo da CPU entre os 
        processos, dando a ilusão de os processos estarem executando 
        simultaneamente. Esta tarefa é chamada de 
        <emphasis>time-sharing</emphasis>. Em sistemas com mais de uma 
        CPU ou mais de um núcleo, mais de um processo pode rodar 
        simultaneamente, mas mesmo assim o time-sharing é utilizado 
        para dividir o tempo da CPU disponível entre os processos.
      </para>

      <para>
        Novos processos são criados através da duplicação de processos 
        existentes utilizando a chamada de sistema <command>fork</command>. 
        <xref linkend="fork" /> mostra esquematicamente uma chamada 
        fork() em ação. O processo pai solicita uma chamada fork(). O 
        kernel irá responder a esta chamada duplicando o processo e 
        nomeando um processo de <emphasis>pai</emphasis> e os outros 
        processos de <emphasis>filhos</emphasis>.
      </para>

      <figure id="fork">
        <title>Duplicando um processo</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/fork.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        A duplicação de processos pode ser usada para criar dois processos
        que podem rodar simultaneamente em máquinas com mais de um 
        processador. Entretanto, isto não é exatamente o ideal, porque 
        ambos os processos terão o seu próprio espaço de endereçamento. A 
        duplicação inicial da memória de um processo leva relativamente 
        muito tempo, e é muito difícil compartilhar dados entre os processos. 
        Este problema é resolvido com um conceito chamado 
        <emphasis>multithreading</emphasis>. Multithreading quer dizer que
        múltiplas instâncias de uma área de texto por rodar ao mesmo tempo, 
        compartilhando a área de dados. Essas instâncias, chamadas de threads, 
        podem ser executadas em paralelo em múltiplos processadores.
      </para>
    </sect2>
  </sect1>

  <sect1 id="concepts-fshierarchy">
    <title>Hierarquia do sistema de arquivos</title>

    <sect2 id="concepts-fshierarchy-structure">
      <title>Estrutura</title>

      <para>
        Sistemas operacionais guardam os dados em sistemas de arquivos. 
        Um sistema de arquivos é basicamente um conjunto de diretórios em 
        uma estrutura similar à de uma árvore e guardam arquivos, 
        como o sistema operacional, programas e dados do usuário. A 
        maioria dos sistemas de arquivos podem guardar várias 
        meta-informações sobre os arquivos e diretórios, como por exemplo 
        a data de execução ou alteração. No GNU/Linux há apenas uma 
        hierarquia no sistema de arquivos, isto quer dizer que não há 
        letras para as mídias (e.g. A:, C:, D:) para diferentes sistemas 
        de arquivos, como no DOS e no Windows. O sistema de arquivos é 
        similar à uma árvore, com um diretório raiz (que não possui 
        diretório pai), ramos e folhas (diretórios sem um subdiretório). 
        O diretório raiz é sempre representado por uma barra (<quote>/</quote>). 
        Os subdiretórios são separados por este caracter também.
      </para>

      <figure id="filesystem-structure">
        <title>A estrutura do sistema de arquivos</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../images/fs-structure.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        <xref linkend="filesystem-structure"/> mostra a estrutura de um 
        sistema de arquivos. Você pode ver que o diretório raiz 
        <filename>/</filename> possui dois subdiretórios:
        <filename>bin</filename> e <filename>home</filename>. O 
        <filename>home</filename> possui dois subdiretórios,
        <filename>joe</filename> e <filename>jack</filename>. O diagrama 
        mostra o caminho completo de cada diretório. A mesma notação 
        é usada para arquivos. Suponha que haja um arquivo chamado 
        <filename>memo.txt</filename> no diretório 
        <filename>/home/jack</filename>, o caminho completo do arquivo 
        é <filename>/home/jack/memo.txt</filename>.
      </para>

      <para>
        Each directory has two special entries,
        <quote><filename>.</filename></quote>, and
        <quote><filename>..</filename></quote>.  The first refers to
        the directory itself, the second to the parent
        directory. These entries can be used for making relative
        paths. If you are working in the <filename>jack</filename>
        directory, you can refer to the the
        <filename>/home/joe</filename> directory with
        <filename>../joe</filename>.
      </para>
    </sect2>

    <sect2 id="concepts-fshierarchy-mounting">
      <title>Mounting</title>

      <para>
        You might wonder how it is possible to access other devices
        or partitions than the hard disk partition which holds the
        root filesystem. Linux uses the same approach as UNIX for
        accessing other filesystems. Linux allows the system
        administrator to connect a device to any directory in the
        filesystem structure. This process is named
        <emphasis>mounting</emphasis>.  For example, one could mount
        the CD-ROM drive to the <filename>/cdrom</filename>
        directory. If the mount is correct, the files on the CD-ROM
        can be accessed through this directory. The mounting process
        is described in detail in <xref
        linkend="basics-filesystem-mounting"/>.
      </para>
    </sect2>

    <sect2 id="concepts-fshierarchy-commondirs">
      <title>Common directories</title>

      <para>
        The Filesystem Hierarchy Standard Group has attempted to
        create a standard that describes which directories should
        be available on a GNU/Linux system. Currently, most major
        distributions use the Filesystem Hierarchy Standard (FHS)
        as a guideline. This section describes some mandatory
        directories on GNU/Linux systems.
      </para>

      <para>
        Please note that GNU/Linux does not have a separate directory
        for each application (like Windows). Instead, files are ordered by
        function and type. For example, the binaries for most
        common user programs are stored in
        <filename>/usr/bin</filename>, and their libraries in
        <filename>/usr/lib</filename>. This is a short overview of
        the important directories on a Slackware Linux system:
      </para>


      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">/bin</emphasis>: essential
            user binaries that should still be available in case the 
            <filename>/usr</filename> is not mounted.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/dev</emphasis>: device files.
            These are special files used to access certain devices.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/etc</emphasis>: the
            <filename>/etc</filename> directory contains all important
            configuration files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/home</emphasis>: contains home
            directories for individual users.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/lib</emphasis>: essential system
            libraries (like glibc),
            and kernel modules.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/root</emphasis>: home directory for the 
            <emphasis>root</emphasis> user.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/sbin</emphasis>: essential binaries
            that are used for system administration.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/tmp</emphasis>: a world-writable
            directory for temporary files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/bin</emphasis>: stores the majority
            of the user binaries.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/lib</emphasis>: libraries that are
            not essential for the system to boot.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/sbin</emphasis>: nonessential
            system administration binaries.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/var</emphasis>: variable data files,
            like logs.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="concepts-devices">
    <title>Devices</title>

    <sect2 id="concepts-devices-intro">
      <title>Introduction</title>

      <para>
        In GNU/Linux virtually everything is represented as a file, including
        devices. Every GNU/Linux system has a directory with special files, named
        <filename>/dev</filename>. Each file in the <filename>/dev</filename>
        directory represents a device or pseudo-device. A device file
        has two special numbers associated with it, the
        <emphasis>major</emphasis> and the <emphasis>minor</emphasis>
        device number. The kernel knows which device a device
        file represents by these device numbers. The following example shows
        the device numbers for the <filename>/dev/zero</filename> device file:
      </para>

      <screen>
$ <command>file /dev/zero</command>
/dev/zero: character special (1/5)
      </screen>

      <para>
        The <command>file</command> command can be used to determine the
        type of a file. This particular file is recognized as a device file
        that has <emphasis>1</emphasis> as the major device number,
        and <emphasis>5</emphasis> as the minor device number.
      </para>

      <para>
        If you have installed the kernel source package, you can find
        a comprehensive list of all major devices with their minor and
        major numbers in
        <filename>/usr/src/linux/Documentation/devices.txt</filename>. An
        up-to-date list is also available on-line through the Linux
        Kernel Archives<footnote>
          <para>
            <ulink url="ftp://ftp.kernel.org/pub/linux/docs/device-list/" />
          </para>
        </footnote>.
      </para>

      <para>
        The Linux kernel handles two types of devices:
        <emphasis>character</emphasis> and <emphasis>block</emphasis>
        devices. Character devices can be read byte by byte,
        block devices can not. Block devices are read per block (for example
        4096 bytes at a time). Whether a device is a character or block device
        is determined by the nature of the device. For example, most storage
        media are block devices, and most input devices are character devices.
        Block devices have one distinctive advantage, namely that they can be
        cached. This means that commonly read or written blocks are stored in
        a special area of the system memory, named the cache. Memory is much
        faster than most storage media, so much performance can be gained
        by performing common block read and write operations in memory.
        Of course, eventually changes have to be written to the storage
        media to reflect the changes that were made in the cache.
      </para>
    </sect2>

    <sect2 id="concepts-devices-atascsi">
      <title>ATA and SCSI devices</title>

      <para>
        There are two kinds of block devices that we are going to look into
        in detail, because understanding the naming of these devices is
        crucial for  partitioning a hard disk and mounting. Almost all modern
        computers with an x86 architecture use ATA hard disks and CD-ROMs.
        Under Linux these devices are named in the following manner:
      </para>

      <screen>
/dev/hda - master device on the first ATA channel
/dev/hdb - slave device on the first ATA channel
/dev/hdc - master device on the second ATA channel
/dev/hdd - slave device on the second ATA channel
      </screen>

      <para>
        On most computers with a single hard disk, the hard disk is the master
        device on the first ATA channel (<filename>/dev/hda</filename>), and
        the CD-ROM is the master device on the second ATA channel. Hard disk
        partitions are named after the disk that holds them plus a number.
        For example, <filename>/dev/hda1</filename> is the first partition
        of the disk represented by the <filename>/dev/hda</filename>
        device file.
      </para>

      <para>
        SCSI hard disks and CD-ROM drives follow an other naming convention.
        SCSI is not commonly used in most low-end machines, but USB drives
        and Serial ATA (SATA) drives are also represented as SCSI disks. The
        following device notation is used for SCSI drives:
      </para>

      <screen>
/dev/sda - First SCSI disk
/dev/sdb - Second SCSI disk
/dev/sdc - Third SCSI disk
/dev/scd0 - First CD-ROM
/dev/scd1 - Second CD-ROM
/dev/scd2 - Third CD-ROM
      </screen>

      <para>
        Partitions names are constructed in the same way as ATA disks;
        <filename>/dev/sda1</filename> is the first partition on the first
        SCSI disk.
      </para>

      <para>
        If you use the software RAID implementation of the Linux kernel, RAID
        volumes are available as <filename>/dev/mdn</filename>, in which
        <emphasis>n</emphasis> is the volume number starting at 0.
      </para>
    </sect2>
  </sect1>
</chapter>
