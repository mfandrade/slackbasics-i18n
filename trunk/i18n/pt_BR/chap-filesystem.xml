<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 xml:lang="pt_BR"
	 xml:id="chap-filesystem">
  <title>Arquivos e diretórios</title>

  <sect1 xml:id="chap-filesystem-introduction">
    <title>Um pouco de teoria</title>

    <para>
      Antes de começarmos a ver as operações práticas com sistemas de
      arquivos, vamos conferir uma visão geral mais teórica de como
      sistemas de arquivos funcionam em sistemas UNIX-like.  O Slackware
      Linux dá suporte a vários sistemas de arquivos distintos, mas
      todos estes sistemas de arquivos usam essencialmente as mesmas
      semânticas.  Estas semânticas são oferecidas através de uma camada
      de <emphasis>Sistema de Arquivo Virtual</emphasis> (VFS, da sigla
      em inglês), que proporciona uma camada genérica para sistemas de
      arquivo em disco ou em rede.
    </para>

    <sect2 xml:id="chap-filesystem-introduction-atoms">
      <title>inodes, diretórios e dados</title>

      <para>
    O sistema de arquivos consiste de dois tipos de elementos: dados e
    metadados.  Os metadados descrevem os atuais blocos de dados que
    estão no disco.  Muitos sistemas de arquivo usam nós de informação
    (inodes) para manter metadados.  Muitos sistemas de arquivo
    armazenam os seguintes dados em seus inodes:
      </para>

      <table xml:id="chap-filesystem-introduction-atoms-inodes">
        <title>Campos comuns em um inode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Campo</entry>
              <entry>Descrição</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>As permissões do arquivo..</entry>
            </row>
            <row>
              <entry>uid</entry>
              <entry>O ID do usuário que é o dono do arquivo.</entry>
            </row>
            <row>
              <entry>gid</entry>
              <entry>O ID do grupo do arquivo.</entry>
            </row>
            <row>
              <entry>size</entry>
              <entry>O tamanho do arquivo em bytes.</entry>
            </row>
            <row>
              <entry>ctime</entry>
              <entry>Momento de criação do arquivo.</entry>
            </row>
            <row>
              <entry>mtime</entry>
              <entry>Momento da última modificação do arquivo.</entry>
            </row>
            <row>
              <entry>links_count</entry>
              <entry>O número de links apontando para este inode.</entry>
            </row>
            <row>
              <entry>i_block</entry>
              <entry>Ponteiros para os blocos de dados.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    Se você não for um entusiasta de UNIX ou Linux, estes nomes
    provavelmente deve estar soando um pouco estranhos a você, mas vamos
    esclarecê-los melhor nas seções seguintes.  De qualquer forma,
    a partir desta tabela possivelmente você já pode deduzir a relação
    entre inodes e dados, e especificamente sobre o campo
    <emphasis>i_block</emphasis>: cada inode tem ponteiros para os
    blocos de dados sobre os quais o inode provê informações.  Além
    disso, o inome e os blocos de dados são o próprio arquivo no sistema
    de arquivos.
      </para>

      <para>
    Agora você pode estar se perguntando onde fica a informação com o
    nome dos arquivos (e diretórios), já que não há um campo para o nome
    do arquivo no inode.  Atualmente, os nomes dos arquivos são
    armazenados nas assim chamadas entradas de diretório.  Estas
    entradas especificam um nome de arquivo e o inode do arquivo.  Uma
    vez que diretórios também são representados por inodes, uma
    estrutura de diretórios pode ser construída desta maneira.
      </para>

      <para>
    Podemos mostrar de uma forma simplicada como isto tudo funciona
    ilustrando o que o kernel faz quando executamos o comando
	<command>cat /home/daniel/note.txt</command>
      </para>

      <orderedlist>
        <listitem>
	  <para>
        O sistema lê o inode do diretório <filename>/</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do
	    diretório <filename>home</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do diretório <filename>home</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do
	    diretório <filename>daniel</filename>.</para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do diretório <filename>daniel</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do arquivo
        <filename>note.txt</filename>
	  </para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do arquivo <filename>note.txt</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        retorna o bloco de dados para o <command>cat</command> por meio
        da chamada de sistema <emphasis>read()</emphasis>.</para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="chap-filesystem-introduction-permissions">
      <title>Permissões de arquivos</title>

      <para>
    Como descrevemos anteriormente, Linux é um sistema multi-usuário.
    Isto significa que cada usuário tem seus próprios arquivos (que
    usualmente estão localizados no diretório home).  Além disso, os
    usuários podem ser membros de grupos, que podem lhes dar privilégios
    adicionais de usuário.
      </para>

      <para>
    Como você viu na tabela dos campos do inode, cada arquivo tem um
    usuário e um grupo.  O controle de acesso tradicional do UNIX
    possibilita permissões para leitura, escrita, ou execução ao dono do
    arquivo, para seu grupo, e para os outros usuários.  Estas
    permissões são armazenadas no campo <emphasis>mode</emphasis> de
    cada inode.  O campo mode representa as permissões do arquivo como
    quatro dígitos em numeração octal.  O primeiro dígito representa
    certas opções especiais; o segundo dígito armazena as permissões do
    dono do arquivo; o terceiro, as permissões de grupo e o quarto
    dígito, as permissões para os outros usuários.  As permissões são
    estabelecidas pelos dígitos usando-se ou adicionando-se um dos
    números em <xref linkend="chap-filesystem-permissions-numbers"/>
      </para>

      <table xml:id="chap-filesystem-permissions-numbers">
        <title>Significado dos números no octeto do campo mode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Número</entry>
              <entry>Significado</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>Execução (x)</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>Escrita (w)</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>Leitura (r)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    Agora, suponha que um arquivo tenha um mode
    <emphasis>0644</emphasis>, isto significa que o arquivo é legível e
    passível de escrita pelo dono (<emphasis>6</emphasis>, e apenas
    legível pelo grupo do arquivo (<emphasis>4</emphasis>) e outros
    usuário (<emphasis>4</emphasis>).</para>

      <para>
    Muitos usuários não querem lidar com números octais, então por isso
    que muitos utilitários podem também lidar com representações
    alfabéticas das permissões de arquivo.  As letras estão listadas em
	<xref linkend="chap-filesystem-permissions-numbers"/> entre
    parênteses e são usadas nesta notação.  No exemplo seguinte, a
    informação sobre um arquivo com permissões <emphasis>0644</emphasis>
    é exibida.  Os números são substituídos por três conjuntos rwx (o
    primeiro caracter pode listar opções especiais de modo).
      </para>

      <screen>
$ <userinput>ls -l note.txt</userinput>
-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt
      </screen>

      <para>
    Com o passar dos anos estas permissões tradicionais do UNIX
    mostraram não serem suficientes em alguns casos.  A especificação
    POSIX 1003.1e ajudou a extender o modelo de controle de acesso do
        UNIX com as <emphasis>Listas de Controle de Acesso</emphasis>
        (ACLs, da sigla em inglês).
    Infelizmente este esforço ficou estagnado, já que só alguns sistemas
        (como o GNU/Linux) implementaram ACLs<footnote>
    <para>No momento em que este livro estava sendo escrito, ACLs têm
        suporte nos sistemas de arquivos ext2, ext3, e XFS</para>
        </footnote>.  Listas de controle de acesso seguem a mesma
        semântica que as permissões de arquivo normais, mas lhe dão a
        oportunidade de adicionar conjuntos de <emphasis>rwx</emphasis>
        para usuários de grupos adicionais.</para>

      <para>
    O exemplo a seguir exibe a lista de controle de acesso de um
    arquivo.  Como você pode ver, as permissões parecem com as
    permissões normais do UNIX (são especificadas as permissões de
    para o dono, o grupo, e outros).  Mas há também uma entrada
    adicional para o usuário <emphasis>joe</emphasis>.
      </para>

      <programlisting>
user::rwx
user:joe:r--
group::---
mask::r--
other::---
      </programlisting>

      <para>
    Para tornar as coisas ainda mais complexas (e mais sofisticadas),
    alguns sistemas GNU/Linux adicionam controle de acesso ainda mais
    específico por meio de Frameworks de Controle de Acesso Obrigatório
    (<foreignphrase>Mandatory Access Control Frameworks,
    MAC</foreignphrase>) como o SELinux e o AppArmor.  Mas estes
    frameworks de controle de acesso estão fora do escopo deste livro.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystems-introduction-links">
      <title>Links</title>

      <para>
    Uma entrada de diretório que aponta para um inode é chamada de 
	<emphasis><foreignphrase>hard linki<foreignphrase></emphasis>.
    Muitos arquivos possuem apenas um único link, mas nada lhe impede de
    criar mais de um link para o arquivo.  Isto irá incrementar o campo
    <emphasis>links_count</emphasis> do inode.  Esta é uma bela maneira
    de o sistema verificar quais inodes e blocos de dados estão livres
    para utilização.  Se links_count estiver com valor zero, então o
    inode não é mais referenciado em lugar nenhum, e pode ser
    reutilizado.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-hardlink">
        <title>A estrutura de um hard link</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../images/hardlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../images/hardlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
	Hard links possuem duas limitações.  Em primeiro lugar, hard links
    não podem linkar entre diferentes sistemas de arquivos, uma vez que
    eles apontam para inodes.  Cada sistema de arquivo tem seus próprios
    inodes e números de inode correspondentes.  Além disso, muitos
    sistemas de arquivos não permitem que você crie hard links para
    diretórios.  Permitir a criação de hard links para diretórios pode
    gerar loops de diretórios, potencialmente resultando em deadlocks e
    inconsistências no sistema de arquivo.  Adicionalmente, muitas
    implementações dos comandos <command>rm</command> e
    <command>rmdir</command> não sabem como lidar com hard links extras
    para diretórios.
      </para>

      <para>
        <emphasis>Links simbólicos</emphasis> não possuem estas
        limitações, pois eles apontam para nomes de arquivos, ao invés
        do que para inodes.  Quando um link simbólico é usado, o sistema
        operacional irá seguir o caminho daquele link.  Links simbólicos
        também podem se referir a arquivos que não existem, uma vez que
        contém apenas um nome.  Links deste tipo são chamados de
        <foreignphrase>dangling links</foreignphrase>.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-symlink">
        <title>A estrutura de um link simbólico</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../images/symlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../images/symlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>
      Se você estiver envolvido com administração de sistemas, é bom
      estar ciente das implicações de segurança da utilização de hard
      links.  Se o diretório <filename>/home</filename> estiver no mesmo
      sistema de arquivos que outros binários do sistema, um usuário
      poderia criar hard links para binários.  No caso de um programa
      vulnerável ser atualizado, o link no diretório home do usuário
      permanecerá apontando para o programa binário antigo, efetivamente
      dadno ao usuário acesso contínuo ao binário vulnerável.
	</para>

        <para>
      Por esta razão é uma boa idéia colocar quaisquer diretórios que os
      usuários possam escrevem em diferentes sistemas de arquivos.  Na
      prática, isto significa que é uma boa idéia colocar ao menos os
      diretórios <filename>/home</filename> e <filename>/tmp</filename>
      em sistemas de arquivos distintos.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystems-analyzing">
    <title>Analisando arquivos</title>

    <para>
      Antes de nos aventurarmos por outros mares, vamos começar com
      um pouco da utilização básica de arquivos e diretórios.
    </para>

    <sect2 xml:id="chap-filesystems-analyzing-listing">
      <title>Listando arquivos</title>

      <para>
    Uma das coisas mais comuns que você vai querer fazer é listar todos
    os alguns arquivos.  O comando <command>ls</command> serve muito bem
    a este propósito.  Usar <command>ls</command> sem nenhum argumento
    irá mostrar o conteúdo do diretório atual:
      </para>

      <screen>
$ <userinput>ls</userinput>
dns.txt  network-hosts.txt  papers
      </screen>

      <para>
    Se você usa uma distribuição GNU/Linux, você também pode ver a saída
    em cores baseadas nos tipos de arquivos.  A saída padrão é útil para
    consultar o conteúdo de um diretório, mas se você quer mais
    informação, você pode usar o parâmetro <parameter
    class="command">-l</parameter>.  Este parâmetro proporciona uma
    listagem longa para cada arquivo:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Isto resulta em bastante informação a mais sobre as entradas da
    árvore de diretório que a que obtemos com o comando
    <command>ls</command>.  A primeira coluna exibe as permissões dos
    arquivos.  A linha que exibe a entrada <filename>papers</filename>
    inicia com um <quote>d</quote>, significando que esta entrada
    representa um diretório.  A segunda coluna exibe o número de hard
    links que apontam para o inode referente aquele diretório.  Se este
    número é maior que 1, há alguns outros nomes de arquivo para o mesmo
    arquivo.  Entradas de diretório usualmente possuem pelo menos dois
    hard links, referenciando o link no diretório pai e o link para o
    diretório em si (cada diretório possui uma entrada
    <filename>.</filename>, a qual se refere ao diretório em si).  A
    terceira e quarta colunas listam o dono do arquivo e o grupo
    respectivamente.  A quinta coluna contém o tamanho do arquivo em
    bytes.  A sexta coluna é o momento da última modificação e a data do
    arquivo.  E finalmente, a última coluna mostra o nome desta entrada.
      </para>

      <para>
    Arquivos que iniciam com um ponto (.) não serão exibidos pela
    maioria das aplicações, incluindo o <command>ls</command>.  Você
    pode listar estes arquivos também, adicionando a opção <parameter
    class="command">-a</parameter> ao comando <command>ls</command>:
      </para>

      <screen>
$ <userinput>ls -la</userinput>
total 60
drwxrwxr-x   3 daniel daniel  4096 Sep 11 10:01 .
drwx------  88 daniel daniel  4096 Sep 11 10:01 ..
-rw-rw-r--   1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--   1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x   2 daniel daniel  4096 Sep  4 15:55 papers
-rw-rw-r--   1 daniel daniel     5 Sep 11 10:01 .settings
      </screen>

      <para>
    Como você pode ver, mais três entradas apareceram.  Primeiro de
    tudo, o arquivo <filename>.settings</filename> agora é mostrado.
    Além disso você pode ver as duas entradas de diretório adicionais,
    <filename>.</filename> e <filename>..</filename>.  Estas representam
    o diretório atual e o diregório pai, respectivamente.
      </para>

      <para>
    Anteriormente neste capítulo (<xref 
	linkend="chap-filesystem-introduction-atoms"/>) falamos sobre
    inodes.  O número do inode apontado por uma entrada de diretório
    pode ser mostrado com o parâmetro <parameter
    class="command">-i</parameter>.  Suponha que eu tenha criado um hard
    link para o inode que aponta para o mesmo inode que o arquivo
    <filename>dns.txt</filename>, eles devem ter o mesmo número de
    inode.  A seguinte saída do comando <command>ls</command> mostra que
    isto é verdade:
      </para>

      <screen>
$ <userinput>ls -i dns*</userinput>
3162388 dns-newhardlink.txt
3162388 dns.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-file">
      <title>Determinando o tipo de um arquivo</title>

      <para>
    Algumas vezes você vai precisar de ajuda para determinar o tipo de
    um arquivo.  É onde o utilitário <command>file</command> se torna
    útil.  Imagine que eu encontre um arquivo chamado
    <filename>HelloWorld.class</filename> em algum lugar do meu disco.
    Eu suponho que este seja um arquivo que contenha bytecodes Java, mas
    podemos usar <command>file</command> para confirmar isto:
      </para>

      <screen>
$ <userinput>file HelloWorld.class</userinput>
HelloWorld.class: compiled Java class data, version 49.0
      </screen>

      <para>
    Definitivamente isto é bytecode Java.  <command>file</command> é
    bastante esperto, e manipula muitas coisas que você sequer imagina.
    Por exemplo, você poderia usá-lo para obter informação sobre um
    dispositivo:
      </para>

      <screen>
$ <userinput>file /dev/zero</userinput>
/dev/zero: character special (1/5)
      </screen>

      <para>
	Ou sobre um link simbólico:
      </para>

      <screen>
$ <userinput>file /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: symbolic link to `Xorg'
      </screen>

      <para>
    Se você estiver interessado em para onde o arquivo 
	<filename>/usr/X11R6/bin/X</filename> aponta, você pode usar a
    opção <parameter class="command">-L</parameter> do
	<command>file</command>:
      </para>

      <screen>
$ <userinput>file -L /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: setuid writable, executable, regular file, no read permission
      </screen>

      <para>
    Você pode se perguntar como o <command>file</command> pode
    determinar o tipo de arquivo tão facilmente.  Muitos arquivos
    iniciam com algo que chamamos de <emphasis>número mágico</emphasis>,
    que é um número único que informa aos programas que podem lê-los
    sobre de que tipo o arquivo é.  O programa <command>file</command>
    usa um arquivo com a descrição de diversos tipos de arquivos e seus
    números mágicos.  Por exemplo, no meu sistema este arquivo mágico
    contém as seguintes linhas para arquivos Java compilados:
      </para>

      <programlisting>
# Java ByteCode
# From Larry Schwimmer (schwim@cs.stanford.edu)
0       belong          0xcafebabe      compiled Java class data,
>6      beshort x       version %d.
>4      beshort x       \b%d
      </programlisting>

      <para>
    Esta entrada diz que se um arquivo iniciar com o longo número mágico
    hexadecimal <emphasis>0xcafebabe</emphasis><footnote><
        <para>Sim, você pode ser criativo com os números mágicos
        também!</para> </footnote>, é um arquivo que contém dados
        compilados de uma classe Java (<quote><foreignphrase>compiled
        Java class data</foreignphrase></quote>).  o número curto que se
        segue determina a versão do formato do arquivo class.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-integrity">
      <title>Integridade de arquivos</title>

      <para>
    Antes de partirmos para a checagem mais avançada da integridade de
    arquivos,  <!-- XXX xref --> vamos dar uma breve olhada no
    utilitário <command>cksum</command>.  <command>cksum</command> pode
    calcular a soma para checagem de redundância cíclica (CRC) de um
    dado arquivo de entrada.  Este é um método matemático para cálculo
    de um número único para um arquivo.  Você pode usar este número para
    verificar se um arquivo não sofreu modificações (por exemplo, depois
    de baixar um arquivo de um servidor).  Você pode especificar o
    arquivos para cálculo do CRC como um parâmetro para o
    <command>cksum</cksum>, e o <command>cksum</command> irá exibir o
    valor do CRC, o tamanho em bytes e o nome do arquivo:
      </para>

      <screen>
$ <userinput>cksum myfile</userinput>
1817811752 22638 myfile
      </screen>

      <para>
	O Slackware Linux também possui utilitários para cálculo de somas de
    verificação baseadas em algorítmos de via única (por exemplo, MD5 ou
    SHA-1).
	<!-- XXX - elaborar -->
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-viewing">
      <title>Visualizando arquivos</title>

      <para>
    Uma vez que muitos arquivos em sistemas UNIX são essencialmente
    arquivos de texto, eles são fáceis de serem visualizados em um
    terminal de caracteres ou emulador de terminal.  A forma mais
    primitiva de ver o conteúdo de um arquivo é através do
    <command>cat</command>.  O comando <command>cat</command> lê
    os arquivos que forem especificados como parâmetros linha por linha,
    e irá exibí-las na saída padrão.  Então, você pode imprimir o
    conteúdo do arquivo <filename>note.txt</filename> para o terminal
    com <filename>cat note.txt</filename>.  Ainda que alguns sistemas e
    muitos emuladores de terminal tenham suporte a barras de rolagem,
    esta não é uma maneira prática de visualizar arquivos grandes.  Você
    pode criar um duto (<foreignphrase>pipe</foreignphrase>) com a saída
    do <command>cat</command> para o paginador <command>less</command>:
      </para>

      <screen>
$ <userinput>cat note.txt | less</userinput>
      </screen>

      <para>
	ou deixar que o <command>less</command> leia o arquivo diretamente:
      </para>

      <screen>
$ <userinput>less note.txt</userinput>
      </screen>

      <para>
    O <command>less</command> é um paginador e permite que você role a
    tela para frente e para trás num arquivo.  <xref
	linkend="chap-filesystem-analyzing-viewing-less-keys"/>
    contém uma visão geral das teclas mais importantes usadas para
    controlar o <command>less</command>
      </para>

      <table xml:id="chap-filesystem-analyzing-viewing-less-keys">
        <title>teclas de comando do less</title>

        <tgroup cols="2" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Tecla</entry>
              <entry>Descrição</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>j</entry>
              <entry>Rola uma linha para a frente.</entry>
            </row>
            <row>
              <entry>k</entry>
              <entry>Rola uma linha para trás.</entry>
            </row>
            <row>
              <entry>f</entry>
              <entry>Rola uma tela cheia de texto para frente.</entry>
            </row>
            <row>
              <entry>b</entry>
              <entry>Rola uma tela cheia de texto para trás.</entry>
            </row>
            <row>
              <entry>q</entry>
              <entry>Termina o comando.</entry>
            </row>
            <row>
              <entry>g</entry>
              <entry>Pula para o começo do arquivo.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>Pula para o final do arquivo.</entry>
            </row>
            <row>
              <entry>/<emphasis>padrão</emphasis></entry>
              <entry> Procura pelo <emphasis>padrão</emphasis> de texto
              com a <link
              xl:href="#chap-textproc-regexps">expressão regular</link>
                dada. </entry>
            </row>
            <row>
              <entry>n</entry>
              <entry> Procura pela próxima ocorrência da expressão
              regular previamente especificada.
              </entry>
            </row>
            <row>
              <entry>m<emphasis>letra</emphasis></entry>
              <entry> Faz um marcador da posição atual no arquivo com a
              <emphasis>letra</emphasis>.
              </entry>
            </row>
            <row>
              <entry>'<emphasis>letra</emphasis></entry>
              <entry>Pula para o marcador dado por <emphasis>letra</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    As teclas de comando podem ser quantificadas com um prefixo
    numérico.  Por exemplo, <emphasis>11j</emphasis> rola a tela onze
    linhas para a frente, e <emphasis>3n</emphasis> procura pela
    terceira ocorrência da última expressão regular especificada.
      </para>

      <para>
    O Slackware Linux também possui uma alternativa ao
	Slackware Linux also provides an alternative to
	<command>less</command>, o antigo comando <quote>more</quote>.
    Não vamos abordar o <emphasis>more</emphasis> aqui pois o
	<command>less</command> é mais confortável e mais popular hoje em
    dia.
      </para>

    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-filesize">
      <title>Tamanhos de arquivos e diretórios</title>

      <para>
	A saída de <command>ls -l</command> que vimos há pouco provê
    informação sobre o tamanho de um arquivo.  Ainda que isto usualmente
    seja informação suficiente sobre tamanhos de arquivos, você pode
    querer coletar informação sobre conjuntos de arquivos ou diretórios.
    É onde entra o comando <command>du</command>.  Por padrão,
    <command>du</command> exibe o tamanho dos arquivos por diretório.
    Por exemplo:
      </para>

      <screen>
$ <userinput>du ~/qconcord</userinput>
72      /home/daniel/qconcord/src
24      /home/daniel/qconcord/ui
132     /home/daniel/qconcord
      </screen>

      <para>
        Por padrão, <command>du</command> representa o tamanho em
        números de blocos de 1024 bytes.  Você pode especificar
        explicitamente que o <command>du</command> deva usar unidades de
        1024 bytes adicionando a opção <parameter
        class="command">-k</command>.  Isto é útil para escrever
    scripts, pois o padrão de alguns outros sistemas é usar blocos de
    512 bytes.  Por exemplo:
      </para>

      <screen>
$ <userinput>du -k ~/qconcord</userinput>
72	/home/daniel/qconcord/src
24	/home/daniel/qconcord/ui
132	/home/daniel/qconcord
      </screen>

      <para>
    Se você também quiser ver a utilização de disco por arquivo, você
    pode adicionar a opção <parameter class="command">-a</parameter>:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord</userinput>
8       /home/daniel/qconcord/ChangeLog
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
12      /home/daniel/qconcord/Makefile
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
8       /home/daniel/qconcord/qconcord.pro
132     /home/daniel/qconcord
      </screen>

      <para>
    Você também pode usar o nome de um arquivo um caracter curinga como
    parâmetro.  Mas isto não vai exibir os tamanhos dos arquivos em
    subdiretórios, a menos que <parameter class="command">-a</parameter>
    seja usado:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord/*</userinput>
8       /home/daniel/qconcord/ChangeLog
12      /home/daniel/qconcord/Makefile
8       /home/daniel/qconcord/qconcord.pro
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
      </screen>

      <para>
    Se você quiser ver a soma total do espaço em disco utilizado pelos
    arquivos e subdiretórios dentro do diretório dado, então use a opção
	<parameter class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>du -k -s ~/qconcord</userinput>
132     /home/daniel/qconcord
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-directories">
    <title>Trabalhando com diretórios</title>

    <para>
      Depois de dar uma visão geral de diretórios em <xref 
      linkend="chap-filesystem-introduction-atoms"/>, vamos agora dar uma
      olhada em alguns comandos relacionados a diretórios.
    </para>

    <sect2 xml:id="chap-filesystem-directories-listing">
      <title>Listando diretórios</title>

      <para>
	O comando <command>ls</command> que vimos em <xref 
	linkend="chap-filesystems-analyzing-listing"/> também pode ser usado
    para listar diretórios de diferentes maneiras.  Como já vimos, a
    saída padrão do <command>ls</command> inclui diretórios, e os
    diretórios podem ser identificados usando a primeira coluna da saída
    de uma listagem longa:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Se um nome de diretório, ou se um coringa for especificado, o
	<command>ls</command> irá listar o conteúdo do diretório, os dos
    diretórios que casem com o coringa respectivamente.  Por exemplo, se
    houver um diretóro <filename>papers</filename>, <command>ls
    paper*</command> vai listar o conteúdo deste diretório
    <filename>papers</filename>.  O parâmetro <parameter 
	class="command">-d</parameter> evita que esta recursão
    aconteça:
      </para>

      <screen>
$ <userinput>ls -ld paper*</userinput>
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Você também pode listar recursivament o conteúdo de um diretório, e
    de seus subdiretórios com o parâmetro <parameter 
	class="command">-R</parameter>:
      </para>

      <screen>
$ <userinput>ls -R</userinput>
.:
dns.txt  network-hosts.txt  papers

./papers:
cs  phil

./papers/cs:
entr.pdf

./papers/phil:
logics.pdf
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-directories-management">
      <title>Criando e removendo diretórios</title>

      <para>
    O UNIX provê o comando <command>mkdir</command> para criar
    diretórios.  Se um caminho relativo é especificado, o diretório é
    criado no diretório corrente.  A sintaxe básica é muito simples:
	<emphasis>mkdir &lt;nome&gt;</emphasis>, por exemplo:
      </para>

      <screen>
$ <userinput>mkdir meudir</userinput>
      </screen>

      <para>
	Por padrão, <command>mkdir</command> cria apenas um nível de
    diretório.  Então, se você usar <command>mkdir</command> para criar 
	<filename>meudir/meusubdir</filename>, <command>mkdir</command> vai
    falhar se <filename>meudir</filename> não existir.  Se você quiser
    criar ambos os diretórios de uma só vez, use o parâmetro
	<parameter class="command">-p</parameter>:
      </para>

      <screen>
$ <userinput>mkdir -p meudir/meusubdir</userinput>
      </screen>

      <para>
	<command>rmdir</command> remove um diretório.  Seu comportamento é
    comparável ao do <command>mkdir</command>.  <command>rmdir
	meudir/meusubdir</command> remove
    <filename>meudir/meusubdir</filename>, ao passo que <command>rmdir -p
    meudir/meusubdir</command> remove
    <filename>meudir/meusubdir</filename> e também 
    <filename>meudir</filename>.
      </para>

      <para>
    Se um subdiretório que quisermos remover contenha entradas de
	diretório, <command>rmdir</command> irá falhar.  Se você quiser
    remover um diretório, incluindo todo o seu conteúdo, use o comando
	<command>rm</command> então. <!-- XXX - xref -->
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-managing">
    <title>Gerenciando arquivos e diretórios</title>

    <sect2 xml:id="chap-filesystem-managing-copying">
      <title>Copiando</title>

      <para>
    Arquivos e diretórios podem ser copiados com o comando 
	<command>cp</command>.  Em sua sintaxe mais básica a origem e destino
    do arquivo são especificados.  O exemplo a seguir fará uma cópia do
	<filename>arquivo1</filename> chamada <filename>arquivo2</filename>:
      </para>

      <screen>
$ <userinput>cp arquivo1 arquivo2</userinput>
      </screen>

      <para>
    Não é surpresa que caminhos relativos e absolutos também funcionam:
      </para>

      <screen>
$ <userinput>cp arquivo1 algumdir/arquivo2</userinput>
$ <userinput>cp arquivo1 /home/joe/design_documents/arquivo2</userinput>
      </screen>

      <para>
    Você também pode especificar um diretório como segundo parâmetro.  Se
    este for o caso, <command>cp</command> vai fazer uma cópia do arquivo
    dentro daquele diretório, dando-lhe o mesmo nome que o arquivo
    original.  Se houver mais de um parâmetro, o último parâmetro será
    usado como diretório de destino.  Por exemplo
      </para>

      <screen>
$ <userinput>cp arquivo1 arquivo2 algumdir</userinput>
      </screen>

      <para>
    vai copiar tanto o <filename>arquivo1</filename> quanto o
    <filename>arquivo2</filename> para o diretório
    <filename>algumdir</filename>.  Você não pode copiar múltiplos
    arquivos para um arquivo.  Vamos usar o <command>cat</command> para
    isto: <!-- XXX href -->
      </para>

      <screen>
$ <userinput>cat arquivo1 arquivo2 > arquivo_combinado</userinput>
      </screen>

      <para>
    Você também pode user <command>cp</command> para copiar diretórios,
    adicionando o parâmetro <parameter class="command">-R</parameter>.
    Isto irá copiar recursivamente um diretório e todos os seus
    subdiretórios.  Se o diretório destino existir, o diretório ou
    diretórios de origem serão postos dentro do diretório destino.  Se o
    diretório destino não existir.  Se o diretório destino não existir,
    será criado se houver um único diretório de origem.
      </para>

      <screen>
$ <userinput>cp -r minhaarvore arvore_copia</userinput>
$ <userinput>mkdir arvores</userinput>
$ <userinput>cp -r minhaarvore arvores</userinput>
      </screen>

      <para>
    Depois de executar estes comandos, haverá duas cópias do diretório 
        <filename>minhaarvore</filename>,
        <filename>arvore_copia</filename> e
        <filename>arvores/minhaarvore</filename>.  Tentar copiar dois
        diretórios para um destino inexistente irá falhar:
      </para>

      <screen>
$ <userinput>cp -R minhaarvore minhaarvore2 novodir</userinput>
usage: cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target
       cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory
      </screen>

      <note>
	<para>
      Tradicionalmente, o <parameter class="command">-r</parameter>
      estava disponível em muitos sistemas UNIX para cópia recursiva de
      diretórios.  No entanto, o comportamento deste parâmetro pode
      depender da implementação, e na versão 3 da Single UNIX
      Specification consta que este parâmetro pode ser removido em
      implementações futuras do padrão.
	</para>
      </note>

      <para>
    Quando você estiver copiando arquivos recursivamente, é uma boa idéia
    especificar o comportamento que o <command>cp</command> deve ter
    ao encontrar um link simbólico explicitamente, se você quiser usar o
    <command>cp</command> em scripts portáveis.  A versão 3 da Single
    UNIX Specification não define como isto deve ser tratado por padrão.
	Se <parameter class="command">-P</parameter> for usado, links
    simbólicos não serão seguidos, resultando efetivamente na cópia do
    link em si.  Se <parameter class="command">-H</parameter> for usado,
    links simbólicos especificdos como um parâmetro para o
    <command>cp</command> podem ser seguidos, dependendo di tipo do
    arquivo.  Se <parameter class="command">-L</parameter> for usado,
    links simbólicos especificados como parâmetro para o
    <command>cp</command> e links simbólicos que forem encontrados
    durante a cópia recursiva serão seguidos, dependendo do conteúdo do
    arquivo.
      </para>

      <para>
    Se você quer preservar a propriedade, os buts SGID/SUID, e os
    momentos de modificação e acesso do arquivo, você pode usar
    o <parameter>-p</parameter>.  Isto tentará preservar estas
    propriedades nas cópias dos arquivos ou diretórios.  Boas
    implementações de <command>cp</command> também provêem algumas
    proteções adicionais - se o arquivo destino já existir, ele não pode
    ser sobrescrito se os metadados relevantes não puderem ser
    preservados.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-moving">
      <title>Movendo arquivos e diretórios</title>

      <para>
    O comando do UNIX para mover arquivos, <command>mv</command>, pode
    mover ou renomear arquivos e diretórios.  O que acontece atualmente
    depende do local dos arquivos ou diretórios.  Se os arquivos de
    origem e de destino estão no mesmo sistema de arquivos, o
    <command>mv</command> comumente apenas cria novos hard links,
    efetivamente renomeando os arquivos ou diretórios.  Se ambos estão
    em sistemas de arquivos diferentes, os arquivos atualmente são
    copiados, e os arquivos ou diretórios de origem são desvinculados.
      </para>

      <para>
	A sintaxe do <command>mv</command> é comparável à do
	<command>cp</command>.  A sintaxe mais básica renomeia
	<filename>arquivo1</filename> para <filename>arquivo2</filename>:
      </para>

      <screen>
$ <userinput>mv arquivo1 arquivo2</userinput>
      </screen>

      <para>
    A mesma sintaxe pode ser usada para dois diretórios também, o que
    vai renomear o diretório dado como primeiro parâmetro para o nome
    especificado no segundo parâmetro.
      </para>

      <para>
    Quando o último parâmetro for um diretório existente, o arquivo ou
    diretório especificado como primeiro parâmetro é copiado para este
    diretório. Neste caso você pode especificar múltiplos arquivos ou
    diretórios também. Por exemplo:
      </para>

      <screen>
$ <userinput>mkdir destinodir</userinput>
$ <userinput>mv arquivo1 diretorio1 destinodir</userinput>
      </screen>

      <para>Isto cria o diretório <filename>destinodir</filename>, e
      move <filename>arquivo1</filename> e
      <filename>diretorio1</filename> para este diretório. </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-removing">
      <title>Removendo arquivos e diretórios</title>

      <para>
    Arquivos e diretórios podem ser removidos com o comando
    <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Este comando desvincula arquivos e diretórios.
        Se não houver outros links para um arquivo, seu inode e seus
        blocos no disco podem ser requisitados por novos arquivos.  Os
        arquivos podem ser removidos informando o nome destes arquivos
        como parâmetro para o 
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Se o arquivo não for gravável, o <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> irá solicitar confirmação. Por exemplo, para
        remover <filename>arquivo1</filename> e
        <filename>arquivo2</filename>, você pode executar: </para>

      <screen>
$ <userinput>rm arquivo1 arquivo2</userinput>
      </screen>

      <para>
      Se você quer remover um número elevado de arquivos que requerem confirmação antes
      de serem deletados, ou se você quer usar <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> para remover arquivos a partir de um script que
        não vai ser executado em um terminal, adicione o parâmetro 
          <parameter class="command">-f</parameter> para evitar diálogos
        de confirmação.  Arquivos sem permissão de escrita, são excluídos
        com o parâmetro <filename>-f</filename> se as permissões do dono
        do arquivo permitirem.  Este parâmetro também vai suprimir a
        exibição de erros para <emphasis>stderr</emphasis> se o arquivo
        a ser excluído não existir. </para>

      <para>Diretórios também podem ser removidos recursivamente com o
        parâmetro <parameter class="command">-r</parameter>.
        <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> vai percorrer a estrutura do diretório, removendo
        links e excluindo diretórios conforme forem encontrados.  A mesma
        semântica é usada como quando arquivos normais são excluídos, da
        mesma forma como o parâmetro
        <parameter class="command">-f</parameter> foi concebido.  Para
        dar um exemplo simples, você pode remover recursivamente todos os
        arquivos e subdiretórios no diretório <filename>notas</filename>
        com: </para>

      <screen>
$ <userinput>rm -r notas</userinput>
      </screen>

      <!-- XXX - descrever o parâmetro -i? -->

      <para> Uma vez que o comando <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> usa a função <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>, blocos de dados não são regravados para um estado não inicializado.  A
        informação em blocos de dados só é sobrescrita quando elas são realocadas e usadas posteriormente.
        Para remover arquivos incluindo seus blocos de dados de forma segura, alguns sistemas disponibilizam um comando
         <citerefentry>
          <refentrytitle>shred</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> que sobrescreve os blocos de dados com dados aleatórios.  Mas isto não
        é efetivo em muitos sistemas de arquivo modernos (com journaling), porque eles não escrevem dados no local. </para>

      <para> O comando <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> provê uma das implementações da função <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>.  É relativamente pouco usável, pois não pode remover 
        diretórios. </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-permissions">
    <title>Permissões</title>

    <para> Nós tocamos no assunto de permissões de arquivos e diretórios em <xref
        linkend="chap-filesystem-introduction-permissions"/>.  Nesta seção, vamos dar uma olhada nos comandos
      <citerefentry>
        <refentrytitle>chown</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry> e <citerefentry>
        <refentrytitle>chmod</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry>, que são usados para definir a propriedade e as permissões de arquivos,
      respectivamente.  Depois disto, vamos conferir uma extensão mais moderna às permissões chamada de
      Listas de Controle de Acesso (ACLs). </para>

    <sect2 xml:id="chap-filesystem-permissions-ownership">
      <title>Alterando o dono de um arquivo</title>

      <para> Como já vimos anteriormente, cada arquivo tem um ID do dono (usuário) e um ID do grupo armazenados no
        inode.  O comando <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> pode ser usado para definir estes campos.  Isto pode ser feito com IDs numéricos
        ou com seus nomes.  Por exemplo, para alterar o dono de um arquivo
        <filename>nota.txt</filename> para <emphasis>john</emphasis>, e seu grupo para 
        <emphasis>staff</emphasis>, o seguinte comando é usado: </para>

      <screen>
$ <userinput>chown john:staff nota.txt</userinput>
      </screen>

      <para> Você também pode omitir qualquer desses componentes, para definir apenas um destes dois campos.  Se você
        quiser definir o nome do usuário, você não precisa informar os dois-pontos.  Assim, o comando acima poderia ser
        realizado em dois passos: </para>

      <screen>
$ <userinput>chown john nota.txt</userinput>
$ <userinput>chown :staff nota.txt</userinput>
      </screen>

      <para> Se você quiser mudar o dono de um diretório, e de todos os arquivos ou subdiretórios contidos
        nele, você pode adicionar um <parameter class="command">-R</parameter> ao <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>: </para>

      <screen>
$ <userinput>chown -R john:staff notas</userinput>
      </screen>

      <para> Se o nome do usuário e do grupo for especificado, ao invés de seus IDs, os nomes são convertidos
        pelo
        <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Esta conversão baseia-se comumente na base de dados de senhas do sistema.  Se você
        está trabalhando em um sistema de arquivos que usa outra base de dados de senhas (p.ex. se você montou
        um sistema de arquivos raíz a partir de outro sistema para recuperação), frequentemente é útil mudar a
        propriedade usando o ID de usuário ou de grupo.  Desta maneira, você pode manter o mapeamento do nome
        do usuário/grupo intacto.  Assim, alterar a propriedade de <filename>nota.txt</filename> para o UID 1000 e
        GUID 1000 é feito da seguinte (e deduzível) maneira: </para>

      <screen>
$ <userinput>chown 1000:1000 nota.txt</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-permbits">
      <title>Modificando os bits de permissão de arquivos</title>

      <para> Depois de ler a introdução às permissões do sistema de arquivos em <xref
          linkend="chap-filesystem-introduction-permissions"/>, alterar os bits de permissão que
          são armazenados no inode é bastante fácil com o comando <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> aceita tanto representações numéricas quanto simbólicas das permissões.
        Representar as permissões de um arquivo numericamente é bastante prático, pois permite definir
        todas as permissões relevantes de uma vez.  Por exemplo: </para>

      <screen>
$ <userinput>chmod 0644 notas.txt</userinput>
      </screen>

      <para> Torna o arquivo <filename>notas.txt</filename> legível e gravável para o dono do arquivo, e
        regível para o grupo do arquivo e outros. </para>

      <para> Permissões simbólicas se prestam a adicionar ou remover permissões, e permitem alterações
        relativas nas permissões de arquivo.  A sintaxe para permissões simbólicas é: </para>

      <screen>
[ugo][-+][rwxst]
      </screen>

      <para> O primeiro componente especifica as classes de usuário às quais a mudança de permissão se aplica
        (usuário, grupo ou outros).  Caracteres múltiplos deste componente podem ser combinados.  O segundo
        componente remove (<emphasis>-</emphasis>) ou adiciona as permissões 
        (<emphasis>+</emphasis>).  O terceiro componente é o descritor de acesso (leitura, escrita, execução,
        uso de UID/GID na execução, e sticky bit).  Múltiplos caracteres podem ser especificados neste componente
        também.  Vamos ver alguns exemplos para tornar isto mais claro: </para>

      <screen>
ug+rw        # Dá permissão de leitura/escrita ao usuário e ao grupo do arquivo
chmod go-x   # Remove a permissão de execução para o grupo do arquivo e para os outros.
chmod ugo-wx # Impossibilita todas as classes de usuário de escrever no arquivo e de executá-lo.
      </screen>

      <para> Estes comandos podem ser usados da seguinte maneira com chmod: </para>

      <screen>
$ <userinput>chmod ug+rw nota.txt</userinput>
$ <userinput>chmod go-x script1.sh</userinput>
$ <userinput>chmod ugo-x script2.sh</userinput>
      </screen>

      <para> As permissões de arquivos e diretórios podem ser alteradas recursivamente com o parâmetro <parameter
          class="command">-R</parameter>.  O seguinte comando torna o diretório 
        <filename>notas</filename> legível a todos, incluindo seu conteúdo: </para>

      <screen>
$ <userinput>chmod -R ugo+r notas</userinput>
      </screen>

      <para> Cuidados extras devem ser tomados com diretórios, porque a permissão <emphasis>x</emphasis>
        tem um significado especial no contexto de diretórios.  Usuários com permissão de execução em diretórios
        podem acessar o diretório.  Usuários que não têm permissões de execução em diretórios não podem.  Devido
        a este comportamente particular, é quase sempre mais fácil mudar as permissões de uma estrutura de
        diretório e de seus arquivos com ajuda do comando <citerefentry>
          <refentrytitle>find</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> <!-- XXX xref -->. </para>

      <para> Há alguns poucos bits extras de permissão que podem ser definidos e que tem um significado especial.  Os
        SUID e SGID são os mais interessantes destes bits extras.  Estes bits modificam o
        ID do usuário ativo ou ID do grupo para aquele usuário ou grupo como o qual o arquivo está
        sendo executado.  O comando <command>su(1)</command> é um bom exemplo de um arquivo que frequentemente tem
        o bit SUID ativado: </para>

      <screen>
$ <userinput>ls -l /bin/su</userinput>
-rwsr-xr-x  1 root root 60772 Aug 13 12:26 /bin/su
      </screen>

      <para> Isso significa que o comando <command>su</command> executa como o usuário 
        <emphasis>root</emphasis> quando executado.  O bit SUID pode ser definido com o modificador
        <emphasis>s</emphasis>.  Por exemplo, se o bit SUID não estivesse atribuído em 
          <filename>/bin/su</filename> isto poderia ser feito com: </para>

      <screen>
$ <userinput>chmod u+s /bin/su</userinput>
      </screen>

      <note>
        <para> Por favor atente que ativas os bits SUID e SGID têm
        implicações de segurança.  Se um programa com estes bits definidos
        contiver um bug, ele poderá ser explorado para obter privilégios
        do dono do arquivo ou grupo.  Por este motivo é uma boa prática deixar
        a quantidade de arquivos com os bits SUID e SGID ativos restritos a
        restritos a um mínimo possível. </para>
      </note>

      <para> O sticky bit também é interessante quando aplicado a um
      diretório.  Ele impossibilita que usuários renomeiem ou excluam
      arquivos que não lhes pertencem, em diretórios que tenham acesso.  
      Isto é comumente usado em diretórios com permissões de escrita para
      todos, como o diretório temporário (<filename>/tmp</filename>) em
      muitos sistemas UNIX.  O sticky bit pode ser atribuído com o
      modificador <emphasis>t</emphasis>: </para>

      <screen>
$ <userinput>chmod g+t /tmp</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-umask">
      <title>Máscara de criação de arquivo</title>

      <para>
    A pergunta que não quer calar é quais as permissões são usadas
    quando um arquvo é criado.  Isto depende de dois fatores: a flag de
    modo que for passada para a chamada de sistema
    <emphasis>open(2)</emphasis>, que é usada para criar um arquivo, e a
    máscara de criação de arquivo ativa.  A máscara de criação de arquivos
    pode ser representada como um número octal.  As permissões efetivas para
    criação do arquivo são determinadas como <emphasis>mode &amp;
	~mask</emphasis>.  Ou, se estiver na representação octal, você pode
	subtrair os dígitos da máscara dos do modo.  Por exemplo, se um arquivo
	é criado com permissões <emphasis>0666</emphasis> (legível e gravável
	pelo usuário do arquivo, pelo grupo e por outros), e a máscara efetiva
	de criação de arquivo for <emphasis>0022</emphasis>, a permissão do
	resultante do arquivo será <emphasis>0644</emphasis>.  Vamos ver outro
	exemplo.  Suponha que arquivos ainda são criados com as permissões 
	<emphasis>0666</emphasis>, e você é mais paranóico, e quer remover
	todas as permissões de leitura e escrita do grupo do arquivo e dos
	outros.  Isto quer dizer que você deve definir a máscara de criação
	de arquivos para <emphasis>0066</emphasis>, já que
	subtraindo <emphasis>0066</emphasis> de 
	<emphasis>0666</emphasis> resulta em 
	<emphasis>0600</emphasis>
      </para>
      
      <para>
        O valor da máscara de criação de arquivos pode ser consultado com
        o comando <command>umask</command>, que normalmente já existe 
        como comando do próprio shell.  A máscara eftiva pode ser exibida
        executando <command>umask</command> sem nenhum parâmetro:
      </para>
      
      <screen>
$ <userinput>umask</userinput>
0002
      </screen>
      
      <para>
        O valor da máscara pode ser definido atribuindo um número octal
        como parâmetro.  Por exemplo:
      </para>
      
      <screen>
$ <userinput>umask 0066</userinput>
      </screen>
      
      <para>
        E podemos verificar que isso funciona criando um arquivo vazio:
      </para>
      
      <screen>
$ <userinput>touch test</userinput>
$ <userinput>ls -l test</userinput>
-rw-------  1 daniel daniel 0 Oct 24 00:10 test2
      </screen>
      
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-acl">
      <title>Listas de Controle de Acesso</title>

      <para>
    Listas de Controle de Acesso (<acronym>ACL</acronym>s) são uma
    extensão às permissões de arquivos tradicionais do UNIX que permitem
    um controle de acesso mais específico.  Muitos sistemas que suportam
    sistemas de arquivos ACLs as implementam tal como especificado nos
    projetos das espeficicações POSIX.1e e POSIX.2c.  Exemplos de
    sistemas UNIX e UNIX-like que implementam ACLs de acordo com estas
    especificações são FreeBSD, Solaris e Linux.
      </para>

      <para>
    Como vimos em <xref
	linkend="chap-filesystem-introduction-permissions" /> listas de
    controle de acesso permitem a você usar trincas de leitura, escrita
    e execução adicionais para usuários ou grupos.  Diferentemente das
    permissões de arquivo tradicionais, listas de controle de acesso
    adicionais não são armazenadas diretamente no inode, mas em
    atributos extendidos que são associados aos arquivos.  Duas coisas
    com que precisamos ter cuidado ao usar listas de controle de acesso
    é que nem todos os sistemas as suportam, e também nem todos os
    programas dão suporte a elas.
      </para>

      <sect3 xml:id="chap-filesystem-permissions-acl-reading">
	<title>Lendo listas de controle de acesso</title>

	<para>
      Na maioria dos sistemas que suportam ACLs, o comando
      <command>ls</command> usa um indicador visual para mostrar que há
      ACLs associadas ao arquivo.  Por exemplo:
	</para>

	<screen>
$ <userinput>ls -l index.html</userinput>
-rw-r-----+ 1 daniel daniel 3254 2006-10-31 17:11 index.html
	</screen>

	<para>
      Como você pode ver, a coluna de permissões mostra um sinal de mais
	  (<emphasis>+</emphasis>) adicional.  Os bits de permissão não agem
      exatamente da forma como você espera que eles ajam.  Vamos ver
      isso em instantes.
	</para>

	<para>
      As ACLs para um arquivo podem ser consultadas com o comando 
	  <command>getfacl</command>:
	</para>

	<screen>
$ <userinput>getfacl index.html</userinput>
# file: index.html
# owner: daniel
# group: daniel
user::rw-
group::---
group:www-data:r--
mask::r--
other::---
	</screen>

	<para>
      Muitas linhas podem ser facilmente interpretadas: o usuário do
      arquivo tem permissões de leitura/escrita, o grupo do arquivo não
      tem quaisquer permissões, usuários do grupo
      <emphasis>www-data</emphasis> têm permissão de leitura, e outros
      usuários também não têm permissões.  Mas por que esta saída mostra
      que não há permissões para o grupo do arquivo enquanto que o
      comando <command>ls</command> mostra permissão de leitura?  O
      segredo é que se houver uma entrada chamada
      <emphasis>mask</emphasis>, o <command>ls</command> exibirá o valor
      da máscara, ao invés das permissões do grupo do arquivo.
	</para>

	<para>
      A entrada <emphasis>mask</emphasis> é usada para restringir todas
      as entradas da listagem exceto a do usuário do arquivo, e a dos
      outros usuários.  Para interpretar ACLs, é melhor memorizar as
      seguintes regras:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
          As permissões da entrada <emphasis>user::</emphasis>
          correspondem às permissões do dono do arquivo.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
          As permissões da entrada <emphasis>group::</emphasis>
          correspondem às permissões do grupo do arquivo, a menos que
          haja uma entrada <emphasis>mask::</emphasis>.  Se houver uma
          entrada <emphasis>mask::</emphasis>, as permissões do grupo
          correspondem à entrada de grupo tendo a entrada de máscara
          como o máximo de permissões permitidas (significando que as
          restrições de grupo podem ser mais restritivas, mas não mais
          permissivas).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
          As permissões de outros usuários e grupos correspondem às suas
          entradas <emphasis>user:</emphasis> e
          <emphasis>group:</emphasis>, com o valor de 
	      <emphasis>mask::</emphasis> como suas permissões máximas.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
      A segunda e terceira regras podem ser claramente observadas se
      houver um usuário ou grupo que tenha mais permissões que a máscara
      para o arquivo:
	</para>

	<screen>
$ <userinput>getfacl links.html</userinput>
# file: links.html
# owner: daniel
# group: daniel
user::rw-
group::rw-                      #effective:r--
group:www-data:rw-              #effective:r--
mask::r--
other::---
	</screen>

	<para>
      Ainda que as permissões de leitura e escrita sejam especificadas
      para o grupo do arquivo e para o grupo
      <emphasis>www-data</emphasis>, ambos os grupos efetivamente terão
      apenas permissão de leitura, pois esta é a permissão máxima que a
      máscara permite.
	</para>

	<para>
      Outro aspecto a que devemos prestar atenção é a manipulação de
      ACLs em diretórios.  Listas de controle de acesso podem ser
      adicionadas a diretórios para gerenciar o acesso, mas os
      diretórios podem também ter <emphasis>ACLs padrão</emphasis> as
      quais especificam as ACLs iniciais para arquivos e diretórios
      criados dentro do diretório em questão.
	</para>

	<para>
      Suponha que o diretório <filename>relatorios/</filename> tenha a
      seguinte ACL:
	</para>

	<screen>
$ <userinput>getfacl relatorios</userinput>
# file: relatorios
# owner: daniel
# group: daniel
user::rwx
group::r-x
group:www-data:r-x
mask::r-x
other::---
default:user::rwx
default:group::r-x
default:group:www-data:r-x
default:mask::r-x
default:other::---
	</screen>

	<para>
      Os novos arquivos que forem criados dentro do diretórios 
	  <filename>relatorios</filename> obtém sua ACL baseada nas entradas
      que têm um <emphasis>default:</emphasis> como prefixo.  Por
      exemplo:
	</para>

	<screen>
$ touch relatorios/teste
$ getfacl reportorios/teste
# file: reportorios/teste
# owner: daniel
# group: daniel
user::rw-
group::r-x                      #effective:r--
group:www-data:r-x              #effective:r--
mask::r--
other::---
	</screen>

	<para>
      Como você pode ver, a ACL padrão foi copiada.  O bit de execução
      foi removido da máscara, pois o novo arquivo não foi criado com
      permissão de execução.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-permissions-acl-setting">
	<title>Criando listas de controle de acesso</title>

	<para>
      A ACL para um arquivo ou diretório pode ser modificada com o
      comando <command>setfacl</command>.  Infelizmente, sua utilização
      é fortemente dependente do sistema em que está sendo usado.  Para
      aumentar a confusão, pelo menos uma opção importante (<parameter
      class="command">-d</parameter>) tem significados diferentes em
      diferentes sistemas.  Pode-se apenas esperar que este comando seja
      padronizado algum dia.
	</para>

	<table xml:id="chap-filesystem-permissions-acl-setting-flags">
	  <title>Opções específicas de sistemas do <command>setfacl</command></title>
	  
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operação</entry>
		<entry>Linux</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Define entradas, removendo todas as entradas antigas</entry>
		<entry><parameter class="command">--set</parameter></entry>
	      </row>
	      <row>
		<entry>Modifica entradas</entry>
		<entry><parameter class="command">-m</parameter></entry>
	      </row>
	      <row>
		<entry>Modifica as entradas ACL padrão</entry>
		<entry><parameter class="command">-d</parameter></entry>
	      </row>
	      <row>
		<entry>Remove entradas</entry>
		<entry><parameter class="command">-x</parameter></entry>
	      </row>
	      <row>
		<entry>
		  Remove todas as entradas ACL (exceto as três entradas que são
          requeridas.)
		</entry>
		<entry><parameter class="command">-b</parameter></entry>
	      </row>
	      <row>
		<entry>Recalcula a máscara</entry>
		<entry>
          Sempre recalculada, a menos que <parameter
		  class="command">-n</parameter> seja usado, ou uma entrada de
          máscara seja especificada explicitamente.
		</entry>
	      </row>
	      <row>
		<entry>Usa a especificação ACL a partir de um arquivo</entry>
		<entry>
		  <parameter class="command">-M</parameter> (modificar),
		  <parameter class="command">-X</parameter> (excluir),
		  ou <parameter class="command">--restore</parameter>
		</entry>
	      </row>
	      <row>
		<entry>Modificação recursiva de ACLs</entry>
		<entry><parameter class="command">-R</parameter></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
      Como vimos nas seções anteriores, entradas podem ser especificadas
      para usuários e grupos usando-se a seguinte sintaxe:
	  <emphasis>user/group:name:permissions</emphasis>.  Permissões
      podem ser especificadas como uma tripla através do uso das letras
	  <emphasis>r</emphasis> (leitura), <emphasis>w</emphasis>
	  (escrita), ou <emphasis>x</emphasis> (execução).  Um hífen
	  (<emphasis>-</emphasis>) deve ser usado para as permissões que
      você não quer dar para aquele usuário ou grupo, uma vez que é
      requerido pelo Solaris.  Se você quiser desabilitar o acesso
      completamente, você pode usar a tripla <emphasis>---</emphasis>.
	</para>

	<para>
      A especificação para outros usuários, e a máscara segue este
      formato: <emphasis>other:r-x</emphasis>.  O formato seguinte,
      ligeiramente mais intuitivo, também pode ser usado:
      <emphasis>other::r-x</emphasis>.
	</para>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-modify">
	  <title>Modificando entradas ACL</title>

	  <para>
        A operação mais simples é modificar uma entrada ACL.  Isto vai
        criar uma nova entrada se a entrada ainda não existir.  Entradas
        podem ser modificadas com <parameter
        class="command">-m</parameter>.  Por exemplo, suponha que
        queiramos dar acesso de leitura e escrita para o grupo
        <emphasis>friends</emphasis> ao arquivo
        <filename>report.txt</filename>.  Isto pode ser feito com:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw- report.txt</userinput>
	  </screen>

	  <para>
        A entrada de máscara será recalculada, definindo-a para a união
        dos três grupos de entradas, e as entradas de usuário
        adicionais:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt</userinput>
# file: report.txt
# owner: daniel
# group: daniel
user::rw-
group::r--
group:friends:rw-
mask::rw-
other::r--
	  </screen>

	  <para>
        Você pode combinar múltiplas entradas ACL separando-as por
        vírgulas.  Por exemplo:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw-,group:foes:--- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-removing">
	  <title>Removendo entradas ACL</title>

	  <para>
	    Uma entrada pode ser removida com a opção <parameter
	    class="command">-x</parameter>:
	  </para>

	  <screen>
$ <userinput>setfacl -x group:friends: report.txt</userinput>
	  </screen>

	  <para>
	    O caracter dois-pontos do final é opcional e pode ser omitido.
	  </para>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-new">
	  <title>Criando uma nova ACL</title>

	  <para>
        A opção <parameter class="command">--set</parameter> está
        disponível para a criação de uma nova lista de controle de
        acesso para um arquivo, limpando todas as entradas existentes,
        exceto pelas três entradas requeridas.  É obrigatório que as
        entradas de usuário do arquivo, de grupo e de outros também
        sejam especificadas.  Por exemplo:
	  </para>

	  <screen>
$ <userinput>setfacl --set user::rw-,group::r--,other:---,group:friends:rwx report.txt</userinput>
	  </screen>

	  <para>
        Se você não quer limpar as permissões de usuário, grupo e
        outros, mas quer limpar todas as outras entradas ACL, você pode
        usar a opção <parameter class="command">-b</parameter>.  O
        exemplo seguinte a utiliza em conjunto com a opção <parameter
        class="command">-m</parameter> para limpar todas as entradas ACL
        (exceto para usuário, grupo e outros), e para adicionar uma
        entrada para o grupo <emphasis>friends</emphasis>:
	  </para>

	  <screen>
$ <userinput>setfacl -b -m group:friends:rw- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-default">
	  <title>Definindo uma ACL padrão</title>

	  <para>
	    Como vimos em <xref
	    linkend="chap-filesystem-permissions-acl" />, diretórios podem
	    ter entradas ACL padrão que especifiquem que permissões devem
	    ser usadas por arquivos e diretórios que forem criados dentro
	    desse diretório.  A opção <parameter class="command">-d</parameter>
	    é usada para operar sobre entradas padrão:
	  </para>

	  <screen>
$ <userinput>setfacl -d -m group:friends:rwx reports</userinput>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:friends:rwx
default:mask::rwx
default:other::r-x
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-filesource">
	  <title>Usando uma ACL a partir de um arquivo de referência</title>

	  <para>
	    Você também pode usar uma definição ACL a partir de um arquivo,
	    ao invés de especificá-la na linha de comando.  Um arquivo de
	    entrada segue a mesma sintaxe para especificação de entradas que
	    o <command>setfacl</command>, mas as entradas são separadas por
	    linhas, ao invés de por vírgulas.  Isto é muito útil, já que
	    você pode usar a ACL para um arquivo existente como referência:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt > ref</userinput>
	  </screen>

	  <para>
	    A opção <parameter class="command">-M</parameter> existe para
	    modificar a ACL para um arquivo através da leitura das entradas
	    a partir de um arquivo.  Assim, se tivermos um arquivo chamado
	    <filename>report2.txt</filename>, podemos modificar a ACL para
	    este arquivo com as entradas de <filename>ref</filename> com:
	  </para>

	  <screen>
$ <userinput>setfacl -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Se você quiser iniciar com uma ACL limpa, e adicionar as
	    entradas a partir de <filename>ref</filename>, você pode
	    adicionar o parâmetro <parameter class="command">-b</parameter>
	    que apresentamos anteriormente:
	  </para>

	  <screen>
$ <userinput>setfacl -b -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    É claro, não é necessário sequer usar este arquivo por completo.
	    Podemos canalizar (<foreignphrase>pipe</foreignphrase>) a saída
	    de <command>getfacl</command> diretamente para
	    <command>setfacl</command>, usando o nome simbólico para a
	    entrada padrão (<emphasis>-</emphasis>), ao invés de um nome de
	    arquivo:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt | setfacl -b -M - report2.txt</userinput>
	  </screen>

	  <para>
	    O <parameter class="command">-X</parameter> remove as entradas
	    ACL definidas num arquivo.  Isto segue a mesma sintaxe que o
	    parâmetro <parameter class="command">-x</parameter>, com
	    vírgulas substituídas por novas-linhas.
	  </para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-finding">
    <title>Procurando arquivos</title>

    <sect2 xml:id="chap-filesystem-finding-find">
      <title>find</title>

      <para>
    O comando <command>find</command>, sem dúvida, é o utilitário mais
    compreensível para procurar arquivos em sistemas UNIX.  Pelo fato de
    que fato de que funciona de uma maneira simples e previsível:
	o <command>find</command> irá varrer a árvore ou árvores de
	diretório que forem especificadas como parâmetro para o
	<command>find</command>.  Além disso, um usuário pode especificar
	uma expressão que será avaliada para cada arquivo e diretório.  O
	nome do arquivo ou diretório será exibido se a expressão for
	avaliada para <emphasis>true</emphasis>.  O primeiro argumento que
	inicia com um hífen (<emphasis>-</emphasis>), ponto de exclamação
	(<emphasis>!</emphasis>, ou abre-parênteses (<emphasis>(</emphasis>,
	significa o início da expressão.  A expressão pode consistir de
	vários operandos.  De forma simplificiada, a sintaxe do
	<command>find</command> e: <emphasis>find caminhos expressão</emphasis>.
      </para>

      <para>
    O uso mais simples de <command>find</command> é não especificar
    nenhuma expressão.  Como o comando corresponde cada entrada de
    diretório e subdiretório, todos os arquivos e diretórios serão
    exibidos.  Por exemplo:
      </para>

      <screen>
$ <userinput>find .</userinput>
.
./economic
./economic/report.txt
./economic/report2.txt
./technical
./technical/report2.txt
./technical/report.txt
      </screen>

      <para>
    Você também pode especificar múltiplos diretórios:
      </para>

      <screen>
$ <userinput>find economic technical</userinput>
economic
economic/report.txt
economic/report2.txt
technical
technical/report2.txt
technical/report.txt
      </screen>

      <sect3 xml:id="chap-filesystem-finding-find-nametype">
	<title>Operandos delimitadores por nome ou tipo de objeto</title>

	<para>
	  Um cenário comum para procura de arquivos ou diretórios é
	  procurá-los pelo nome.  O operando <emphasis>-name</emphasis> pode
	  ser usado para corresponder objetos com um dado nome, ou que casem
	  com um determinado coringa.  Por exemplo, usar o operando 
	  <emphasis>-name 'report.txt'</emphasis> irá apenas ser verdadeiro
	  para arquivos ou diretórios com o nome 
	  <filename>report.txt</filename>.  Por exemplo:
	</para>

	<screen>
$ <userinput>find economic technical -name 'report.txt'</userinput>
economic/report.txt
technical/report.txt
	</screen>

	<para>
	  A mesma coisa se aplica quando se usa coringas:
	</para>

	<screen>
$ <userinput>find economic technical -name '*2.txt'</userinput>
economic/report2.txt
technical/report2.txt
	</screen>

	<note>
	  <para>
	    Ao usar o <command>find</command> você vai querer passar o
	    caracter coringa ao <command>find</command>, ao invés de deixar
	    o shell expandí-lo.  Assim, certifique-se de que os padrões ou
	    sejam delimitados por aspas, ou que os coringas sejam escapados.
	  </para>
	</note>

	<para>
	  Também é possível avaliar o tipo dos objetos com o operando
	  <emphasis>-type c</emphasis>, onde <emphasis>c</emphasis>
	  especifica o tipo a ser correspondido.
	  <xref
	  linkend="chap-filesystem-finding-find-nametype-type-params"
	  /> lista os vários tipos de objetos que podem ser usados.
	</para>

	<table xml:id="chap-filesystem-finding-find-nametype-type-params">
	  <title>Parâmetros para o operando '-type'</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Parâmetro</entry><entry>Significado</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>b</entry><entry>Arquivo de dispositivo de block</entry>
	      </row>
	      <row>
		<entry>c</entry><entry>Arquivo de dispositivo de caracter</entry>
	      </row>
	      <row>
		<entry>d</entry><entry>Diretório</entry>
	      </row>
	      <row>
		<entry>f</entry><entry>Arquivo normal</entry>
	      </row>
	      <row>
		<entry>l</entry><entry>Link simbólico</entry>
	      </row>
	      <row>
		<entry>p</entry><entry>FIFO</entry>
	      </row>
	      <row>
		<entry>s</entry><entry>Socket</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Assim, por exemplo, se você quiser encontrar diretórios, você
	  poderia usar o parâmetro <emphasis>d</emphasis> para o operando
	  <emphasis>-type</emphasis>:
	</para>

	<screen>
$ <userinput>find . -type d</userinput>
.
./economic
./technical
	</screen>

	<para>
	  Vamos ver como formar expressões mais complexas ao final desta
	  seção sobre o <command>find</command>, mas neste momento é útil
	  saber que você pode fazer uma expressão booleana 'and'
	  especificando múltiplos operandos.  Por exemplo
	  <emphasis>operando1 operando2</emphasis> é verdadeiro se tanto
	  <emphasis>operando1</emphasis> e
	  <emphasis>operando2</emphasis> forem verdadeiros para o objeto
	  sendo avaliado.  Então, você pode combinar os operandos
	  <emphasis>-name</emphasis> e <emphasis>-type</emphasis> para
	  encontrar todos os diretórios que comecem com
	  <emphasis>eco</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name 'eco*' -type d</userinput>
./economic
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-perms">
	<title>Operandos que especificam a propriedade ou permissões</title>

	<para>
	  Além de casar objetos por seus nomes ou tipos, você também pode
	  procurá-los por suas permissoes ativas ou pela propriedade do
	  objeto.  Isto frequentemente é útil para encontrar arquivos que
	  tenham permissões ou propriedade incorretas.
	</para>

	<para>
	  O dono (usuário) ou grupo de um objeto podem ser correspondidos
	  respectivamente com as opções <emphasis>-user username</emphasis>
	  e <emphasis>-group groupname</emphasis>.  O nome do usuário ou
	  grupo será interpretado como um ID de usuário ou ID de grupo cujo
	  nome é decimal, e poderia não ser encontrado no sistema com 
	  <citerefentry><refentrytitle>getpwnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>
	  ou
	  <citerefentry><refentrytitle>getgrnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
      Assim, se você quiser obter todos os objetos que pertençam ao
      usuário <emphasis>joe</emphasis>, você poderia usar 
	  <emphasis>-user joe</emphasis> como um operando:
	</para>

	<screen>
$ <userinput>find . -user joe</userinput>
./secret/report.txt
	</screen>

	<para>
	  Ou para encontrar todos os objetos que tenham
	  <emphasis>friend</emphasis> como grupo de arquivo:
	</para>

	<screen>
$ <userinput>find . -group friends</userinput>
./secret/report.txt
	</screen>

	<para>
	  The operand for checking file permissions
	  <emphasis>-perm</emphasis> is less trivial. Like the
	  <command>chmod</command> command this operator can work with
	  octal and symbolic permission notations. We will start with
	  looking at the octal notation. If an octal number is
	  specified as a parameter to the <emphasis>-perm</emphasis>
	  operand, it will match all objects that have exactly that
	  permissions. For instance, <emphasis>-perm 0600</emphasis>
	  will match all objects that are only readable and writable
	  by the user, and have no additional flags set:
	</para>

	<screen>
$ <userinput>find . -perm 0600</userinput>
./secret/report.txt
	</screen>

	<para>
	  If a dash is added as a prefix to a number, it will match
	  every object that has at least the bits set that are
	  specified in the octal number. A useful example is to find
	  all files which have at least writable bits set for
	  <emphasis>other</emphasis> users with <emphasis>-perm
	  -0002</emphasis>. This can help you to find device nodes or
	  other objects with insecure permissions.
	</para>

	<screen>
$ <userinput>find /dev -perm -0002</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>

	<note>
	  <para>
	    Some device nodes have to be world-writable for a UNIX
	    system to function correctly. For instance, the
	    <filename>/dev/null</filename> device is always writable.
	  </para>
	</note>

	<para>
	  The symbolic notation of <emphasis>-perm</emphasis>
	  parameters uses the same notation as the
	  <command>chmod</command> command.  Symbolic permissions are
	  built with a file mode where all bits are cleared, so it is
	  never necessary to use a dash to take away rights. This also
	  prevents ambiguity that could arise with the dash
	  prefix. Like the octal syntax, prefixing the permission with
	  a dash will match objects that have at least the specified
	  permission bits set. The use of symbolic names is quite
	  predictable - the following two commands repeat the previous
	  examples with symbolic permissions:
	</para>

	<screen>
$ <userinput>find . -perm u+rw</userinput>
./secret/report.txt
	</screen>

	<screen>
$ <userinput>find /dev -perm -o+w</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-time">
	<title>Operands that limit by object creation time</title>

	<para>
	  There are three operands that operate on time intervals.
	  The syntax of the operand is <emphasis>operand n</emphasis>,
	  where <emphasis>n</emphasis> is the time in days. All three
	  operators calculate a time delta in seconds that is divided
	  by the the number of seconds in a day (86400), discarding
	  the remainder. So, if the delta is one day,
	  <emphasis>operand 1</emphasis> will match for the
	  object. The three operands are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>-atime n</emphasis> - this operand evaluates
	      to true if the initialization time of <command>find</command>
	      minus the last access time of the object equals
	      to <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-ctime n</emphasis> - this operand evaluates
	      to true if the initialization time of
	      <command>find</command> minus the time of the latest
	      change in the file status information equals to
	      <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-mtime n</emphasis> - this operand evaluates
	      to true if the initialization time of
	      <command>find</command> minus the latest file change
	      time equals to <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  So, these operands match if the latest access, change,
	  modification respectively was <emphasis>n</emphasis> days
	  ago. To give an example, the following command shows all
	  objects in <filename>/etc</filename> that have been modified
	  one day ago:
	</para>

	<screen>
$ <userinput>find /etc -mtime 1</userinput>
/etc
/etc/group
/etc/master.passwd
/etc/spwd.db
/etc/passwd
/etc/pwd.db
	</screen>

	<para>
	  The plus or minus sign can be used as modifiers for the meaning
	  of <emphasis>n</emphasis>. <emphasis>+n</emphasis> means more
	  than <emphasis>n</emphasis> days, <emphasis>-n</emphasis>
	  means less than <emphasis>n</emphasis> days. So, to find all
	  files in <filename>/etc</filename> that were modified less
	  than two days ago, you could execute:
	</para>

	<screen>
$ <userinput>find /etc -mtime -2</userinput>
/etc
/etc/network/run
/etc/network/run/ifstate
/etc/resolv.conf
/etc/default
/etc/default/locale
[...]
	</screen>

	<para>
	  Another useful time-based operand is the <emphasis>-newer
	  reffile</emphasis> operand. This matches all files that were
	  modified later that the file with filename
	  <filename>reffile</filename>. The followin example shows how
	  you could use this to list all files that have later modification
	  times than <filename>economic/report2.txt</filename>:
	</para>

	<screen>
$ <userinput>find . -newer economic/report2.txt</userinput>
.
./technical
./technical/report2.txt
./technical/report.txt
./secret
./secret/report.txt
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-depth">
	<title>Operands that affect tree traversal</title>

	<para>
	  Some operands affect the manner in which the
	  <command>find</command> command traverses the tree. The
	  first of these operands is the <emphasis>-xdev</emphasis>
	  operand. <emphasis>-xdev</emphasis> prevents that
	  <command>find</command> decends into directories that have a
	  different device ID, effectively avoiding traversal of other
	  filesystems. The directory to which the filesystem is
	  mounted, is printed, because this operand always returns
	  <emphasis>true</emphasis>. A nice example is a system where
	  <filename>/usr</filename> is mounted on a different filesystem
	  than <filename>/</filename>. For instance, if we search for
	  directories with the name <emphasis>bin</emphasis>, this may
	  yield the following result:
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d</userinput>
/usr/bin
/bin
	</screen>

	<para>
	  But if we add <emphasis>-xdev</emphasis>
	  <filename>/usr/bin</filename> is not found, because it is on
	  a different filesystem (and device):
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d -xdev</userinput>
/bin
	</screen>

	<para>
	  The <emphasis>-depth</emphasis> operand modifies the order
	  in which directories are evaluated. With
	  <emphasis>-depth</emphasis> the contents of a directory are
	  evaluated first, and then the directory itself. This can be
	  witnessed in the following example:
	</para>

	<screen>
$ <userinput>find . -depth</userinput>
./economic/report.txt
./economic/report2.txt
./economic
./technical/report2.txt
./technical/report.txt
./technical
.
	</screen>

	<para>
	  As you can see in the output, files in the
	  <emphasis>./economic</emphasis> directory is evaluated
	  before <filename>.</filename>, and
	  <filename>./economic/report.txt</filename> before
	  <filename>./economic</filename>. <emphasis>-depth</emphasis>
	  always evaluates to <emphasis>true</emphasis>.
	</para>

	<para>
	  Finally, the <emphasis>-prune</emphasis> operand causes find
	  not to decend into a directory that is being evaluated.
	  <emphasis>-prune</emphasis> is discarded if the
	  <emphasis>-depth</emphasis> operand is also
	  used. <emphasis>-depth</emphasis> always evaluates to
	  <emphasis>true</emphasis>.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-exec">
	<title>Operands that execute external utilities</title>

	<para>
	  <command>find</command> becomes a very powerful tool when it
	  is combined with external utilities. This can be done with
	  the <emphasis>-exec</emphasis> operand. There are two
	  syntaxes for the <emphasis>-exec</emphasis> operand. The
	  first syntax is <emphasis>-exec utility arguments
	  ;</emphasis>. The command <emphasis>utility</emphasis> will
	  be executed with the arguments that were specified for each
	  object that is being evaluated. If any of the arguments is
	  <emphasis>{}</emphasis>, these braces will be replaced by
	  the file being evaluated. This is very handy, especially when
	  we consider that, if we use no additional expression syntax,
	  operands will be evaluated from left to right. Let's look at
	  an example:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} \;</userinput>
	</screen>

	<para>
	 The first operand returns true for files that have their
	 permissions set to <emphasis>0666</emphasis>. The second
	 operand executes <emphasis>chmod 0644 filename</emphasis> for
	 each file that is being evaluated. If you were wondering why
	 this command is not executed for every file, that is a good
	 question. Like many other interpreters of expressions,
	 <command>find</command> uses <quote>short-circuiting</quote>.
	 Because no other operator was specified, the logical
	 <emphasis>and</emphasis> operator is automatically is assumed
	 between both operands. If the first operand evaluates to
	 <emphasis>false</emphasis>, it makes no sense to evaluate any
	 further operands, because the complete expression will always
	 evaluate to false. So, the <emphasis>-exec</emphasis> operand
	 will only be evaluated if the first operand is true. Another
	 particularity is that the semi-colon that closes the
	 <emphasis>-exec</emphasis> is escaped, to prevent that the
	 shell parses it.
	</para>

	<para>
	  A nice thing about the <emphasis>-exec</emphasis> operator
	  is that it evaluates to <emphasis>true</emphasis> if the
	  command terminated sucessfully. So, you could also use
	  the <emphasis>-exec</emphasis> command to add additional
	  conditions that are not represented by <command>find</command>
	  operands. For instance, the following command prints
	  all objects ending with <emphasis>.txt</emphasis> that contain
	  the string <emphasis>gross income</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name '*.txt' -exec grep -q 'gross income' {} \; -print</userinput>
./economic/report2.txt
	</screen>

	<para>
	  The <command>grep</command> command will be covered lateron.
	  <!-- XXX - xref --> But for the moment, it is enough to know
	  that it can be used to match text patterns. The
	  <emphasis>-print</emphasis> operand prints the current
	  object path. It is always used implicitly, except when the
	  <emphasis>-exec</emphasis> or <emphasis>-ok</emphasis>
	  operands are used. <!-- XXX - move to introduction? -->
	</para>

	<para>
	  The second syntax of the <emphasis>-exec</emphasis> operand
	  is <emphasis>-exec utility arguments {} +</emphasis>. This
	  gathers a set of all matched object for which the expression
	  is true, and provides this set of files as an argument to
	  the utility that was specified. The first example of the
	  <emphasis>-exec</emphasis> operand can also be written as:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} +</userinput>
	</screen>

	<para>
	  This will execute the <command>chmod</command> command only
	  once, with all files for which the expression is true as its
	  arguments. This operand always returns <emphasis>true</emphasis>.
	</para>

	<para>
	  If a command executed by find returns a non-zero value
	  (meaning that the execution of the command was not
	  succesful), <command>find</command> should also return a
	  non-zero value.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-operators">
	<title>Operators for building complex expressions</title>

	<para>
	  <command>find</command> provides some operators that can be
	  combined to make more complex expressions:
	</para>

	<variablelist>
	  <title>Operators</title>

	  <varlistentry>
	    <term>( expr )</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if
		<emphasis>expr</emphasis> evaluates to
		<emphasis>true</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 [-a] expr2</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if both
		<emphasis>expr1</emphasis> and <emphasis>expr2</emphasis>
		are true. If <emphasis>-a</emphasis> is omitted,
		this operator is implicitly assumed.
	      </para>

	      <para>
		<command>find</command> will use short-circuiting when
		this operator is evaluated: <emphasis>expr2</emphasis>
		will not be evaluated when <emphasis>expr1</emphasis>
		evaluates to <emphasis>false</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 -o expr2</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if either or
		both <emphasis>expr1</emphasis> and
		<emphasis>expr2</emphasis> are true.
	      </para>

	      <para>
		<command>find</command> will use short-circuiting when
		this operator is evaluated: <emphasis>expr2</emphasis>
		will not be evaluated when <emphasis>expr1</emphasis>
		evaluates to <emphasis>true</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>! expr</term>
	    <listitem>
	      <para>
		Negates <emphasis>expr</emphasis>. So, if
		<emphasis>expr</emphasis> evaluates to true, this
		expression will evaluate to <emphasis>false</emphasis>
		and vise versa.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>
	  Since both the parentheses and exclamation mark characters
	  are interpreted by most shells, they should usually be
	  escaped.
	</para>

	<para>
	  The following example shows some operators in action. This
	  command executes <command>chmod</command> for all files that
	  either have their permissions set to
	  <emphasis>0666</emphasis> or <emphasis>0664</emphasis>.
	</para>

	<screen>
$ <userinput>find . \( -perm 0666 -o -perm 0664 \) -exec chmod 0644 {} \;</userinput>
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-which">
      <title>which</title>

      <para>
	The <command>which</command> command is not part of the Single
	UNIX Specification version 3, but it is provided by most
	sysmtems. <command>which</command> locates a command that is
	in the user's path (as set by the PATH environment variable),
	printing its full path. Providing the name of a command as its
	parameter will show the full path:
      </para>

      <screen>
$ <userinput>which ls</userinput>
/bin/ls
      </screen>

      <para>
	You can also query the paths of multiple commands:
      </para>

      <screen>
$ <userinput>which ls cat</userinput>
/bin/ls
/bin/cat
      </screen>

      <para>
        <command>which</command> returns a non-zero return value
	if the command could not be found.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-whereis">
      <title>whereis</title>

      <para>
	This <command>whereis</command> command searches binaries, manual pages and sources of a
	command in some predefined places. For instance, the following
	command shows the path of the <command>ls</command> and the
	<citerefentry><refentrytitle>ls</refentrytitle><manvolnum>1</manvolnum></citerefentry>
	manual page:
      </para>

      <screen>
$ <userinput>whereis ls</userinput>
ls: /bin/ls /usr/share/man/man1/ls.1.gz
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-locate">
      <title>locate</title>

      <para>
        Slackware Linux also provides the
	<command>locate</command> command that searches through a file
	database that can be generated periodically with the
	<command>updatedb</command> command. Since it uses a prebuilt
	database of the filesystem, it is a lot faster than
	<command>command</command>, especially when directory entry
	information has not been cached yet. Though, the
	<command>locate</command>/<command>updatedb</command> combo
	has some downsides:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    New files are not part of the database until the next
	    <command>updatedb</command> invocation.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <command>locate</command> has no conception of
	    permissions, so users may locate files that are normally
	    hidden to them.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    A newer implementation, named <emphasis>slocate</emphasis>
	    deals with permissions, but requires elevated privileges.
	    This is the <command>locate</command> variation that is
	    included with Slackware Linux.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	With filesystems becoming faster, and by applying common sense
	when formulating <command>find</command> queries,
	<command>locate</command> does not really seem worth the
	hassle. Of course, your mileage may vary. That said, the basic
	usage of <command>locate</command> is <emphasis>locate
	filename</emphasis>. For example:
      </para>

      <screen>
$ <userinput>locate locate</userinput>
/usr/bin/locate
/usr/lib/locate
/usr/lib/locate/bigram
/usr/lib/locate/code
/usr/lib/locate/frcode
[...]
      </screen>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-archives">
    <title>Archives</title>

    <sect2 xml:id="basics-filesystem-archives-introduction">
      <title>Introduction</title>

      <para>
	Sooner or later a GNU/Linux user will encounter
	<acronym>tar</acronym> archives, tar is the standard format
	for archiving files on GNU/Linux.  It is often used in
	conjunction with <command>gzip</command> or
	<command>bzip2</command>. Both commands can compress files and
	archives.  <xref linkend="archive-extentions" /> lists
	frequently used archive extensions, and what they mean.
      </para>

      <table xml:id="archive-extentions">
	<title>Archive file extensions</title>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Extension</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>.tar</entry>
	      <entry>An uncompressed tar archive</entry>
	    </row>
	    <row>
	      <entry>.tar.gz</entry>
	      <entry>A tar archive compressed with gzip</entry>
	    </row>
	    <row>
	      <entry>.tgz</entry>
	      <entry>A tar archive compressed with gzip</entry>
	    </row>
	    <row>
	      <entry>.tar.bz2</entry>
	      <entry>A tar archive compressed with bzip2</entry>
	    </row>
	    <row>
	      <entry>.tbz</entry>
	      <entry>A tar archive compressed with bzip2</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	The difference between <command>bzip2</command> and
	<command>gzip</command> is that <command>bzip2</command> can
	find repeating information in larger blocks, resulting in
	better compression. But <command>bzip2</command> is also a lot
	slower, because it does more data analysis.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-extracting">
      <title>Extracting archives</title>

      <para>
	Since many software and data in the GNU/Linux world is
	archived with <command>tar</command> it is important to get
	used to extracting tar archives. The first thing you will
	often want to do when you receive a tar archive is to list its
	contents. This can be achieved by using the <parameter
	class="command">t</parameter> parameter. However, if we just
	execute <command>tar</command> with this parameter and the
	name of the archive it will just sit and wait until you enter
	something to the standard input:
      </para>

      <screen>
$ <userinput>tar t test.tar</userinput>
      </screen>

      <para>
	This happens because <command>tar</command> reads data from
	its standard input. If you forgot how redirection works, it is
	a good idea to reread <xref linkend="chap-shell-inout" />. Let's
	see what happens if we redirect our tar archive to tar:
      </para>

      <screen>
$ <userinput>tar t &lt; test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	That looks more like the output you probably expected. This
	archive seems to contain a directory
	<filename>test</filename>, which contains the files
	<filename>test2</filename> and <filename>test2</filename>.  It
	is also possible to specify the archive file name as an
	parameter to <command>tar</command>, by using the <parameter
	class="command">f</parameter> parameter:
      </para>

      <screen>
$ <userinput>tar tf test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	This looks like an archive that contains useful files ;). We
	can now go ahead, and extract this archive by using the
	<parameter class="command">x</parameter> parameter:
      </para>

      <screen>
$ <userinput>tar xf test.tar</userinput>
      </screen>

      <para>
	We can now verify that tar really extracted the archive by
	listing the contents of the directory with
	<command>ls</command>:
      </para>

      <screen>
$ <userinput>ls test/</userinput>
test1  test2
      </screen>

      <para>
	Extracting or listing files from a gzipped or bzipped archive
	is not much more difficult. This can be done by adding a
	<parameter class="command">z</parameter> or <parameter
	class="command">b</parameter> for respectively archives
	compressed with <command>gzip</command> or
	<command>bzip2</command>.  For example, we can list the
	contents of a gzipped archive with:
      </para>

      <screen>
$ <userinput>tar ztf archive2.tar.gz</userinput>
      </screen>

      <para>
	And a bzipped archive can be extracted with:
      </para>

      <screen>
$ <userinput>tar bxf archive3.tar.bz2</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-creating">
      <title>Creating archives</title>

      <para>
	You can create archives with the <parameter
	class="command">c</parameter> parameter. Suppose that we have
	the directory <filename>test</filename> shown in the previous
	example. We can make an archive with the
	<filename>test</filename> directory and the files in this
	directory with:
      </para>

      <screen>
$ <userinput>tar cf important-files.tar test</userinput>
      </screen>

      <para>
	This will create the <filename>important-files.tar</filename>
	archive (which is specified with the <parameter
	class="command">f</parameter> parameter). We can now verify
	the archive:
      </para>

      <screen>
$ <userinput>tar tf important-files.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Creating a gzipped or bzipped archive goes along the same
	lines as extracting compressed archives: add a <parameter
	class="command">z</parameter> for gzipping an archive, or
	<parameter class="command">b</parameter> for bzipping an
	archive. Suppose that we wanted to create a
	<command>gzip</command> compressed version of the archive
	created above. We can do this with:
      </para>

      <screen>
<userinput>tar zcf important-files.tar.gz test</userinput>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-mounting">
    <title>Mounting filesystems</title>

    <sect2 xml:id="basics-filesystem-mounting-introduction">
      <title>Introduction</title>

      <para>
	Like most Unices Linux uses a technique named
	<quote>mounting</quote> to access filesystems. Mounting means
	that a filesystem is connected to a directory in the root
	filesystem. One could for example mount a CD-ROM drive to the
	<filename>/mnt/cdrom</filename> directory. Linux supports many
	kinds of filesystems, like Ext2, Ext3, ReiserFS, JFS, XFS,
	ISO9660 (used for CD-ROMs), UDF (used on some DVDs) and
	DOS/Windows filesystems, like FAT, FAT32 and NTFS. These
	filesystems can reside on many kinds of media, for example
	hard drives, CD-ROMs and Flash drives. This section explains
	how filesystems can be mounted and unmounted.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-mount">
      <title>mount</title>

      <para>
	The <command>mount</command> is used to mount filesystems. The
	basic syntax is: <quote>mount /dev/devname
	/mountpoint</quote>. The device name can be any block device,
	like hard disks or CD-ROM drives. The mount point can be an
	arbitrary point in the root filesystem. Let's look at an
	example:
      </para>

      <screen>
# <userinput>mount /dev/cdrom /mnt/cdrom</userinput>
      </screen>

      <para>
	This mounts the <filename>/dev/cdrom</filename> on the
	<filename>/mnt/cdrom</filename> mountpoint. The
	<filename>/dev/cdrom</filename> device name is normally a link
	to the real CD-ROM device name (for example,
	<filename>/dev/hdc</filename>). As you can see, the concept is
	actually very simple, it just takes some time to learn the
	device names ;). Sometimes it is necessary to specify which
	kind of filesystem you are trying to mount.  The filesystem
	type can be specified by adding the <parameter
	class="command">-t</parameter> parameter:
      </para>

      <screen>
# <userinput>mount -t vfat /dev/sda1 /mnt/flash</userinput>
      </screen>

      <para>
	This mounts the vfat filesystem on
	<filename>/dev/sda1</filename> to
	<filename>/mnt/flash</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-umount">
      <title>umount</title>

      <para>
	The <command>umount</command> command is used to unmount
	filesystems.  <command>umount</command> accepts two kinds of
	parameters, mount points or devices. For example:
      </para>

      <screen>
# <userinput>umount /mnt/cdrom</userinput>
# <userinput>umount /dev/sda1</userinput>
      </screen>

      <para>
	The first command unmounts the filesystem that was mounted on
	<filename>/mnt/cdrom</filename>, the second commands unmounts
	the filesystem on <filename>/dev/sda1</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-fstab">
      <title>The fstab file</title>

      <para>
	The GNU/Linux system has a special file,
	<filename>/etc/fstab</filename>, that specifies which
	filesystems should be mounted during the system boot.  Let's
	look at an example:
      </para>

      <screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
      </screen>

      <para>
	As you can see each entry in the <filename>fstab</filename>
	file has five entries: fs_spec, fs_file, fs_vfstype,
	fs_mntops, fs_freq, and fs_passno.  We are now going to look
	at each entry.
      </para>

      <sect3>
	<title>fs_spec</title>

	<para>
	  The fs_spec option specifies the block device, or remote
	  filesystem that should be mounted. As you can see in the
	  example several /dev/hda partitions are specified, as well
	  as the CD-ROM drive and floppy drive. When NFS volumes are
	  mounted an IP address and directory can be specified, for
	  example: <filename>192.168.1.10:/exports/data</filename>.
	</para>
      </sect3>

      <sect3>
	<title>fs_file</title>

	<para>
	  fs_file specifies the mount point. This can be an arbitrary
	  directory in the filesystem.
	</para>
      </sect3>

      <sect3>
	<title>fs_vfstype</title>

	<para>
	  This option specifies what kind of filesystem the entry
	  represents. For example this can be: ext2, ext3, reiserfs,
	  xfs, nfs, vfat, or ntfs.
	</para>
      </sect3>

      <sect3>
	<title>fs_mntops</title>

	<para>
	  The fs_mntops option specifies which parameters should be
	  used for mounting the filesystem. The
	  <command>mount</command> manual page has an extensive
	  description of the available options. These are the most
	  interesting options:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>noauto</emphasis>: filesystems that are listed
	      in <filename>/etc/fstab</filename> are normally mounted
	      automatically. When the <quote>noauto</quote> option is
	      specified, the filesystem will not be mounted during the
	      system boot, but only after issuing a
	      <command>mount</command> command. When mounting such
	      filesystem, only the mount point or device name has to
	      be specified, for example: <command>mount
	      /mnt/cdrom</command>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>user</emphasis>: adding the
	      <quote>user</quote> option will allow normal users to
	      mount the filesystem (normally only the superuser is
	      allowed to mount filesystems).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>owner</emphasis>: the <quote>owner</quote>
	      option will allow the owner of the specified device to
	      mount the specified device. You can see the owner of a
	      device using <command>ls</command>, e.g.  <command>ls -l
	      /dev/cdrom</command>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>noexec</emphasis>: with this option enabled
	      users can not run files from the mounted
	      filesystem. This can be used to provide more security.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>nosuid</emphasis>: this option is comparable
	      to the <quote>noexec</quote> option. With
	      <quote>nosuid</quote> enabled SUID bits on files on the
	      filesystem will not be allowed. SUID is used for certain
	      binaries to provide a normal user to do something
	      privileged.  This is certainly a security threat, so
	      this option should really be used for removable media,
	      etc. A normal user mount will force the nosuid option,
	      but a mount by the superuser will not!
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>unhide</emphasis>: this option is only
	      relevant for normal CD-ROMs with the ISO9660
	      filesystem. If <quote>unhide</quote> is specified hidden
	      files will also be visible.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>fs_freq</title>

	<para>
	  If the <quote>fs_freq</quote> is set to 1 or higher, it
	  specifies after how many days a filesystem dump (backup) has
	  to be made. This option is only used when <ulink
	  url="http://dump.sourceforge.net/">dump</ulink> is
	  installed, and set up correctly to handle this.
	</para>
      </sect3>

      <sect3>
	<title>fs_passno</title>

	<para>
	  This field is used by <command>fsck</command> to determine
	  the order in which filesystems are checked during the system
	  boot.
	</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="basics-filesystem-gnupg">
    <title>Encrypting and signing files</title>

    <sect2>
      <title>Introduction</title>

      <para>
	There are two security mechanisms for securing files: signing
	files and encrypting files. Signing a file means that a
	special digital signature is generated for a file. You, or
	other persons can use the signature to verify the integrity of
	the file. File encryption encodes a file in a way that only a
	person for which the file was intended to read can read the
	file.
      </para>

      <para>
	This system relies on two keys: the private and the public
	key. Public keys are used to encrypt files, and files can only
	be decrypted with the private key. This means that one can
	sent his public key out to other persons. Others can use this
	key to send encrypted files, that only the person with the
	private key can decode. Of course, this means that the
	security of this system depends on how well the private is
	kept secret.
      </para>

      <para>
	Slackware Linux provides an excellent tool for signing and
	encrypting files, named GnuPG. GnuPG can be installed from the
	<quote>n</quote> disk set.
      </para>
    </sect2>

    <sect2>
      <title>Generating your private and public keys</title>

      <para>
	Generating public and private keys is a bit complicated,
	because GnuPG uses DSA keys by default. DSA is an encryption
	algorithm, the problem is that the maximum key length of DSA
	is 1024 bits, this is considered too short for the longer
	term. That is why it is a good idea to use 2048 bit RSA
	keys. This section describers how this can be done.
      </para>

      <note>
	<para>
	  1024-bit keys were believed to be secure for a long
	  time. But Bernstein's paper <emphasis>Circuits for Integer
	  Factorization: a Proposal</emphasis> contests this, the
	  bottom line is that it is quite feasible for national
	  security agencies to produce hardware that can break keys in
	  a relatively short amount of time.  Besides that it has be
	  shown that 512-bit RSA keys can be broken in a relatively
	  short time using common hardware. More information about
	  these issues can by found in this e-mail to the cypherpunks
	  list:
	<ulink url="http://lists.saigon.com/vault/security/encryption/rsa1024.html" />
	</para>
      </note>

      <para>
	We can generate a key by executing:
      </para>

      <screen>
$ <userinput>gpg --gen-key</userinput>
      </screen>

      <para>
	The first question is what kind of key you would like to
	make. We will choose <emphasis>(4) RSA (sign only)</emphasis>:
      </para>

      <screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <userinput>4</userinput>
      </screen>

      <para>
	You will then be asked what the size of the key you want to
	generate has to be. Type in <emphasis>2048</emphasis> to
	generate a 2048 bit key, and press enter to continue.
      </para>

      <screen>
What keysize do you want? (1024) <userinput>2048</userinput>
      </screen>

      <para>
	The next question is simple to answer, just choose what you
	like. Generally speaking it is not a bad idea to let the key
	be valid infinitely. You can always deactivate the key with a
	special revocation certificate.
      </para>

      <screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	GnuPG will then ask for confirmation. After confirming your
	name and e-mail address will be requested. GnuPG will also ask
	for a comment, you can leave this blank, or you could fill in
	something like <quote>Work</quote> or <quote>Private</quote>,
	to indicate what the key is used for. For example:
      </para>

      <screen>
Real name: <userinput>John Doe</userinput>
Email address: <userinput>john@doe.com</userinput>
Comment: <userinput>Work</userinput>              
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	GnuPG will the ask you to confirm your user ID. After
	confirming it GnuPG will ask you to enter a password. Be sure
	to use a good password:
      </para>

      <screen>
You need a Passphrase to protect your secret key.    

Enter passphrase:
      </screen>

      <para>
	After entering the password twice GnuPG will generate the
	keys. But we are not done yet. GnuPG has only generated a key
	for signing information, not for encryption of information. To
	continue, have a look at the output, and look for the key
	ID. In the information about the key you will see
	<emphasis>pub 2048R/</emphasis>. The key ID is printed after
	this fragment.  In this example:
      </para>

      <screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
      </screen>

      <para>
	the key ID is <emphasis>8D080768</emphasis>. If you lost the
	output of the key generation you can still find the key ID in
	the output of the <command>gpg --list-keys</command>
	command. Use the key ID to tell GnuPG that you want to edit
	your key:
      </para>

      <screen>
$ <userinput>gpg --edit-key &lt;Key ID&gt;</userinput>
      </screen>

      <para>
	With the example key above the command would be:
      </para>

      <screen>
$ <userinput>gpg --edit-key 8D080768</userinput>
      </screen>

      <para>
	GnuPG will now display a command prompt. Execute the
	<command>addkey</command> command on this command prompt:
      </para>

      <screen>
Command&gt; <userinput>addkey</userinput>
      </screen>

      <para>
	GnuPG will now ask the password you used for your key:
      </para>

      <screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	After entering the password GnuPG will ask you what kind of
	key you would like to create. Choose <emphasis>RSA (encrypt
	only)</emphasis>, and fill in the information like you did
	earlier (be sure to use a 2048 bit key).  For example:
      </para>

      <screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <userinput>5</userinput>
What keysize do you want? (1024) <userinput>2048</userinput>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	And confirm that the information is correct. After the key is
	generated you can leave the GnuPG command prompt, and save the
	new key with the <command>save</command> command:
      </para>

      <screen>
Command&gt; <userinput>save</userinput>
      </screen>

      <para>
	Congratulations! You have now generated the necessary keys to
	encrypt and decrypt e-mails and files. You can now configure
	your e-mail client to use GnuPG. It is a good idea to store
	the contents of the <filename>.gnupg</filename> directory on
	some reliable medium, and store that in a safe place! If your
	private key is lost you can't decrypt files and messages that
	were encrypted with your public key. If the private key, and
	your password are stolen, the security of this system is
	completely compromised.
      </para>
    </sect2>

    <sect2>
      <title>Exporting your public key</title>

      <para>
	To make GnuPG useful, you have to give your public key to
	people who send you files or e-mails. They can use your public
	key to encrypt files, or use it to verify whether a file has a
	correct signature or not. The key can be exported using the
	<parameter class="command">--export</parameter> parameter. It
	is also a good idea to specify the <parameter
	class="command">--output</parameter> parameter, this will save
	the key in a file. The following command would save the public
	key of <emphasis>John Doe</emphasis>, used in earlier
	examples, to the file <filename>key.gpg</filename>:
      </para>

      <screen>
$ <userinput>gpg --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	This saves the key in binary format. Often it is more
	convenient to use the so-called <quote>ASCII armored
	output</quote>, which fits better for adding the key to
	e-mails, or websites. You export an ASCII armored version of
	the key by adding the <parameter
	class="command">--armor</parameter> parameter:
      </para>

      <screen>
$ <userinput>gpg --armor --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	If you look at the <filename>key.gpg</filename> file you will
	notice that the ASCII armored key is a much more comfortable
	format.
      </para>
    </sect2>

    <sect2>
      <title>Signatures</title>

      <para>
	With GPG you can make a signature for a file. This signature
	is unique, because your signature can only be made with your
	private key. This means that other people can check whether
	the file was really sent by you, and whether it was in any way
	altered or not. Files can be signed with the <parameter
	class="command">--detach-sign</parameter> parameter. Let us
	look at an example. This command will make a signature for the
	<filename>memo.txt</filename> file. The signature will be
	stored in <filename>memo.txt.sig</filename>.
      </para>

      <screen>
$ <userinput>gpg --output memo.txt.sig --detach-sign memo.txt</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	As you can see, GnuPG will ask you to enter the password for
	your private key. After you have entered the right key the
	signature file (<filename>memo.txt.sig</filename>) will be
	created.
      </para>

      <para>
	You can verify a file with its signature using the <parameter
	class="command">--verify</parameter> parameter. Specify the
	signature file as a parameter to the <parameter
	class="command">--verify</parameter> parameter. The file that
	needs to be verified can be specified as the final parameter:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	This will confirm that the file was indeed signed by
	<emphasis>John Doe (Work) &lt;john@doe.com&gt;</emphasis>,
	with the key <emphasis>8D080768</emphasis>, and that the file
	is unchanged. Suppose the file was changed, GnuPG would have
	complained about it loudly:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>
    </sect2>

    <sect2>
      <title>Encryption</title>

      <para>
	One of the main features of GnuPG is encryption. Due to its
	use of asymmetric cryptography, the person who encrypts a file
	and the person who decrypts a file do not need to share a
	key. You can encrypt a file with the public key of another
	person, and that other person can decrypt it with his or her
	private key. You can encrypt files with the <parameter
	class="command">--encrypt</parameter>. If you do not specify a
	user ID for which the file should be encrypted, GnuPG will
	prompt for the user ID. You can specify the user ID with the
	<parameter class="command">-r</parameter> parameter. In the
	following example, the file <filename>secret.txt</filename>
	will be encrypted for another person named <emphasis>John
	Doe</emphasis>:
      </para>

      <screen>
$ <userinput>gpg --encrypt -r "John Doe" secret.txt</userinput>
      </screen>

      <para>
	The user ID is quoted with double quotes for making sure that
	the ID is interpreted as a single program argument. After the
	encryption is completed, the encrypted version of the file
	will be available as <filename>secret.txt.gpg</filename>.
      </para>

      <para>
	The user who receives the file can decrypt it with the
	<parameter class="command">--decrypt</parameter> parameter of
	the <command>gpg</command> command:
      </para>

      <screen>
$ <userinput>gpg --output secret.txt --decrypt secret.txt.gpg</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16 (main key ID EC3ED1AB)

Enter passphrase:

gpg: encrypted with 2048-bit RSA key, ID 8D080768, created 2004-07-16
      "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	In this example the <parameter
	class="command">--output</parameter> parameter is used store
	the decrypted content in <filename>secret.txt</filename>.
      </para>
    </sect2>
  </sect1>
</chapter>
