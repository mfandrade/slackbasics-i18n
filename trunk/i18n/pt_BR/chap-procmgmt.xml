<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="en"
	 xml:id="chap-procmgmt">

  <title>Gerência de processos</title>

  <sect1 xml:id="chap-procmgmt-theory">
    <title>Teoria</title>

    <sect2 xml:id="chap-procmgmt-theory-proc">
      <title>Processos</title>

      <para>
    Uma instância de um programa que está executando é 
    chamada de <emphasis>processo</emphasis>. Cada processo
    tem sua própria área de memória chamada de <emphasis>espaço de 
        endereçamento</emphasis> do processo. Esse espaço de endereçamento
    é constituído de duas áreas: <emphasis>área de texto</emphasis> e <emphasis>área de dados</emphasis>.
    A área de texto contém o código do programa e diz ao sistema o que deve ser feito. A área de dados
    armazena constantes e dados em tempo de execução do processo. Como existem vários processos em um 
    sistema e apenas um ou poucos processadores, o kernel do sistema precisa dividir
    o tempo de processamento entre os processos. Essa tarefa é chamada de: <emphasis>compartilhamento de tempo</emphasis>.
      </para>

      <table xml:id="chap-procmgmt-theory-proc-struct">
	<title>A estrutura de um processo</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Campo</entry><entry>Descrição</entry></row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>pid</entry><entry>O identificador numérico do processo</entry>
	    </row>
	    <row>
	      <entry>ppid</entry><entry>O identificador do processo</entry>
	    </row>
	    <row>
	      <entry>euid</entry><entry>O ID efetivo (nome do usuário) que está executando o processo</entry>
	    </row>
	    <row>
	      <entry>ruid</entry><entry>O ID real (id numérico) do usuário que está executando o processo</entry>
	    </row>
	    <row>
	      <entry>egid</entry><entry>O ID do grupo (nome do grupo) do processo</entry>
	    </row>
	    <row>
	      <entry>rgid</entry><entry>O ID real do grupo (id numérico) do processo</entry>
	    </row>
	    <row>
	      <entry>fd</entry><entry>Ponteiro para a lista de descritores de arquivos abertos</entry>
	    </row>
	    <row>
	      <entry>vmspace</entry><entry>Ponteiro para espaço de endereçamento do processo</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
          <xref linkend="chap-procmgmt-theory-proc-struct" /> lista os campos mais
          importantes onde o kernel armazena informações sobre processos. Cada processo
          pode ser identificado exclusivamente pelo seu <emphasis>PID</emphasis> (process identifier),
          que é nada mais do que um número (sempre positivo).
          Como veremos mais adiante, um usuário pode facilmente saber o PID de um processo.
          Cada processo é associado a um <emphasis>UID</emphasis> (user ID) e a um <emphasis>GID</emphasis> (group ID) no sistema.
          Cada process possui um <emphasis>UID real</emphasis>, que é o UID pelo
          qual o processo foi iniciado, e um <emphasis>UID efetivo</emphasis>, que é o UID com o qual o
          processo opera. Normalmente o UID real é igual ao UID efetivo, mas alguns programas
          pedem ao sistema que troque seu UID efetivo. O UID efetivo é usado para controle de acesso. Isto
          significa que se um usuário chamado joe executar um comando, ele apenas poderá arquivos onde
          joe tenha permissão de leitura.  Além disso, um processo também tem
          um <emphasis>GID real</emphasis> e um <emphasis>GID efetivo</emphasis>.
      </para>

      <para>
          Muitos processos abrem arquivos. O <foreignphrase>handle</foreignphrase> utilizado
          para operar o arquivo é chamado de descritor de arquivo. O kernel manipula
          uma lista de descritores de arquivo para cada processo. O campo <emphasis>fd</emphasis> contém
          um ponteiro para a lista de arquivos abertos. O campo <emphasis>vmspace</emphasis> aponta o espaço
          de endereçamento do processo.
      </para>

      <!-- XXX - make more sophisticated (swap)? -->
      <figure xml:id="chap-procmgmt-theory-proc-procstates">
	<title>Estados do Processo</title>

	<mediaobject>
	  <imageobject>
	    <imagedata format="PNG" fileref="../images/procstates.png"/>
	  </imageobject>
	  <imageobject>
	    <imagedata format="SVG" fileref="../images/procstates.svg"/>
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
    Nem todo processo precisa da CPU em um dado momento. Em um
    determinado momento um(ns) processo(s) pode(m) estar aguardando o término de uma operação
    de Entrada/Saída (<emphasis>I/O</emphasis>). 
    Sem levar em consideração pequenos detalhes, os processos normalmente possuem os 
    seguintes estados: <emphasis>iniciado</emphasis>, <emphasis>executando</emphasis>, <emphasis>bloqueado</emphasis>, 
    <emphasis>pronto</emphasis> (para executar), <emphasis>bloqueado</emphasis> (aguardando por I/O) ou 
    <emphasis>terminado</emphasis>.
    <xref linkend="chap-procmgmt-theory-proc-procstates" /> mostra o ciclo de vida
    de um processo. Um processo que é terminado mas cuja tabela de informações não foi
    removida é normalmente chamado de <emphasis>processo zumbi</emphasis>. Processos
    zumbi são úteis para permitir que o processo pai leia o status de saída do processo, ou 
    então para reservar temporariamente a entrada na tabela de processos.
      </para>
    </sect2>

    <sect2 xml:id="chap-procmgmt-theory-proc-new">
      <title>Criando novos processos</title>

      <para>
    Novos processos são criados com a chamada de sistema (<foreignphrase>system call</foreignphrase>) <emphasis>fork()</emphasis>.
    Essa chamada de sistema copia o espaço de endereçamento e informações do processo que a executou e cria o novo
    processo, chamado processo filho, com um PID diferente. O processo filho continuará
    a execução a partir do mesmo ponto que o processo pai, mas vai obter um valor de retorno diferente da chamada
    de sistema <emphasis>fork()</emphasis>. Baseado nesse valor de retorno o processo pai
    pode decidir como continuar a execução. O trecho de código C a seguir mostra como funciona uma chamada a <emphasis>form()</emphasis>: 
      </para>

      <programlisting>
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
  pid_t pid = fork();
  if (pid == 0)
    printf("Hi, I am the child!\n");
  else
    printf("Hi, I am the parent, the child PID is %d!\n", pid);

  return 0;
}
      </programlisting>

      <para>
          .	
          Este pequeno programa executa a <emphasis>fork()</emphasis> e armazena
          o valor retornado por <emphasis>fork()</emphasis> na variável pid. <emphasis>fork()</emphasis> o
          valor <emphasis>0</emphasis> para o processo filho e o PID do processo filho para o processo pai.
          Desde que isso tenha ocorrido, nós podemos uma simples estrutura condicional para verificar
          o valor da variável <emphasis>pid</emphasis> e exibir a mensagem que for mais apropriada.
      </para>

      <para>
    Você deve estar curioso para saber como é possível iniciar novos programas já
    que a chamada a <emphasis>fork()</emphasis> duplica um processo existente. 
    Essa é uma boa questão já que não é possível executar novos programas utilizando apenas <emphasis>fork()</emphasis>.
    O kernel UNIX fornece um conjunto de chamadas
    de sistema, a começar pela <emphasis>exec</emphasis>, que carrega um novo programa no
    no processo corrente. Nós vimos no início deste capítulo que um processo
    é um programa em execução -- um processo foi construído na memória a partir de uma imagem
    de um programa que é armazenado em uma mídia de armazenamento. A chamada
    de sistema <emphasis>exec</emphasis> então oferece a um processo em execução a facilidade
    de substituir seu conteúdo com um programa armazenado em alguma mídia. Por si só isto não
    é realmente muito útil visto que cada vez que a chamada de sistema <emphasis>exec</emphasis> é
    executada o código (programa) original é removido do processo. Isso pode ser conferido
    com o código C a seguir:
      </para>

      <programlisting>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
  execve("/bin/ls", NULL, NULL);

  /* This will never be printed, unless execve() fails. */
  printf("Hello world!\n");

  return 0;
}
      </programlisting>

      <para>
          Esse programa executa um <command>ls</command> usando a chamada de sistema <emphasis>execve()</emphasis>.
          A mensagem mostrada com <emphasis>printf()</emphasis> nunca será mostrada porque a imagem do 
          programa em execução será substituída pelo <command>ls</command>.
          A combinação de <emphasis>fork()</emphasis> e <emphasis>exec</emphasis> é bem poderosa.
          Um processo pode fazer um fork dele mesmo e deixar que o processo filho <quote>encerre</quote> por conta
          própria para executar outro programa. O programa a seguir demonstra esse funcionamento:
      </para>

      <programlisting>
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
  pid_t pid = fork();
  if (pid == 0)
    execve("/bin/ls", NULL, NULL);

  printf("Hello world!");

  return 0;
}
      </programlisting>

      <para>
    Este programa primeiramente faz um fork de si próprio. A imagem do programa do processo 
    filho será substituída pelo <command>ls</command>, enquanto que o processo
    pai mostra na tela a mensagem <quote>Hello world!</quote> e encerra a execução.
      </para>

      <para>
    Esse procedimento é seguido por muitos programas, incluindo 
    o shell, quando um comando é executado a partir de um prompt de comando.
    De fato, todos os processos em um sistema UNIX são direta ou indiretamente
    derivados do processo <emphasis>init</emphasis> que é o primeiro programa
    iniciado em um sistema UNIX.
      </para>

      <!-- XXX - Describe what is inherited when exec is called. -->
    </sect2>

    <sect2 xml:id="chap-procmgmt-theory-proc-threads">
      <title>Threads</title>

      <para>
    Apesar de forks serem muito úteis para permitir
    um certo paralelismo<footnote><para>Por exemplo um servidor
    web pode fazer fork de vários processos filhos para 
    gerenciar requisições</para></footnote>, eles podem
    ser dispendiosos em alguns casos. Copiar todo um processo
    consome algum tempo e ainda há o custo envolvido caso os processos
    compartilhem dados. Essa situação é resolvida com uma alternativa
    mais leve, já sabida, que é utilizar mais de uma thread de execução. Cada
    thread pode ser executada separadamente, porém, os dados do processo são
    compartilhados entre as threads.
      </para>

      <para>
          Escrever bons <emphasis>programas multi-thread</emphasis> requer bons
          conhecimentos sobre comparilhamento de dados e técnicas
          de <foreignphrase>locking</foreignphrase> (gerenciar a disputa por uma mesma área).
          Já que todos os dados são compartilhados, um programa mal feito pode caminhar
          para problemas de disputa.
      </para>
    </sect2>

    <!-- XXX - Add a section about capabilities. -->
  </sect1>

  <sect1 xml:id="chap-procmanagement-analyzing">
    <title>Analisando processos em execução</title>

    <sect2 xml:id="chap-procmanagement-analyzing-listing">
      <title>Listando processos em execução</title>

      <para>
    Sistemas UNIX fornecem o comando <command>ps</command> para exibir
    uma lista de processos que estão em execução. Infelizmente 
    esse é um exemplo dos problemas da falta de padronização. O BSD
    e variantes do System V possuem o <command>ps</command> com seu 
    próprio conjunto de opções. Felizmente o GNU/Linux implementa ambos
    os conjuntos de opção, do BSD e System V, e também, algumas opções
    a mais no estilo GNU. Opções precedidas com um traço são interpretadas
    como opções do System V e opções sem o traço são tratadas como opções BSD.
    Nós vamos descrever as opções do System V nesta seção.
      </para>

      <para>
          Se for executado o comando <command>ps</command> sem qualquer parâmetro,
          o resultado será uma lista de todos os processos que pertencem
          ao usuário que executou o <command>ps</command> e que são relativos
         ao terminal que está sendo utilizado. Por exemplo:
      </para>

      <screen>
$ <userinput>ps</userinput>
  PID TTY          TIME CMD
 8844 pts/5    00:00:00 bash
 8862 pts/5    00:00:00 ps
      </screen>

      <para>
    Muitas informações podem ser extraídas do resultado obtido. Como
    você pode ver, dois processos são listados, o shell que usamos
    para executar o <command>ps</command> (<emphasis>bash</emphasis>) e o
    próprio comando <command>ps</command>. Nesse caso existem quatro campos
    de informação. <emphasis>PID</emphasis> é o ID do processo, <emphasis>TTY</emphasis> é
    o terminal onde foi executado o comando, <emphasis>TIME</emphasis> é o tempo gasto pelo
    processador e <emphasis>CMD</emphasis> é o comando ou programa cuja cópia está rodando.
    Os campos que são mostrados por padrão podem variar de acordo com o sistema, mas ao menos
    os mostrados anteriormente serão exibidos (talvez variando um pouco o nome dos campos).
      </para>

      <para>
    Talvez você queira uma visão maior dos processos que estão em execução.
    Ao adicionar a opção <parameter class="command">-a</parameter> você verá todos os processos
   associados a qualquer erminal. 
   Por exemplo:
      </para>

      <screen>
$ <userinput>ps -a</userinput>
  PID TTY          TIME CMD
 7487 pts/1    00:00:00 less
 8556 pts/4    00:00:10 emacs-x
11324 pts/3    00:00:00 ps
      </screen>

      <para>
    Como você pode ver, processos de diferentes terminais foram exibidos. 



	As you can see, processes with different controlling terminals
	are shown. Though, in contrast to the plain
	<command>ps</command> output, only processes that control the
	terminal at the moment are shown. For instance, the shell that
	was used to call <command>ps</command> is not shown.
      </para>

      <para>
	You can also print all processes that are running, including
	processes that are not associated with a terminal, by using the
	<parameter class="command">-A</parameter> option:
      </para>

      <screen>
$ <userinput>ps -A | head -n 10</userinput>
  PID TTY          TIME CMD
    1 ?        00:00:01 init
    2 ?        00:00:00 migration/0
    3 ?        00:00:00 ksoftirqd/0
    4 ?        00:00:00 watchdog/0
    5 ?        00:00:00 migration/1
    6 ?        00:00:00 ksoftirqd/1
    7 ?        00:00:00 watchdog/1
    8 ?        00:00:00 events/0
    9 ?        00:00:00 events/1
      </screen>

      <para>
	You can print all processes with a certain user ID, with the
	<emphasis>-U</emphasis> option. This option accepts a user
	name as a parameter, or multiple user names that are separated
	by a comma. The following command shows all processes that
	have <emphasis>xfs</emphasis> or <emphasis>rpc</emphasis> as
	their user ID:
      </para>

      <screen>
$ <userinput>ps -U xfs,rpc</userinput>
  PID TTY          TIME CMD
 2409 ?        00:00:00 portmap
 2784 ?        00:00:00 xfs
      </screen>

      <para>
	Likewise, you can also print processes with a particular group
	ID, with the <emphasis>-G</emphasis> option:
      </para>

      <screen>
$ <userinput>ps -G messagebus,haldaemon</userinput>
  PID TTY          TIME CMD
 8233 ?        00:00:00 dbus-daemon
11312 ?        00:00:00 hald
11320 ?        00:00:00 hald-addon-keyb
11323 ?        00:00:00 hald-addon-acpi
      </screen>

      <para>
	If you would like to have a list for a physical or
	pseudo-terminal, you can use the <parameter
	class="command">-t</parameter> option:
      </para>

      <screen>
$ <userinput>ps -t tty2</userinput>
  PID TTY          TIME CMD
 2655 tty2     00:00:00 getty
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-procmanagement-managing">
    <title>Managing processes</title>

    <sect2 xml:id="chap-procmanagement-managing-signals">
      <title>Sending singals to a process</title>

      <para>
	Signals are a crude, but effective form of inter-process
	communication (IPC). A signal is basically a number that is
	delivered to a process that has a special meaning. For all
	signals there are default signal handlers. Processes can
	install their own signal handlers, or choose to ignore
	signals. Some signals (normally SIGKILL and SIGSTOP) can not
	be ignored. All signals have convenient symbolic names.
      </para>

      <para>
	Only a few signals are normally interesting for interactive
	use on UNIX(-like) systems. These are (followed by their number):
      </para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>SIGKILL (9):</emphasis> forcefully kill
	  a process.</para>
	</listitem>
	<listitem>
	  <para><emphasis>SIGTERM (15):</emphasis> request a process
	  to terminate. Since this is a request, a program could ignore
	  it, in contrast to <emphasis>SIGKILL</emphasis>.</para>
	</listitem>
	<listitem>
	  <para><emphasis>SIGHUP (1):</emphasis> Traditionally, this
	  has signalled a terminal hangup. But nowadays some daemons
	  (e.g. <emphasis>inetd</emphasis>) reread their configuration
	  when this signal is sent.</para>
	</listitem>
      </itemizedlist>

      <para>
	The <command>kill</command> command is used to send a signal
	to a process. By default, <command>kill</command> sends the
	<emphasis>SIGTERM</emphasis> signal. To send this signal, the
	process ID of the process that you would like to send this
	signal to should be added as a parameter. For instance:
      </para>

      <screen>
$ <userinput>kill 15631</userinput>
      </screen>

      <para>
	To send another signal, you can use one of two options:
	<emphasis>-signalnumber</emphasis> or
	<emphasis>-signalname</emphasis>. So, the following commands
	both send the <emphasis>SIGKILL</emphasis> signal to the process
	with process ID <emphasis>15631</emphasis>:
      </para>

      <screen>
$ <userinput>kill -9 15631</userinput>
      </screen>

      <screen>
$ <userinput>kill -SIGKILL 15631</userinput>
      </screen>

      <!-- XXX - Add note about what users can send signals. -->
    </sect2>

    <sect2 xml:id="chap-procmanagement-managing-nice">
      <title>Being nice to others</title>

      <para>
	In an act of altruism you can be nice to other users of
	computer resources. If you plan to run a CPU-time intensive
	process, but do not want that to interfere with work of other
	users on the system (or other processes), you can assign some
	grade of 'niceness' to a process. Practically, this means that
	you will be able to influence the scheduling priority of a
	process. Nicer processes get a lower scheduling priority. The
	normal niceness of a process is <emphasis>0</emphasis>, and
	can be changed by executing a program with the
	<command>nice</command> command. The <emphasis>-n
	[niceness]</emphasis> option can be used to specify the
	niceness:
      </para>

      <screen>
$ <userinput>nice -n 20 cputimewaster</userinput>
      </screen>

      <para>
	The maximum number for niceness is
	implementation-dependent. If a program was started with
	<command>nice</command>, but no niceness was specified, the
	niceness will be set to <emphasis>10</emphasis>. In case you
	were wondering: yes, you can also be rude, but this right is
	restricted to the <emphasis>root</emphasis> user. You can
	boost the priority of a process by specifying a negative value
	as the niceness.
      </para>

      <para>
	You can also modify the niceness of a running processes with
	the <command>renice</command> command. This can be done for
	specific process IDs (<parameter class="command">-p
	PIDs</parameter>), users (<parameter class="command">-u
	user/uid</parameter>), and effective groups (<parameter
	class="command">-g group/gid</parameter>). The new niceness
	is specified as the first parameter.
      </para>

      <para>
	The niceness of a process can only be increased. And, of
	course, no user except for <emphasis>root</emphasis> can
	affect the niceness of processes of other users.
      </para>

      <para>
	Lets look at an example, to set the niceness of a process with
	PID <emphasis>3108</emphasis> to <emphasis>14</emphasis>, you
	could use the following command:
      </para>

      <screen>
$ <command>renice 14 -p 3108</command>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-procmanagement-jobcontrol">
    <title>Job control</title>

    <para>
      It is often useful to group processes to allow operations on a
      set of processes, for instance to distribute a signal to all
      processes in a group rather than a single process. Not too
      suprisingly, these sets of processes are called
      <emphasis>program groups</emphasis> in UNIX. After a fork, a
      child process is automatically a member of the process group of
      the parent. Though, new process groups can be created by making
      one process a process group leader, and adding other processes
      to the group. The process group ID is the PID of the process
      group leader.
    </para>

    <para>
      Virtually all modern UNIX shells give processes that are created
      through the invocation of a command their own process group. All
      processes in a pipeline are normally added to one process group.
      If the following commands that create a pipepine are executed
    </para>

    <screen>
cat | tr -s ' ' | egrep 'foob.r'
    </screen>

    <para>
      the shell roughly performs the following steps:
    </para>

    <orderedlist>
      <listitem>
	<para>
	  Three child processes are forked.
	</para>
      </listitem>
      <listitem>
	<para>
	  The first process in the pipeline is put in a process group
	  with its own PID as the process group ID, making it the
	  process leader. The other processes in the pipeline are added
	  to the process group.
	</para>
      </listitem>
      <listitem>
	<para>
	  The file descriptors of the processes in the pipeline are
	  reconfigured to form a pipeline.
	</para>
      </listitem>
      <listitem>
	<para>
	  The programs in the pipeline are executed.
	</para>
      </listitem>
    </orderedlist>

    <para>
      The shell uses process groups to implement <emphasis>job
      control</emphasis>. A shell can run multiple jobs in the
      background, there can be multiple stopped job, and one job can
      be in the foreground. A foreground job is wired to the terminal
      for its standard input (meaning that it is the job the gets user
      input).
    </para>

    <sect2 xml:id="chap-procmgmt-jobcontrol-stopping">
      <title>Stopping and continuing a job</title>
      
      <para>
	A job that is in the foreground (thus, a job that potentially
	accepts userinput from the terminal) can be stopped by
	pressing <emphasis>Ctrl-z</emphasis> (pressing both the 'Ctrl' and
	'z' keys simultaneously). This will stop the job,
	and will handle control over the terminal back to the shell.
	Let's try this with the <command>sleep</command> command, which
	waits for the number of seconds provided as an argument:
      </para>

      <screen>
$ <userinput>sleep 3600</userinput>
<userinput>Ctrl-z</userinput>
[1]+  Stopped                 sleep 3600
      </screen>

      <para>
	The process group, which we will refer to as a job has been
	stopped now, meaning the the <command>sleep</command> has
	stopped counting - it's execution is completely stopped. You
	can retrieve a list of jobs with the <command>jobs</command>
	command:
      </para>

      <screen>
$ <userinput>jobs</userinput>
[1]+  Stopped                 sleep 3600
      </screen>

      <para>
	This shows the job number (<emphasis>1</emphasis>), its state,
	and the command that was used to start this job. Let's run
	another program, stop that too, and have another look at the
	job listing.
      </para>

      <screen>
$ <userinput>cat</userinput>
<userinput>Ctrl-z</userinput>
[2]+  Stopped                 cat
$ <userinput>jobs</userinput>
[1]-  Stopped                 sleep 3600
[2]+  Stopped                 cat
      </screen>

      <para>
	As expected, the second job is also stopped, and was assigned
	job number <emphasis>2</emphasis>. The plus sign
	(<emphasis>+</emphasis>) following the first job has changed
	to a minus (<emphasis>-</emphasis>) sign, while the second job
	is now marked by a plus sign. The plus sign is used to
	indicate the <emphasis>current job</emphasis>. The
	<command>bg</command> and <command>fg</command> commands that
	we will look at shortly, will operate on the current job
	if no job was specified as a parameter.
      </para>
     
      <!-- XXX - Document under what circumstances a job becomes the
                 current job. -->

      <para>
	Usually, when you are working with jobs, you will want to move
	jobs to the foreground again. This is done with the
	<command>fg</command> command. Executing <command>fg</command>
	without a parameter will put the current job in the
	foreground.  Most shells will print the command that is moved
	to the foreground to give an indication of what process was
	moved to the foreground:
      </para>

      <screen>
$ <userinput>fg</userinput>
cat
      </screen>

      <para>
	Of course, it's not always useful to put the current job in
	the foreground. You can put another job in the foreground by
	adding the job number preceded by the percentage sign
	(<emphasis>%</emphasis>) as an argument to
	<command>fg</command>:
      </para>

      <screen>
$ <userinput>fg %1</userinput>
sleep 3600
      </screen>

      <para>
	Switching jobs my stopping them and putting them in the
	foreground is often very useful when the shell is used
	interactively. For example, suppose that you are editing a
	file with a text editor, and would like to execute some other
	command and then continue editing. You could stop the editor
	with <emphasis>Ctrl-z</emphasis>, execute a command, and put
	the editor in the foreground again with <command>fg</command>.
      </para>
    </sect2>

    <sect2 xml:id="chap-procmgmt-jobcontrol-background">
      <title>Background jobs</title>

      <para>
	Besides running in the foreground, jobs can also run in the
	background. This means that they are running, but input from
	the terminal is not redirected to background processes. Most
	shells do configure background jobs to direct output to the
	terminal of the shell where they were started.
      </para>

      <para>
	A process that is stopped can be continued in the background
	with the <command>bg</command> command:
      </para>

      <screen>
$ <userinput>sleep 3600</userinput>
  
[1]+  Stopped                 sleep 3600
$ <userinput>bg</userinput>
[1]+ sleep 3600 &amp;
$
      </screen>

      <para>
	You can see that the job is indeed running with
	<command>jobs</command>:
      </para>

      <screen>
$ <userinput>jobs</userinput>
[1]+  Running                 sleep 3600 &amp;
      </screen>

      <para>
	Like <command>fg</command>, you can also move another job than
	the current job to the background by specifying its job
	number:
      </para>

      <screen>
$ <command>bg %1</command>
[1]+ sleep 3600 &amp;
      </screen>

      <para>
	You can also run put a job directly in the background when it is
	started, by adding an trailing ampersand (&amp;) to a command
	or pipeline. For instance:
      </para>

      <screen>
$ <userinput>sleep 3600 &amp;</userinput>
[1] 5078
      </screen>

      <!-- XXX - behavior of background processes when a shell is
                 terminated. -->
    </sect2>
  </sect1>
</chapter>
