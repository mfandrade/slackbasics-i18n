<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
     xmlns:xl="http://www.w3.org/1999/xlink"
     xml:lang="pt_BR"
     xml:id="chap-filesystem">
  <title>Arquivos e diretórios</title>

  <sect1 xml:id="chap-filesystem-introduction">
    <title>Um pouco de teoria</title>

    <para>
      Antes de começarmos a ver as operações práticas com sistemas de
      arquivos, vamos conferir uma visão geral mais teórica de como
      sistemas de arquivos funcionam em sistemas UNIX-like.  O Slackware
      Linux dá suporte a vários sistemas de arquivos distintos, mas
      todos estes sistemas de arquivos usam essencialmente as mesmas
      semânticas.  Estas semânticas são oferecidas através de uma camada
      de <emphasis>Sistema de Arquivo Virtual</emphasis> (VFS, da sigla
      em inglês), que proporciona uma camada genérica para sistemas de
      arquivo em disco ou em rede.
    </para>

    <sect2 xml:id="chap-filesystem-introduction-atoms">
      <title>inodes, diretórios e dados</title>

      <para>
    O sistema de arquivos consiste de dois tipos de elementos: dados e
    metadados.  Os metadados descrevem os atuais blocos de dados que
    estão no disco.  Muitos sistemas de arquivo usam nós de informação
    (inodes) para manter metadados.  Muitos sistemas de arquivo
    armazenam os seguintes dados em seus inodes:
      </para>

      <table xml:id="chap-filesystem-introduction-atoms-inodes">
        <title>Campos comuns em um inode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Campo</entry>
              <entry>Descrição</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>As permissões do arquivo..</entry>
            </row>
            <row>
              <entry>uid</entry>
              <entry>O ID do usuário que é o dono do arquivo.</entry>
            </row>
            <row>
              <entry>gid</entry>
              <entry>O ID do grupo do arquivo.</entry>
            </row>
            <row>
              <entry>size</entry>
              <entry>O tamanho do arquivo em bytes.</entry>
            </row>
            <row>
              <entry>ctime</entry>
              <entry>Momento de criação do arquivo.</entry>
            </row>
            <row>
              <entry>mtime</entry>
              <entry>Momento da última modificação do arquivo.</entry>
            </row>
            <row>
              <entry>links_count</entry>
              <entry>O número de links apontando para este inode.</entry>
            </row>
            <row>
              <entry>i_block</entry>
              <entry>Ponteiros para os blocos de dados.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    Se você não for um entusiasta de UNIX ou Linux, estes nomes
    provavelmente deve estar soando um pouco estranhos a você, mas vamos
    esclarecê-los melhor nas seções seguintes.  De qualquer forma,
    a partir desta tabela possivelmente você já pode deduzir a relação
    entre inodes e dados, e especificamente sobre o campo
    <emphasis>i_block</emphasis>: cada inode tem ponteiros para os
    blocos de dados sobre os quais o inode provê informações.  Além
    disso, o inode e os blocos de dados são o próprio arquivo no sistema
    de arquivos.
      </para>

      <para>
    Agora você pode estar se perguntando onde fica a informação com o
    nome dos arquivos (e diretórios), já que não há um campo para o nome
    do arquivo no inode.  Atualmente, os nomes dos arquivos são
    armazenados nas assim chamadas entradas de diretório.  Estas
    entradas especificam um nome de arquivo e o inode do arquivo.  Uma
    vez que diretórios também são representados por inodes, uma
    estrutura de diretórios pode ser construída desta maneira.
      </para>

      <para>
    Podemos mostrar de uma forma simplificada como isto tudo funciona
    ilustrando o que o kernel faz quando executamos o comando
    <command>cat /home/daniel/note.txt</command>
      </para>

      <orderedlist>
        <listitem>
      <para>
        O sistema lê o inode do diretório <filename>/</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do
        diretório <filename>home</filename>.
      </para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do diretório <filename>home</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do
        diretório <filename>daniel</filename>.</para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do diretório <filename>daniel</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        lê o bloco de dados para encontrar o número do inode do arquivo
        <filename>note.txt</filename>
      </para>
        </listitem>
        <listitem>
          <para>
        O sistema lê o inode do arquivo <filename>note.txt</filename>,
        verifica se o usuário tem permissão para acessar este inode, e
        retorna o bloco de dados para o <command>cat</command> por meio
        da chamada de sistema <emphasis>read()</emphasis>.</para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="chap-filesystem-introduction-permissions">
      <title>Permissões de arquivos</title>

      <para>
    Como descrevemos anteriormente, Linux é um sistema multiusuário.
    Isto significa que cada usuário tem seus próprios arquivos (que
    usualmente estão localizados no diretório home).  Além disso, os
    usuários podem ser membros de grupos, que podem lhes dar privilégios
    adicionais de usuário.
      </para>

      <para>
    Como você viu na tabela dos campos do inode, cada arquivo tem um
    usuário e um grupo.  O controle de acesso tradicional do UNIX
    possibilita permissões para leitura, escrita, ou execução ao dono do
    arquivo, para seu grupo, e para os outros usuários.  Estas
    permissões são armazenadas no campo <emphasis>mode</emphasis> de
    cada inode.  O campo mode representa as permissões do arquivo como
    quatro dígitos em numeração octal.  O primeiro dígito representa
    certas opções especiais; o segundo dígito armazena as permissões do
    dono do arquivo; o terceiro, as permissões de grupo e o quarto
    dígito, as permissões para os outros usuários.  As permissões são
    estabelecidas pelos dígitos usando-se ou adicionando-se um dos
    números em <xref linkend="chap-filesystem-permissions-numbers"/>
      </para>

      <table xml:id="chap-filesystem-permissions-numbers">
        <title>Significado dos números no octeto do campo mode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Número</entry>
              <entry>Significado</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>Execução (x)</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>Escrita (w)</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>Leitura (r)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    Agora, suponha que um arquivo tenha um mode
    <emphasis>0644</emphasis>, isto significa que o arquivo é legível e
    passível de escrita pelo dono (<emphasis>6</emphasis>, e apenas
    legível pelo grupo do arquivo (<emphasis>4</emphasis>) e outros
    usuário (<emphasis>4</emphasis>).</para>

      <para>
    Muitos usuários não querem lidar com números octais, então por isso
    que muitos utilitários podem também lidar com representações
    alfabéticas das permissões de arquivo.  As letras estão listadas em
    <xref linkend="chap-filesystem-permissions-numbers"/> entre
    parênteses e são usadas nesta notação.  No exemplo seguinte, a
    informação sobre um arquivo com permissões <emphasis>0644</emphasis>
    é exibida.  Os números são substituídos por três conjuntos rwx (o
    primeiro caractere pode listar opções especiais de modo).
      </para>

      <screen>
$ <userinput>ls -l note.txt</userinput>
-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt
      </screen>

      <para>
    Com o passar dos anos estas permissões tradicionais do UNIX
    mostraram não serem suficientes em alguns casos.  A especificação
    POSIX 1003.1e ajudou a estender o modelo de controle de acesso do
        UNIX com as <emphasis>Listas de Controle de Acesso</emphasis>
        (ACLs, da sigla em inglês).
    Infelizmente este esforço ficou estagnado, já que só alguns sistemas
        (como o GNU/Linux) implementaram ACLs<footnote>
    <para>No momento em que este livro estava sendo escrito, ACLs têm
        suporte nos sistemas de arquivos ext2, ext3, e XFS</para>
        </footnote>.  Listas de controle de acesso seguem a mesma
        semântica que as permissões de arquivo normais, mas lhe dão a
        oportunidade de adicionar conjuntos de <emphasis>rwx</emphasis>
        para usuários de grupos adicionais.</para>

      <para>
    O exemplo a seguir exibe a lista de controle de acesso de um
    arquivo.  Como você pode ver, as permissões parecem com as
    permissões normais do UNIX (são especificadas as permissões de
    para o dono, o grupo, e outros).  Mas há também uma entrada
    adicional para o usuário <emphasis>joe</emphasis>.
      </para>

      <programlisting>
user::rwx
user:joe:r--
group::---
mask::r--
other::---
      </programlisting>

      <para>
    Para tornar as coisas ainda mais complexas (e mais sofisticadas),
    alguns sistemas GNU/Linux adicionam controle de acesso ainda mais
    específico por meio de Frameworks de Controle de Acesso Obrigatório
    (Mandatory Access Control Frameworks, MAC) como o SELinux e o AppArmor.  Mas estes
    frameworks de controle de acesso estão fora do escopo deste livro.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystems-introduction-links">
      <title>Links</title>

      <para>
    Uma entrada de diretório que aponta para um inode é chamada de
    <emphasis>hard link</emphasis>.
    Muitos arquivos possuem apenas um único link, mas nada lhe impede de
    criar mais de um link para o arquivo.  Isto irá incrementar o campo
    <emphasis>links_count</emphasis> do inode.  Esta é uma bela maneira
    de o sistema verificar quais inodes e blocos de dados estão livres
    para utilização.  Se links_count estiver com valor zero, então o
    inode não é mais referenciado em lugar nenhum, e pode ser
    reutilizado.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-hardlink">
        <title>A estrutura de um hard link</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/hardlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/hardlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
    Hard links possuem duas limitações.  Em primeiro lugar, hard links
    não podem lincar entre diferentes sistemas de arquivos, uma vez que
    eles apontam para inodes.  Cada sistema de arquivo tem seus próprios
    inodes e números de inode correspondentes.  Além disso, muitos
    sistemas de arquivos não permitem que você crie hard links para
    diretórios.  Permitir a criação de hard links para diretórios pode
    gerar loops de diretórios, potencialmente resultando em deadlocks e
    inconsistências no sistema de arquivo.  Adicionalmente, muitas
    implementações dos comandos <command>rm</command> e
    <command>rmdir</command> não sabem como lidar com hard links extras
    para diretórios.
      </para>

      <para>
        <emphasis>Links simbólicos</emphasis> não possuem estas
        limitações, pois eles apontam para nomes de arquivos, ao invés
        do que para inodes.  Quando um link simbólico é usado, o sistema
        operacional irá seguir o caminho daquele link.  Links simbólicos
        também podem se referir a arquivos que não existem, uma vez que
        contém apenas um nome.  Links deste tipo são chamados de
        dangling links.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-symlink">
        <title>A estrutura de um link simbólico</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/symlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/symlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>
      Se você estiver envolvido com administração de sistemas, é bom
      estar ciente das implicações de segurança da utilização de hard
      links.  Se o diretório <filename>/home</filename> estiver no mesmo
      sistema de arquivos que outros binários do sistema, um usuário
      poderia criar hard links para binários.  No caso de um programa
      vulnerável ser atualizado, o link no diretório home do usuário
      permanecerá apontando para o programa binário antigo, efetivamente
      dando ao usuário acesso contínuo ao binário vulnerável.
    </para>

        <para>
      Por esta razão é uma boa idéia colocar quaisquer diretórios que os
      usuários possam escrevem em diferentes sistemas de arquivos.  Na
      prática, isto significa que é uma boa idéia colocar ao menos os
      diretórios <filename>/home</filename> e <filename>/tmp</filename>
      em sistemas de arquivos distintos.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystems-analyzing">
    <title>Analisando arquivos</title>

    <para>
      Antes de nos aventurarmos por outros mares, vamos começar com
      um pouco da utilização básica de arquivos e diretórios.
    </para>

    <sect2 xml:id="chap-filesystems-analyzing-listing">
      <title>Listando arquivos</title>

      <para>
    Uma das coisas mais comuns que você vai querer fazer é listar todos
    os alguns arquivos.  O comando <command>ls</command> serve muito bem
    a este propósito.  Usar <command>ls</command> sem nenhum argumento
    irá mostrar o conteúdo do diretório atual:
      </para>

      <screen>
$ <userinput>ls</userinput>
dns.txt  network-hosts.txt  papers
      </screen>

      <para>
    Se você usa uma distribuição GNU/Linux, você também pode ver a saída
    em cores baseadas nos tipos de arquivos.  A saída padrão é útil para
    consultar o conteúdo de um diretório, mas se você quer mais
    informação, você pode usar o parâmetro <parameter
    class="command">-l</parameter>.  Este parâmetro proporciona uma
    listagem longa para cada arquivo:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Isto resulta em bastante informação a mais sobre as entradas da
    árvore de diretório que a que obtemos com o comando
    <command>ls</command>.  A primeira coluna exibe as permissões dos
    arquivos.  A linha que exibe a entrada <filename>papers</filename>
    inicia com um <quote>d</quote>, significando que esta entrada
    representa um diretório.  A segunda coluna exibe o número de hard
    links que apontam para o inode referente aquele diretório.  Se este
    número é maior que 1, há alguns outros nomes de arquivo para o mesmo
    arquivo.  Entradas de diretório usualmente possuem pelo menos dois
    hard links, referenciando o link no diretório pai e o link para o
    diretório em si (cada diretório possui uma entrada
    <filename>.</filename>, a qual se refere ao diretório em si).  A
    terceira e quarta colunas listam o dono do arquivo e o grupo
    respectivamente.  A quinta coluna contém o tamanho do arquivo em
    bytes.  A sexta coluna é o momento da última modificação e a data do
    arquivo.  E finalmente, a última coluna mostra o nome desta entrada.
      </para>

      <para>
    Arquivos que iniciam com um ponto (.) não serão exibidos pela
    maioria das aplicações, incluindo o <command>ls</command>.  Você
    pode listar estes arquivos também, adicionando a opção <parameter
    class="command">-a</parameter> ao comando <command>ls</command>:
      </para>

      <screen>
$ <userinput>ls -la</userinput>
total 60
drwxrwxr-x   3 daniel daniel  4096 Sep 11 10:01 .
drwx------  88 daniel daniel  4096 Sep 11 10:01 ..
-rw-rw-r--   1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--   1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x   2 daniel daniel  4096 Sep  4 15:55 papers
-rw-rw-r--   1 daniel daniel     5 Sep 11 10:01 .settings
      </screen>

      <para>
    Como você pode ver, mais três entradas apareceram.  Primeiro de
    tudo, o arquivo <filename>.settings</filename> agora é mostrado.
    Além disso você pode ver as duas entradas de diretório adicionais,
    <filename>.</filename> e <filename>..</filename>.  Estas representam
    o diretório atual e o diretório pai, respectivamente.
      </para>

      <para>
    Anteriormente neste capítulo (<xref
    linkend="chap-filesystem-introduction-atoms"/>) falamos sobre
    inodes.  O número do inode apontado por uma entrada de diretório
    pode ser mostrado com o parâmetro <parameter
    class="command">-i</parameter>.  Suponha que eu tenha criado um hard
    link para o inode que aponta para o mesmo inode que o arquivo
    <filename>dns.txt</filename>, eles devem ter o mesmo número de
    inode.  A seguinte saída do comando <command>ls</command> mostra que
    isto é verdade:
      </para>

      <screen>
$ <userinput>ls -i dns*</userinput>
3162388 dns-newhardlink.txt
3162388 dns.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-file">
      <title>Determinando o tipo de um arquivo</title>

      <para>
    Algumas vezes você vai precisar de ajuda para determinar o tipo de
    um arquivo.  É onde o utilitário <command>file</command> se torna
    útil.  Imagine que eu encontre um arquivo chamado
    <filename>HelloWorld.class</filename> em algum lugar do meu disco.
    Eu suponho que este seja um arquivo que contenha bytecodes Java, mas
    podemos usar <command>file</command> para confirmar isto:
      </para>

      <screen>
$ <userinput>file HelloWorld.class</userinput>
HelloWorld.class: compiled Java class data, version 49.0
      </screen>

      <para>
    Definitivamente isto é bytecode Java.  <command>file</command> é
    bastante esperto, e manipula muitas coisas que você sequer imagina.
    Por exemplo, você poderia usá-lo para obter informação sobre um
    dispositivo:
      </para>

      <screen>
$ <userinput>file /dev/zero</userinput>
/dev/zero: character special (1/5)
      </screen>

      <para>
    Ou sobre um link simbólico:
      </para>

      <screen>
$ <userinput>file /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: symbolic link to `Xorg'
      </screen>

      <para>
    Se você estiver interessado em para onde o arquivo
    <filename>/usr/X11R6/bin/X</filename> aponta, você pode usar a
    opção <parameter class="command">-L</parameter> do
    <command>file</command>:
      </para>

      <screen>
$ <userinput>file -L /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: setuid writable, executable, regular file, no read permission
      </screen>

      <para>
    Você pode se perguntar como o <command>file</command> pode
    determinar o tipo de arquivo tão facilmente.  Muitos arquivos
    iniciam com algo que chamamos de <emphasis>número mágico</emphasis>,
    que é um número único que informa aos programas que podem lê-los
    sobre de que tipo o arquivo é.  O programa <command>file</command>
    usa um arquivo com a descrição de diversos tipos de arquivos e seus
    números mágicos.  Por exemplo, no meu sistema este arquivo mágico
    contém as seguintes linhas para arquivos Java compilados:
      </para>

      <programlisting>
# Java ByteCode
# From Larry Schwimmer (schwim@cs.stanford.edu)
0       belong          0xcafebabe      compiled Java class data,
>6      beshort x       version %d.
>4      beshort x       \b%d
      </programlisting>

      <para>
    Esta entrada diz que se um arquivo iniciar com o longo número mágico
    hexadecimal <emphasis>0xcafebabe</emphasis><footnote>
        <para>Sim, você pode ser criativo com os números mágicos
        também!</para> </footnote>, é um arquivo que contém dados
        compilados de uma classe Java (<quote>compiled
        Java class data</quote>).  o número curto que se
        segue determina a versão do formato do arquivo class.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-integrity">
      <title>Integridade de arquivos</title>

      <para>
    Antes de partirmos para a checagem mais avançada da integridade de
    arquivos,  <!-- XXX xref --> vamos dar uma breve olhada no
    utilitário <command>cksum</command>.  <command>cksum</command> pode
    calcular a soma para checagem de redundância cíclica (CRC) de um
    dado arquivo de entrada.  Este é um método matemático para cálculo
    de um número único para um arquivo.  Você pode usar este número para
    verificar se um arquivo não sofreu modificações (por exemplo, depois
    de baixar um arquivo de um servidor).  Você pode especificar o
    arquivos para cálculo do CRC como um parâmetro para o
    <command>cksum</command>, e o <command>cksum</command> irá exibir o
    valor do CRC, o tamanho em bytes e o nome do arquivo:
      </para>

      <screen>
$ <userinput>cksum myfile</userinput>
1817811752 22638 myfile
      </screen>

      <para>
    O Slackware Linux também possui utilitários para cálculo de somas de
    verificação baseadas em algoritmos de via única (por exemplo, MD5 ou
    SHA-1).
    <!-- XXX - elaborar -->
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-viewing">
      <title>Visualizando arquivos</title>

      <para>
    Uma vez que muitos arquivos em sistemas UNIX são essencialmente
    arquivos de texto, eles são fáceis de serem visualizados em um
    terminal de caracteres ou emulador de terminal.  A forma mais
    primitiva de ver o conteúdo de um arquivo é através do
    <command>cat</command>.  O comando <command>cat</command> lê
    os arquivos que forem especificados como parâmetros linha por linha,
    e irá exibi-las na saída padrão.  Então, você pode imprimir o
    conteúdo do arquivo <filename>note.txt</filename> para o terminal
    com <filename>cat note.txt</filename>.  Ainda que alguns sistemas e
    muitos emuladores de terminal tenham suporte a barras de rolagem,
    esta não é uma maneira prática de visualizar arquivos grandes.  Você
    pode criar um duto (pipe) com a saída
    do <command>cat</command> para o paginador <command>less</command>:
      </para>

      <screen>
$ <userinput>cat note.txt | less</userinput>
      </screen>

      <para>
    ou deixar que o <command>less</command> leia o arquivo diretamente:
      </para>

      <screen>
$ <userinput>less note.txt</userinput>
      </screen>

      <para>
    O <command>less</command> é um paginador e permite que você role a
    tela para frente e para trás num arquivo.  <xref
    linkend="chap-filesystem-analyzing-viewing-less-keys"/>
    contém uma visão geral das teclas mais importantes usadas para
    controlar o <command>less</command>
      </para>

      <table xml:id="chap-filesystem-analyzing-viewing-less-keys">
        <title>teclas de comando do less</title>

        <tgroup cols="2" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Tecla</entry>
              <entry>Descrição</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>j</entry>
              <entry>Rola uma linha para a frente.</entry>
            </row>
            <row>
              <entry>k</entry>
              <entry>Rola uma linha para trás.</entry>
            </row>
            <row>
              <entry>f</entry>
              <entry>Rola uma tela cheia de texto para frente.</entry>
            </row>
            <row>
              <entry>b</entry>
              <entry>Rola uma tela cheia de texto para trás.</entry>
            </row>
            <row>
              <entry>q</entry>
              <entry>Termina o comando.</entry>
            </row>
            <row>
              <entry>g</entry>
              <entry>Pula para o começo do arquivo.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>Pula para o final do arquivo.</entry>
            </row>
            <row>
              <entry>/<emphasis>padrão</emphasis></entry>
              <entry> Procura pelo <emphasis>padrão</emphasis> de texto
              com a <link
              xl:href="#chap-textproc-regexps">expressão regular</link>
                dada. </entry>
            </row>
            <row>
              <entry>n</entry>
              <entry> Procura pela próxima ocorrência da expressão
              regular previamente especificada.
              </entry>
            </row>
            <row>
              <entry>m<emphasis>letra</emphasis></entry>
              <entry> Faz um marcador da posição atual no arquivo com a
              <emphasis>letra</emphasis>.
              </entry>
            </row>
            <row>
              <entry>'<emphasis>letra</emphasis></entry>
              <entry>Pula para o marcador dado por <emphasis>letra</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
    As teclas de comando podem ser quantificadas com um prefixo
    numérico.  Por exemplo, <emphasis>11j</emphasis> rola a tela onze
    linhas para a frente, e <emphasis>3n</emphasis> procura pela
    terceira ocorrência da última expressão regular especificada.
      </para>

      <para>
    O Slackware Linux também possui uma alternativa ao
    <command>less</command>, o antigo comando <quote>more</quote>.
    Não vamos abordar o <emphasis>more</emphasis> aqui pois o
    <command>less</command> é mais confortável e mais popular hoje em
    dia.
      </para>

    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-filesize">
      <title>Tamanhos de arquivos e diretórios</title>

      <para>
    A saída de <command>ls -l</command> que vimos há pouco provê
    informação sobre o tamanho de um arquivo.  Ainda que isto usualmente
    seja informação suficiente sobre tamanhos de arquivos, você pode
    querer coletar informação sobre conjuntos de arquivos ou diretórios.
    É onde entra o comando <command>du</command>.  Por padrão,
    <command>du</command> exibe o tamanho dos arquivos por diretório.
    Por exemplo:
      </para>

      <screen>
$ <userinput>du ~/qconcord</userinput>
72      /home/daniel/qconcord/src
24      /home/daniel/qconcord/ui
132     /home/daniel/qconcord
      </screen>

      <para>
        Por padrão, <command>du</command> representa o tamanho em
        números de blocos de 1024 bytes.  Você pode especificar
        explicitamente que o <command>du</command> deva usar unidades de
        1024 bytes adicionando a opção <parameter
        class="command">-k</parameter>.  Isto é útil para escrever
    scripts, pois o padrão de alguns outros sistemas é usar blocos de
    512 bytes.  Por exemplo:
      </para>

      <screen>
$ <userinput>du -k ~/qconcord</userinput>
72  /home/daniel/qconcord/src
24  /home/daniel/qconcord/ui
132 /home/daniel/qconcord
      </screen>

      <para>
    Se você também quiser ver a utilização de disco por arquivo, você
    pode adicionar a opção <parameter class="command">-a</parameter>:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord</userinput>
8       /home/daniel/qconcord/ChangeLog
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
12      /home/daniel/qconcord/Makefile
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
8       /home/daniel/qconcord/qconcord.pro
132     /home/daniel/qconcord
      </screen>

      <para>
    Você também pode usar o nome de um arquivo um caractere curinga como
    parâmetro.  Mas isto não vai exibir os tamanhos dos arquivos em
    subdiretórios, a menos que <parameter class="command">-a</parameter>
    seja usado:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord/*</userinput>
8       /home/daniel/qconcord/ChangeLog
12      /home/daniel/qconcord/Makefile
8       /home/daniel/qconcord/qconcord.pro
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
      </screen>

      <para>
    Se você quiser ver a soma total do espaço em disco utilizado pelos
    arquivos e subdiretórios dentro do diretório dado, então use a opção
    <parameter class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>du -k -s ~/qconcord</userinput>
132     /home/daniel/qconcord
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-directories">
    <title>Trabalhando com diretórios</title>

    <para>
      Depois de dar uma visão geral de diretórios em <xref
      linkend="chap-filesystem-introduction-atoms"/>, vamos agora dar uma
      olhada em alguns comandos relacionados a diretórios.
    </para>

    <sect2 xml:id="chap-filesystem-directories-listing">
      <title>Listando diretórios</title>

      <para>
    O comando <command>ls</command> que vimos em <xref
    linkend="chap-filesystems-analyzing-listing"/> também pode ser usado
    para listar diretórios de diferentes maneiras.  Como já vimos, a
    saída padrão do <command>ls</command> inclui diretórios, e os
    diretórios podem ser identificados usando a primeira coluna da saída
    de uma listagem longa:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Se um nome de diretório, ou se um coringa for especificado, o
    <command>ls</command> irá listar o conteúdo do diretório, os dos
    diretórios que casem com o coringa respectivamente.  Por exemplo, se
    houver um diretório <filename>papers</filename>, <command>ls
    paper*</command> vai listar o conteúdo deste diretório
    <filename>papers</filename>.  O parâmetro <parameter
    class="command">-d</parameter> evita que esta recursão
    aconteça:
      </para>

      <screen>
$ <userinput>ls -ld paper*</userinput>
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
    Você também pode listar recursivamente o conteúdo de um diretório, e
    de seus subdiretórios com o parâmetro <parameter
    class="command">-R</parameter>:
      </para>

      <screen>
$ <userinput>ls -R</userinput>
.:
dns.txt  network-hosts.txt  papers

./papers:
cs  phil

./papers/cs:
entr.pdf

./papers/phil:
logics.pdf
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-directories-management">
      <title>Criando e removendo diretórios</title>

      <para>
    O UNIX provê o comando <command>mkdir</command> para criar
    diretórios.  Se um caminho relativo é especificado, o diretório é
    criado no diretório corrente.  A sintaxe básica é muito simples:
    <emphasis>mkdir &lt;nome&gt;</emphasis>, por exemplo:
      </para>

      <screen>
$ <userinput>mkdir meudir</userinput>
      </screen>

      <para>
    Por padrão, <command>mkdir</command> cria apenas um nível de
    diretório.  Então, se você usar <command>mkdir</command> para criar
    <filename>meudir/meu_subdir</filename>, <command>mkdir</command> vai
    falhar se <filename>meudir</filename> não existir.  Se você quiser
    criar ambos os diretórios de uma só vez, use o parâmetro
    <parameter class="command">-p</parameter>:
      </para>

      <screen>
$ <userinput>mkdir -p meudir/meu_subdir</userinput>
      </screen>

      <para>
    <command>rmdir</command> remove um diretório.  Seu comportamento é
    comparável ao do <command>mkdir</command>.  <command>rmdir
    meudir/meu_subdir</command> remove
    <filename>meudir/meu_subdir</filename>, ao passo que <command>rmdir -p
    meudir/meu_subdir</command> remove
    <filename>meudir/meu_subdir</filename> e também
    <filename>meudir</filename>.
      </para>

      <para>
    Se um subdiretório que quisermos remover contenha entradas de
    diretório, <command>rmdir</command> irá falhar.  Se você quiser
    remover um diretório, incluindo todo o seu conteúdo, use o comando
    <command>rm</command> então. <!-- XXX - xref -->
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-managing">
    <title>Gerenciando arquivos e diretórios</title>

    <sect2 xml:id="chap-filesystem-managing-copying">
      <title>Copiando</title>

      <para>
    Arquivos e diretórios podem ser copiados com o comando
    <command>cp</command>.  Em sua sintaxe mais básica a origem e destino
    do arquivo são especificados.  O exemplo a seguir fará uma cópia do
    <filename>arquivo1</filename> chamada <filename>arquivo2</filename>:
      </para>

      <screen>
$ <userinput>cp arquivo1 arquivo2</userinput>
      </screen>

      <para>
    Não é surpresa que caminhos relativos e absolutos também funcionam:
      </para>

      <screen>
$ <userinput>cp arquivo1 algum_dir/arquivo2</userinput>
$ <userinput>cp arquivo1 /home/joe/design_documents/arquivo2</userinput>
      </screen>

      <para>
    Você também pode especificar um diretório como segundo parâmetro.  Se
    este for o caso, <command>cp</command> vai fazer uma cópia do arquivo
    dentro daquele diretório, dando-lhe o mesmo nome que o arquivo
    original.  Se houver mais de um parâmetro, o último parâmetro será
    usado como diretório de destino.  Por exemplo
      </para>

      <screen>
$ <userinput>cp arquivo1 arquivo2 algum_dir</userinput>
      </screen>

      <para>
    vai copiar tanto o <filename>arquivo1</filename> quanto o
    <filename>arquivo2</filename> para o diretório
    <filename>algum_dir</filename>.  Você não pode copiar múltiplos
    arquivos para um arquivo.  Vamos usar o <command>cat</command> para
    isto: <!-- XXX href -->
      </para>

      <screen>
$ <userinput>cat arquivo1 arquivo2 > arquivo_combinado</userinput>
      </screen>

      <para>
    Você também pode user <command>cp</command> para copiar diretórios,
    adicionando o parâmetro <parameter class="command">-R</parameter>.
    Isto irá copiar recursivamente um diretório e todos os seus
    subdiretórios.  Se o diretório destino existir, o diretório ou
    diretórios de origem serão postos dentro do diretório destino.  Se o
    diretório destino não existir.  Se o diretório destino não existir,
    será criado se houver um único diretório de origem.
      </para>

      <screen>
$ <userinput>cp -r minha_arvore arvore_copia</userinput>
$ <userinput>mkdir arvores</userinput>
$ <userinput>cp -r minha_arvore arvores</userinput>
      </screen>

      <para>
    Depois de executar estes comandos, haverá duas cópias do diretório
        <filename>minha_arvore</filename>,
        <filename>arvore_copia</filename> e
        <filename>arvores/minha_arvore</filename>.  Tentar copiar dois
        diretórios para um destino inexistente irá falhar:
      </para>

      <screen>
$ <userinput>cp -R minha_arvore minha_arvore2 novo_dir</userinput>
usage: cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target
       cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory
      </screen>

      <note>
    <para>
      Tradicionalmente, o <parameter class="command">-r</parameter>
      estava disponível em muitos sistemas UNIX para cópia recursiva de
      diretórios.  No entanto, o comportamento deste parâmetro pode
      depender da implementação, e na versão 3 da Single UNIX
      Specification consta que este parâmetro pode ser removido em
      implementações futuras do padrão.
    </para>
      </note>

      <para>
    Quando você estiver copiando arquivos recursivamente, é uma boa idéia
    especificar o comportamento que o <command>cp</command> deve ter
    ao encontrar um link simbólico explicitamente, se você quiser usar o
    <command>cp</command> em scripts portáveis.  A versão 3 da Single
    UNIX Specification não define como isto deve ser tratado por padrão.
    Se <parameter class="command">-P</parameter> for usado, links
    simbólicos não serão seguidos, resultando efetivamente na cópia do
    link em si.  Se <parameter class="command">-H</parameter> for usado,
    links simbólicos especificados como um parâmetro para o
    <command>cp</command> podem ser seguidos, dependendo do tipo do
    arquivo.  Se <parameter class="command">-L</parameter> for usado,
    links simbólicos especificados como parâmetro para o
    <command>cp</command> e links simbólicos que forem encontrados
    durante a cópia recursiva serão seguidos, dependendo do conteúdo do
    arquivo.
      </para>

      <para>
    Se você quer preservar a propriedade, os bits SGID/SUID, e os
    momentos de modificação e acesso do arquivo, você pode usar
    o <parameter>-p</parameter>.  Isto tentará preservar estas
    propriedades nas cópias dos arquivos ou diretórios.  Boas
    implementações de <command>cp</command> também provêem algumas
    proteções adicionais - se o arquivo destino já existir, ele não pode
    ser sobrescrito se os metadados relevantes não puderem ser
    preservados.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-moving">
      <title>Movendo arquivos e diretórios</title>

      <para>
    O comando do UNIX para mover arquivos, <command>mv</command>, pode
    mover ou renomear arquivos e diretórios.  O que acontece atualmente
    depende do local dos arquivos ou diretórios.  Se os arquivos de
    origem e de destino estão no mesmo sistema de arquivos, o
    <command>mv</command> comumente apenas cria novos hard links,
    efetivamente renomeando os arquivos ou diretórios.  Se ambos estão
    em sistemas de arquivos diferentes, os arquivos atualmente são
    copiados, e os arquivos ou diretórios de origem são desvinculados.
      </para>

      <para>
    A sintaxe do <command>mv</command> é comparável à do
    <command>cp</command>.  A sintaxe mais básica renomeia
    <filename>arquivo1</filename> para <filename>arquivo2</filename>:
      </para>

      <screen>
$ <userinput>mv arquivo1 arquivo2</userinput>
      </screen>

      <para>
    A mesma sintaxe pode ser usada para dois diretórios também, o que
    vai renomear o diretório dado como primeiro parâmetro para o nome
    especificado no segundo parâmetro.
      </para>

      <para>
    Quando o último parâmetro for um diretório existente, o arquivo ou
    diretório especificado como primeiro parâmetro é copiado para este
    diretório. Neste caso você pode especificar múltiplos arquivos ou
    diretórios também. Por exemplo:
      </para>

      <screen>
$ <userinput>mkdir destinodir</userinput>
$ <userinput>mv arquivo1 diretorio1 destinodir</userinput>
      </screen>

      <para>Isto cria o diretório <filename>destinodir</filename>, e
      move <filename>arquivo1</filename> e
      <filename>diretorio1</filename> para este diretório. </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-removing">
      <title>Removendo arquivos e diretórios</title>

      <para>
    Arquivos e diretórios podem ser removidos com o comando
    <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Este comando desvincula arquivos e diretórios.
        Se não houver outros links para um arquivo, seu inode e seus
        blocos no disco podem ser requisitados por novos arquivos.  Os
        arquivos podem ser removidos informando o nome destes arquivos
        como parâmetro para o
       <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Se o arquivo não for gravável, o <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> irá solicitar confirmação. Por exemplo, para
        remover <filename>arquivo1</filename> e
        <filename>arquivo2</filename>, você pode executar: </para>

      <screen>
$ <userinput>rm arquivo1 arquivo2</userinput>
      </screen>

      <para>
      Se você quer remover um número elevado de arquivos que requerem confirmação antes
      de serem deletados, ou se você quer usar <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> para remover arquivos a partir de um script que
        não vai ser executado em um terminal, adicione o parâmetro
          <parameter class="command">-f</parameter> para evitar diálogos
        de confirmação.  Arquivos sem permissão de escrita, são excluídos
        com o parâmetro <filename>-f</filename> se as permissões do dono
        do arquivo permitirem.  Este parâmetro também vai suprimir a
        exibição de erros para <emphasis>stderr</emphasis> se o arquivo
        a ser excluído não existir. </para>

      <para>Diretórios também podem ser removidos recursivamente com o
        parâmetro <parameter class="command">-r</parameter>.
        <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> vai percorrer a estrutura do diretório, removendo
        links e excluindo diretórios conforme forem encontrados.  A mesma
        semântica é usada como quando arquivos normais são excluídos, da
        mesma forma como o parâmetro
        <parameter class="command">-f</parameter> foi concebido.  Para
        dar um exemplo simples, você pode remover recursivamente todos os
        arquivos e subdiretórios no diretório <filename>notas</filename>
        com: </para>

      <screen>
$ <userinput>rm -r notas</userinput>
      </screen>

      <!-- XXX - descrever o parâmetro -i? -->

      <para> Uma vez que o comando <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> usa a função <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>, blocos de dados não são regravados para um estado não inicializado.  A
        informação em blocos de dados só é sobrescrita quando elas são realocadas e usadas posteriormente.
        Para remover arquivos incluindo seus blocos de dados de forma segura, alguns sistemas disponibilizam um comando
         <citerefentry>
          <refentrytitle>shred</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> que sobrescreve os blocos de dados com dados aleatórios.  Mas isto não
        é efetivo em muitos sistemas de arquivo modernos (com journaling), porque eles não escrevem dados no local. </para>

      <para> O comando <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> provê uma das implementações da função <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>.  É relativamente pouco usável, pois não pode remover
        diretórios. </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-permissions">
    <title>Permissões</title>

    <para> Nós tocamos no assunto de permissões de arquivos e diretórios em <xref
        linkend="chap-filesystem-introduction-permissions"/>.  Nesta seção, vamos dar uma olhada nos comandos
      <citerefentry>
        <refentrytitle>chown</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry> e <citerefentry>
        <refentrytitle>chmod</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry>, que são usados para definir a propriedade e as permissões de arquivos,
      respectivamente.  Depois disto, vamos conferir uma extensão mais moderna às permissões chamada de
      Listas de Controle de Acesso (ACLs). </para>

    <sect2 xml:id="chap-filesystem-permissions-ownership">
      <title>Alterando o dono de um arquivo</title>

      <para> Como já vimos anteriormente, cada arquivo tem um ID do dono (usuário) e um ID do grupo armazenados no
        inode.  O comando <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> pode ser usado para definir estes campos.  Isto pode ser feito com IDs numéricos
        ou com seus nomes.  Por exemplo, para alterar o dono de um arquivo
        <filename>nota.txt</filename> para <emphasis>john</emphasis>, e seu grupo para
        <emphasis>staff</emphasis>, o seguinte comando é usado: </para>

      <screen>
$ <userinput>chown john:staff nota.txt</userinput>
      </screen>

      <para> Você também pode omitir qualquer desses componentes, para definir apenas um destes dois campos.  Se você
        quiser definir o nome do usuário, você não precisa informar os dois-pontos.  Assim, o comando acima poderia ser
        realizado em dois passos: </para>

      <screen>
$ <userinput>chown john nota.txt</userinput>
$ <userinput>chown :staff nota.txt</userinput>
      </screen>

      <para> Se você quiser mudar o dono de um diretório, e de todos os arquivos ou subdiretórios contidos
        nele, você pode adicionar um <parameter class="command">-R</parameter> ao <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>: </para>

      <screen>
$ <userinput>chown -R john:staff notas</userinput>
      </screen>

      <para> Se o nome do usuário e do grupo for especificado, ao invés de seus IDs, os nomes são convertidos
        pelo
        <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>.  Esta conversão baseia-se comumente na base de dados de senhas do sistema.  Se você
        está trabalhando em um sistema de arquivos que usa outra base de dados de senhas (p.ex. se você montou
        um sistema de arquivos raiz a partir de outro sistema para recuperação), frequentemente é útil mudar a
        propriedade usando o ID de usuário ou de grupo.  Desta maneira, você pode manter o mapeamento do nome
        do usuário/grupo intacto.  Assim, alterar a propriedade de <filename>nota.txt</filename> para o UID 1000 e
        GUID 1000 é feito da seguinte (e deduzível) maneira: </para>

      <screen>
$ <userinput>chown 1000:1000 nota.txt</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-permbits">
      <title>Modificando os bits de permissão de arquivos</title>

      <para> Depois de ler a introdução às permissões do sistema de arquivos em <xref
          linkend="chap-filesystem-introduction-permissions"/>, alterar os bits de permissão que
          são armazenados no inode é bastante fácil com o comando <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> aceita tanto representações numéricas quanto simbólicas das permissões.
        Representar as permissões de um arquivo numericamente é bastante prático, pois permite definir
        todas as permissões relevantes de uma vez.  Por exemplo: </para>

      <screen>
$ <userinput>chmod 0644 notas.txt</userinput>
      </screen>

      <para> Torna o arquivo <filename>notas.txt</filename> legível e gravável para o dono do arquivo, e
        legível para o grupo do arquivo e outros. </para>

      <para> Permissões simbólicas se prestam a adicionar ou remover permissões, e permitem alterações
        relativas nas permissões de arquivo.  A sintaxe para permissões simbólicas é: </para>

      <screen>
[ugo][-+][rwxst]
      </screen>

      <para> O primeiro componente especifica as classes de usuário às quais a mudança de permissão se aplica
        (usuário, grupo ou outros).  Caracteres múltiplos deste componente podem ser combinados.  O segundo
        componente remove (<emphasis>-</emphasis>) ou adiciona as permissões
        (<emphasis>+</emphasis>).  O terceiro componente é o descritor de acesso (leitura, escrita, execução,
        uso de UID/GID na execução, e sticky bit).  Múltiplos caracteres podem ser especificados neste componente
        também.  Vamos ver alguns exemplos para tornar isto mais claro: </para>

      <screen>
ug+rw        # Dá permissão de leitura/escrita ao usuário e ao grupo do arquivo
chmod go-x   # Remove a permissão de execução para o grupo do arquivo e para os outros.
chmod ugo-wx # Impossibilita todas as classes de usuário de escrever no arquivo e de executá-lo.
      </screen>

      <para> Estes comandos podem ser usados da seguinte maneira com chmod: </para>

      <screen>
$ <userinput>chmod ug+rw nota.txt</userinput>
$ <userinput>chmod go-x script1.sh</userinput>
$ <userinput>chmod ugo-x script2.sh</userinput>
      </screen>

      <para> As permissões de arquivos e diretórios podem ser alteradas recursivamente com o parâmetro <parameter
          class="command">-R</parameter>.  O seguinte comando torna o diretório
        <filename>notas</filename> legível a todos, incluindo seu conteúdo: </para>

      <screen>
$ <userinput>chmod -R ugo+r notas</userinput>
      </screen>

      <para> Cuidados extras devem ser tomados com diretórios, porque a permissão <emphasis>x</emphasis>
        tem um significado especial no contexto de diretórios.  Usuários com permissão de execução em diretórios
        podem acessar o diretório.  Usuários que não têm permissões de execução em diretórios não podem.  Devido
        a este comportamento particular, é quase sempre mais fácil mudar as permissões de uma estrutura de
        diretório e de seus arquivos com ajuda do comando <citerefentry>
          <refentrytitle>find</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> <!-- XXX xref -->. </para>

      <para> Há alguns poucos bits extras de permissão que podem ser definidos e que tem um significado especial.  Os
        SUID e SGID são os mais interessantes destes bits extras.  Estes bits modificam o
        ID do usuário ativo ou ID do grupo para aquele usuário ou grupo como o qual o arquivo está
        sendo executado.  O comando <command>su(1)</command> é um bom exemplo de um arquivo que frequentemente tem
        o bit SUID ativado: </para>

      <screen>
$ <userinput>ls -l /bin/su</userinput>
-rwsr-xr-x  1 root root 60772 Aug 13 12:26 /bin/su
      </screen>

      <para> Isso significa que o comando <command>su</command> executa como o usuário
        <emphasis>root</emphasis> quando executado.  O bit SUID pode ser definido com o modificador
        <emphasis>s</emphasis>.  Por exemplo, se o bit SUID não estivesse atribuído em
          <filename>/bin/su</filename> isto poderia ser feito com: </para>

      <screen>
$ <userinput>chmod u+s /bin/su</userinput>
      </screen>

      <note>
        <para> Por favor atente que ativas os bits SUID e SGID têm
        implicações de segurança.  Se um programa com estes bits definidos
        contiver um bug, ele poderá ser explorado para obter privilégios
        do dono do arquivo ou grupo.  Por este motivo é uma boa prática deixar
        a quantidade de arquivos com os bits SUID e SGID ativos restritos a
        restritos a um mínimo possível. </para>
      </note>

      <para> O sticky bit também é interessante quando aplicado a um
      diretório.  Ele impossibilita que usuários renomeiem ou excluam
      arquivos que não lhes pertencem, em diretórios que tenham acesso.
      Isto é comumente usado em diretórios com permissões de escrita para
      todos, como o diretório temporário (<filename>/tmp</filename>) em
      muitos sistemas UNIX.  O sticky bit pode ser atribuído com o
      modificador <emphasis>t</emphasis>: </para>

      <screen>
$ <userinput>chmod g+t /tmp</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-umask">
      <title>Máscara de criação de arquivo</title>

      <para>
    A pergunta que não quer calar é quais as permissões são usadas
    quando um arquivo é criado.  Isto depende de dois fatores: a flag de
    modo que for passada para a chamada de sistema
    <emphasis>open(2)</emphasis>, que é usada para criar um arquivo, e a
    máscara de criação de arquivo ativa.  A máscara de criação de arquivos
    pode ser representada como um número octal.  As permissões efetivas para
    criação do arquivo são determinadas como <emphasis>mode &amp;
    ~mask</emphasis>.  Ou, se estiver na representação octal, você pode
    subtrair os dígitos da máscara dos do modo.  Por exemplo, se um arquivo
    é criado com permissões <emphasis>0666</emphasis> (legível e gravável
    pelo usuário do arquivo, pelo grupo e por outros), e a máscara efetiva
    de criação de arquivo for <emphasis>0022</emphasis>, a permissão do
    resultante do arquivo será <emphasis>0644</emphasis>.  Vamos ver outro
    exemplo.  Suponha que arquivos ainda são criados com as permissões
    <emphasis>0666</emphasis>, e você é mais paranóico, e quer remover
    todas as permissões de leitura e escrita do grupo do arquivo e dos
    outros.  Isto quer dizer que você deve definir a máscara de criação
    de arquivos para <emphasis>0066</emphasis>, já que
    subtraindo <emphasis>0066</emphasis> de
    <emphasis>0666</emphasis> resulta em
    <emphasis>0600</emphasis>
      </para>

      <para>
        O valor da máscara de criação de arquivos pode ser consultado com
        o comando <command>umask</command>, que normalmente já existe
        como comando do próprio shell.  A máscara efetiva pode ser exibida
        executando <command>umask</command> sem nenhum parâmetro:
      </para>

      <screen>
$ <userinput>umask</userinput>
0002
      </screen>

      <para>
        O valor da máscara pode ser definido atribuindo um número octal
        como parâmetro.  Por exemplo:
      </para>

      <screen>
$ <userinput>umask 0066</userinput>
      </screen>

      <para>
        E podemos verificar que isso funciona criando um arquivo vazio:
      </para>

      <screen>
$ <userinput>touch test</userinput>
$ <userinput>ls -l test</userinput>
-rw-------  1 daniel daniel 0 Oct 24 00:10 test2
      </screen>

    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-acl">
      <title>Listas de Controle de Acesso</title>

      <para>
    Listas de Controle de Acesso (<acronym>ACL</acronym>s) são uma
    extensão às permissões de arquivos tradicionais do UNIX que permitem
    um controle de acesso mais específico.  Muitos sistemas que suportam
    sistemas de arquivos ACLs as implementam tal como especificado nos
    projetos das especificações POSIX.1e e POSIX.2c.  Exemplos de
    sistemas UNIX e UNIX-like que implementam ACLs de acordo com estas
    especificações são FreeBSD, Solaris e Linux.
      </para>

      <para>
    Como vimos em <xref
    linkend="chap-filesystem-introduction-permissions" /> listas de
    controle de acesso permitem a você usar trincas de leitura, escrita
    e execução adicionais para usuários ou grupos.  Diferentemente das
    permissões de arquivo tradicionais, listas de controle de acesso
    adicionais não são armazenadas diretamente no inode, mas em
    atributos estendidos que são associados aos arquivos.  Duas coisas
    com que precisamos ter cuidado ao usar listas de controle de acesso
    é que nem todos os sistemas as suportam, e também nem todos os
    programas dão suporte a elas.
      </para>

      <sect3 xml:id="chap-filesystem-permissions-acl-reading">
    <title>Lendo listas de controle de acesso</title>

    <para>
      Na maioria dos sistemas que suportam ACLs, o comando
      <command>ls</command> usa um indicador visual para mostrar que há
      ACLs associadas ao arquivo.  Por exemplo:
    </para>

    <screen>
$ <userinput>ls -l index.html</userinput>
-rw-r-----+ 1 daniel daniel 3254 2006-10-31 17:11 index.html
    </screen>

    <para>
      Como você pode ver, a coluna de permissões mostra um sinal de mais
      (<emphasis>+</emphasis>) adicional.  Os bits de permissão não agem
      exatamente da forma como você espera que eles ajam.  Vamos ver
      isso em instantes.
    </para>

    <para>
      As ACLs para um arquivo podem ser consultadas com o comando
      <command>getfacl</command>:
    </para>

    <screen>
$ <userinput>getfacl index.html</userinput>
# file: index.html
# owner: daniel
# group: daniel
user::rw-
group::---
group:www-data:r--
mask::r--
other::---
    </screen>

    <para>
      Muitas linhas podem ser facilmente interpretadas: o usuário do
      arquivo tem permissões de leitura/escrita, o grupo do arquivo não
      tem quaisquer permissões, usuários do grupo
      <emphasis>www-data</emphasis> têm permissão de leitura, e outros
      usuários também não têm permissões.  Mas por que esta saída mostra
      que não há permissões para o grupo do arquivo enquanto que o
      comando <command>ls</command> mostra permissão de leitura?  O
      segredo é que se houver uma entrada chamada
      <emphasis>mask</emphasis>, o <command>ls</command> exibirá o valor
      da máscara, ao invés das permissões do grupo do arquivo.
    </para>

    <para>
      A entrada <emphasis>mask</emphasis> é usada para restringir todas
      as entradas da listagem exceto a do usuário do arquivo, e a dos
      outros usuários.  Para interpretar ACLs, é melhor memorizar as
      seguintes regras:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          As permissões da entrada <emphasis>user::</emphasis>
          correspondem às permissões do dono do arquivo.
        </para>
      </listitem>
      <listitem>
        <para>
          As permissões da entrada <emphasis>group::</emphasis>
          correspondem às permissões do grupo do arquivo, a menos que
          haja uma entrada <emphasis>mask::</emphasis>.  Se houver uma
          entrada <emphasis>mask::</emphasis>, as permissões do grupo
          correspondem à entrada de grupo tendo a entrada de máscara
          como o máximo de permissões permitidas (significando que as
          restrições de grupo podem ser mais restritivas, mas não mais
          permissivas).
        </para>
      </listitem>
      <listitem>
        <para>
          As permissões de outros usuários e grupos correspondem às suas
          entradas <emphasis>user:</emphasis> e
          <emphasis>group:</emphasis>, com o valor de
          <emphasis>mask::</emphasis> como suas permissões máximas.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      A segunda e terceira regras podem ser claramente observadas se
      houver um usuário ou grupo que tenha mais permissões que a máscara
      para o arquivo:
    </para>

    <screen>
$ <userinput>getfacl links.html</userinput>
# file: links.html
# owner: daniel
# group: daniel
user::rw-
group::rw-                      #effective:r--
group:www-data:rw-              #effective:r--
mask::r--
other::---
    </screen>

    <para>
      Ainda que as permissões de leitura e escrita sejam especificadas
      para o grupo do arquivo e para o grupo
      <emphasis>www-data</emphasis>, ambos os grupos efetivamente terão
      apenas permissão de leitura, pois esta é a permissão máxima que a
      máscara permite.
    </para>

    <para>
      Outro aspecto a que devemos prestar atenção é a manipulação de
      ACLs em diretórios.  Listas de controle de acesso podem ser
      adicionadas a diretórios para gerenciar o acesso, mas os
      diretórios podem também ter <emphasis>ACLs padrão</emphasis> as
      quais especificam as ACLs iniciais para arquivos e diretórios
      criados dentro do diretório em questão.
    </para>

    <para>
      Suponha que o diretório <filename>relatorios/</filename> tenha a
      seguinte ACL:
    </para>

    <screen>
$ <userinput>getfacl relatorios</userinput>
# file: relatorios
# owner: daniel
# group: daniel
user::rwx
group::r-x
group:www-data:r-x
mask::r-x
other::---
default:user::rwx
default:group::r-x
default:group:www-data:r-x
default:mask::r-x
default:other::---
    </screen>

    <para>
      Os novos arquivos que forem criados dentro do diretórios
      <filename>relatorios</filename> obtém sua ACL baseada nas entradas
      que têm um <emphasis>default:</emphasis> como prefixo.  Por
      exemplo:
    </para>

    <screen>
$ touch relatorios/teste
$ getfacl reportorios/teste
# file: reportorios/teste
# owner: daniel
# group: daniel
user::rw-
group::r-x                      #effective:r--
group:www-data:r-x              #effective:r--
mask::r--
other::---
    </screen>

    <para>
      Como você pode ver, a ACL padrão foi copiada.  O bit de execução
      foi removido da máscara, pois o novo arquivo não foi criado com
      permissão de execução.
    </para>
      </sect3>

      <sect3 xml:id="chap-filesystem-permissions-acl-setting">
    <title>Criando listas de controle de acesso</title>

    <para>
      A ACL para um arquivo ou diretório pode ser modificada com o
      comando <command>setfacl</command>.  Infelizmente, sua utilização
      é fortemente dependente do sistema em que está sendo usado.  Para
      aumentar a confusão, pelo menos uma opção importante (<parameter
      class="command">-d</parameter>) tem significados diferentes em
      diferentes sistemas.  Pode-se apenas esperar que este comando seja
      padronizado algum dia.
    </para>

    <table xml:id="chap-filesystem-permissions-acl-setting-flags">
      <title>Opções específicas de sistemas do <command>setfacl</command></title>

      <tgroup cols="2">
        <thead>
          <row>
        <entry>Operação</entry>
        <entry>Linux</entry>
          </row>
        </thead>
        <tbody>
          <row>
        <entry>Define entradas, removendo todas as entradas antigas</entry>
        <entry><parameter class="command">--set</parameter></entry>
          </row>
          <row>
        <entry>Modifica entradas</entry>
        <entry><parameter class="command">-m</parameter></entry>
          </row>
          <row>
        <entry>Modifica as entradas ACL padrão</entry>
        <entry><parameter class="command">-d</parameter></entry>
          </row>
          <row>
        <entry>Remove entradas</entry>
        <entry><parameter class="command">-x</parameter></entry>
          </row>
          <row>
        <entry>
          Remove todas as entradas ACL (exceto as três entradas que são
          requeridas.)
        </entry>
        <entry><parameter class="command">-b</parameter></entry>
          </row>
          <row>
        <entry>Recalcula a máscara</entry>
        <entry>
          Sempre recalculada, a menos que <parameter
          class="command">-n</parameter> seja usado, ou uma entrada de
          máscara seja especificada explicitamente.
        </entry>
          </row>
          <row>
        <entry>Usa a especificação ACL a partir de um arquivo</entry>
        <entry>
          <parameter class="command">-M</parameter> (modificar),
          <parameter class="command">-X</parameter> (excluir),
          ou <parameter class="command">--restore</parameter>
        </entry>
          </row>
          <row>
        <entry>Modificação recursiva de ACLs</entry>
        <entry><parameter class="command">-R</parameter></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      Como vimos nas seções anteriores, entradas podem ser especificadas
      para usuários e grupos usando-se a seguinte sintaxe:
      <emphasis>user/group:name:permissions</emphasis>.  Permissões
      podem ser especificadas como uma tripla através do uso das letras
      <emphasis>r</emphasis> (leitura), <emphasis>w</emphasis>
      (escrita), ou <emphasis>x</emphasis> (execução).  Um hífen
      (<emphasis>-</emphasis>) deve ser usado para as permissões que
      você não quer dar para aquele usuário ou grupo, uma vez que é
      requerido pelo Solaris.  Se você quiser desabilitar o acesso
      completamente, você pode usar a tripla <emphasis>---</emphasis>.
    </para>

    <para>
      A especificação para outros usuários, e a máscara segue este
      formato: <emphasis>other:r-x</emphasis>.  O formato seguinte,
      ligeiramente mais intuitivo, também pode ser usado:
      <emphasis>other::r-x</emphasis>.
    </para>

    <sect4 xml:id="chap-filesystem-permissions-acl-setting-modify">
      <title>Modificando entradas ACL</title>

      <para>
        A operação mais simples é modificar uma entrada ACL.  Isto vai
        criar uma nova entrada se a entrada ainda não existir.  Entradas
        podem ser modificadas com <parameter
        class="command">-m</parameter>.  Por exemplo, suponha que
        queiramos dar acesso de leitura e escrita para o grupo
        <emphasis>friends</emphasis> ao arquivo
        <filename>report.txt</filename>.  Isto pode ser feito com:
      </para>

      <screen>
$ <userinput>setfacl -m group:friends:rw- report.txt</userinput>
      </screen>

      <para>
        A entrada de máscara será recalculada, definindo-a para a união
        dos três grupos de entradas, e as entradas de usuário
        adicionais:
      </para>

      <screen>
$ <userinput>getfacl report.txt</userinput>
# file: report.txt
# owner: daniel
# group: daniel
user::rw-
group::r--
group:friends:rw-
mask::rw-
other::r--
      </screen>

      <para>
        Você pode combinar múltiplas entradas ACL separando-as por
        vírgulas.  Por exemplo:
      </para>

      <screen>
$ <userinput>setfacl -m group:friends:rw-,group:foes:--- report.txt</userinput>
      </screen>
    </sect4>

    <sect4 xml:id="chap-filesystem-permissions-acl-setting-removing">
      <title>Removendo entradas ACL</title>

      <para>
        Uma entrada pode ser removida com a opção <parameter
        class="command">-x</parameter>:
      </para>

      <screen>
$ <userinput>setfacl -x group:friends: report.txt</userinput>
      </screen>

      <para>
        O caractere dois-pontos do final é opcional e pode ser omitido.
      </para>
    </sect4>

    <sect4 xml:id="chap-filesystem-permissions-acl-setting-new">
      <title>Criando uma nova ACL</title>

      <para>
        A opção <parameter class="command">--set</parameter> está
        disponível para a criação de uma nova lista de controle de
        acesso para um arquivo, limpando todas as entradas existentes,
        exceto pelas três entradas requeridas.  É obrigatório que as
        entradas de usuário do arquivo, de grupo e de outros também
        sejam especificadas.  Por exemplo:
      </para>

      <screen>
$ <userinput>setfacl --set user::rw-,group::r--,other:---,group:friends:rwx report.txt</userinput>
      </screen>

      <para>
        Se você não quer limpar as permissões de usuário, grupo e
        outros, mas quer limpar todas as outras entradas ACL, você pode
        usar a opção <parameter class="command">-b</parameter>.  O
        exemplo seguinte a utiliza em conjunto com a opção <parameter
        class="command">-m</parameter> para limpar todas as entradas ACL
        (exceto para usuário, grupo e outros), e para adicionar uma
        entrada para o grupo <emphasis>friends</emphasis>:
      </para>

      <screen>
$ <userinput>setfacl -b -m group:friends:rw- report.txt</userinput>
      </screen>
    </sect4>

    <sect4 xml:id="chap-filesystem-permissions-acl-setting-default">
      <title>Definindo uma ACL padrão</title>

      <para>
        Como vimos em <xref
        linkend="chap-filesystem-permissions-acl" />, diretórios podem
        ter entradas ACL padrão que especifiquem que permissões devem
        ser usadas por arquivos e diretórios que forem criados dentro
        desse diretório.  A opção <parameter class="command">-d</parameter>
        é usada para operar sobre entradas padrão:
      </para>

      <screen>
$ <userinput>setfacl -d -m group:friends:rwx reports</userinput>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:friends:rwx
default:mask::rwx
default:other::r-x
      </screen>
    </sect4>

    <sect4 xml:id="chap-filesystem-permissions-acl-setting-filesource">
      <title>Usando uma ACL a partir de um arquivo de referência</title>

      <para>
        Você também pode usar uma definição ACL a partir de um arquivo,
        ao invés de especificá-la na linha de comando.  Um arquivo de
        entrada segue a mesma sintaxe para especificação de entradas que
        o <command>setfacl</command>, mas as entradas são separadas por
        linhas, ao invés de por vírgulas.  Isto é muito útil, já que
        você pode usar a ACL para um arquivo existente como referência:
      </para>

      <screen>
$ <userinput>getfacl report.txt > ref</userinput>
      </screen>

      <para>
        A opção <parameter class="command">-M</parameter> existe para
        modificar a ACL para um arquivo através da leitura das entradas
        a partir de um arquivo.  Assim, se tivermos um arquivo chamado
        <filename>report2.txt</filename>, podemos modificar a ACL para
        este arquivo com as entradas de <filename>ref</filename> com:
      </para>

      <screen>
$ <userinput>setfacl -M ref report2.txt</userinput>
      </screen>

      <para>
        Se você quiser iniciar com uma ACL limpa, e adicionar as
        entradas a partir de <filename>ref</filename>, você pode
        adicionar o parâmetro <parameter class="command">-b</parameter>
        que apresentamos anteriormente:
      </para>

      <screen>
$ <userinput>setfacl -b -M ref report2.txt</userinput>
      </screen>

      <para>
        É claro, não é necessário sequer usar este arquivo por completo.
        Podemos canalizar (pipe) a saída
        de <command>getfacl</command> diretamente para
        <command>setfacl</command>, usando o nome simbólico para a
        entrada padrão (<emphasis>-</emphasis>), ao invés de um nome de
        arquivo:
      </para>

      <screen>
$ <userinput>getfacl report.txt | setfacl -b -M - report2.txt</userinput>
      </screen>

      <para>
        O <parameter class="command">-X</parameter> remove as entradas
        ACL definidas num arquivo.  Isto segue a mesma sintaxe que o
        parâmetro <parameter class="command">-x</parameter>, com
        vírgulas substituídas por novas-linhas.
      </para>
    </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-finding">
    <title>Procurando arquivos</title>

    <sect2 xml:id="chap-filesystem-finding-find">
      <title>find</title>

      <para>
    O comando <command>find</command>, sem dúvida, é o utilitário mais
    compreensível para procurar arquivos em sistemas UNIX.  Pelo fato de
    que fato de que funciona de uma maneira simples e previsível:
    o <command>find</command> irá varrer a árvore ou árvores de
    diretório que forem especificadas como parâmetro para o
    <command>find</command>.  Além disso, um usuário pode especificar
    uma expressão que será avaliada para cada arquivo e diretório.  O
    nome do arquivo ou diretório será exibido se a expressão for
    avaliada para <emphasis>true</emphasis>.  O primeiro argumento que
    inicia com um hífen (<emphasis>-</emphasis>), ponto de exclamação
    (<emphasis>!</emphasis>, ou abre-parênteses (<emphasis>(</emphasis>,
    significa o início da expressão.  A expressão pode consistir de
    vários operandos.  De forma simplificada, a sintaxe do
    <command>find</command> e: <emphasis>find caminhos expressão</emphasis>.
      </para>

      <para>
    O uso mais simples de <command>find</command> é não especificar
    nenhuma expressão.  Como o comando corresponde cada entrada de
    diretório e subdiretório, todos os arquivos e diretórios serão
    exibidos.  Por exemplo:
      </para>

      <screen>
$ <userinput>find .</userinput>
.
./economic
./economic/report.txt
./economic/report2.txt
./technical
./technical/report2.txt
./technical/report.txt
      </screen>

      <para>
    Você também pode especificar múltiplos diretórios:
      </para>

      <screen>
$ <userinput>find economic technical</userinput>
economic
economic/report.txt
economic/report2.txt
technical
technical/report2.txt
technical/report.txt
      </screen>

      <sect3 xml:id="chap-filesystem-finding-find-nametype">
    <title>Operandos delimitadores por nome ou tipo de objeto</title>

    <para>
      Um cenário comum para procura de arquivos ou diretórios é
      procurá-los pelo nome.  O operando <emphasis>-name</emphasis> pode
      ser usado para corresponder objetos com um dado nome, ou que casem
      com um determinado coringa.  Por exemplo, usar o operando
      <emphasis>-name 'report.txt'</emphasis> irá apenas ser verdadeiro
      para arquivos ou diretórios com o nome
      <filename>report.txt</filename>.  Por exemplo:
    </para>

    <screen>
$ <userinput>find economic technical -name 'report.txt'</userinput>
economic/report.txt
technical/report.txt
    </screen>

    <para>
      A mesma coisa se aplica quando se usa coringas:
    </para>

    <screen>
$ <userinput>find economic technical -name '*2.txt'</userinput>
economic/report2.txt
technical/report2.txt
    </screen>

    <note>
      <para>
        Ao usar o <command>find</command> você vai querer passar o
        caractere coringa ao <command>find</command>, ao invés de deixar
        o shell expandi-lo.  Assim, certifique-se de que os padrões ou
        sejam delimitados por aspas, ou que os coringas sejam escapados.
      </para>
    </note>

    <para>
      Também é possível avaliar o tipo dos objetos com o operando
      <emphasis>-type c</emphasis>, onde <emphasis>c</emphasis>
      especifica o tipo a ser correspondido.
      <xref
      linkend="chap-filesystem-finding-find-nametype-type-params"
      /> lista os vários tipos de objetos que podem ser usados.
    </para>

    <table xml:id="chap-filesystem-finding-find-nametype-type-params">
      <title>Parâmetros para o operando '-type'</title>

      <tgroup cols="2">
        <thead>
          <row>
        <entry>Parâmetro</entry><entry>Significado</entry>
          </row>
        </thead>
        <tbody>
          <row>
        <entry>b</entry><entry>Arquivo de dispositivo de block</entry>
          </row>
          <row>
        <entry>c</entry><entry>Arquivo de dispositivo de caractere</entry>
          </row>
          <row>
        <entry>d</entry><entry>Diretório</entry>
          </row>
          <row>
        <entry>f</entry><entry>Arquivo normal</entry>
          </row>
          <row>
        <entry>l</entry><entry>Link simbólico</entry>
          </row>
          <row>
        <entry>p</entry><entry>FIFO</entry>
          </row>
          <row>
        <entry>s</entry><entry>Socket</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      Assim, por exemplo, se você quiser encontrar diretórios, você
      poderia usar o parâmetro <emphasis>d</emphasis> para o operando
      <emphasis>-type</emphasis>:
    </para>

    <screen>
$ <userinput>find . -type d</userinput>
.
./economic
./technical
    </screen>

    <para>
      Vamos ver como formar expressões mais complexas ao final desta
      seção sobre o <command>find</command>, mas neste momento é útil
      saber que você pode fazer uma expressão booleana 'and'
      especificando múltiplos operandos.  Por exemplo
      <emphasis>operando1 operando2</emphasis> é verdadeiro se tanto
      <emphasis>operando1</emphasis> e
      <emphasis>operando2</emphasis> forem verdadeiros para o objeto
      sendo avaliado.  Então, você pode combinar os operandos
      <emphasis>-name</emphasis> e <emphasis>-type</emphasis> para
      encontrar todos os diretórios que comecem com
      <emphasis>eco</emphasis>:
    </para>

    <screen>
$ <userinput>find . -name 'eco*' -type d</userinput>
./economic
    </screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-perms">
    <title>Operandos que especificam a propriedade ou permissões</title>

    <para>
      Além de casar objetos por seus nomes ou tipos, você também pode
      procurá-los por suas permissões ativas ou pela propriedade do
      objeto.  Isto frequentemente é útil para encontrar arquivos que
      tenham permissões ou propriedade incorretas.
    </para>

    <para>
      O dono (usuário) ou grupo de um objeto podem ser correspondidos
      respectivamente com as opções <emphasis>-user nome_do_usuario</emphasis>
      e <emphasis>-group nome_do_grupo</emphasis>.  O nome do usuário ou
      grupo será interpretado como um ID de usuário ou ID de grupo cujo
      nome é decimal, e poderia não ser encontrado no sistema com
      <citerefentry><refentrytitle>getpwnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>
      ou
      <citerefentry><refentrytitle>getgrnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
      Assim, se você quiser obter todos os objetos que pertençam ao
      usuário <emphasis>joe</emphasis>, você poderia usar
      <emphasis>-user joe</emphasis> como um operando:
    </para>

    <screen>
$ <userinput>find . -user joe</userinput>
./secret/report.txt
    </screen>

    <para>
      Ou para encontrar todos os objetos que tenham
      <emphasis>friend</emphasis> como grupo de arquivo:
    </para>

    <screen>
$ <userinput>find . -group friends</userinput>
./secret/report.txt
    </screen>

    <para>
      O operando para verificação das permissões de arquivos
      <emphasis>-perm</emphasis> é menos trivial.  Como o comando
      <command>chmod</command>, este operador pode trabalhar com
      notações de permissões octais e simbólicas.  Vamos começar olhando
      a notação octal.  Se um número octal for especificado como
      parâmetro para o operando <emphasis>-perm</emphasis>, ele irá
      corresponder a todos os objetos que tenham exatamente aquelas
      permissões.  Por exemplo, <emphasis>-perm 0600</emphasis> irá
      procurar por todos os objetos que tenham apenas permissões de
      leitura e escrita para o usuário, e não tenham opções adicionais
      definidas:
    </para>

    <screen>
$ <userinput>find . -perm 0600</userinput>
./secret/report.txt
    </screen>

    <para>
      Se um hífen for adicionado como prefixo para um número, ele irá
      procurar cada objeto que tenha pelo menos os bits definidos tal
      como especificado pelo número octal.  Um exemplo útil é procurar
      todos os arquivos que tenham pelo menos os bits de escrita
      definidos para <emphasis>outros</emphasis> usuários com
      <emphasis>-perm -0002</emphasis>.  Isto pode lhe ajudara encontrar
      nós de dispositivos ou outros objetos com permissões inseguras.
    </para>

    <screen>
$ <userinput>find /dev -perm -0002</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
    </screen>

    <note>
      <para>
        Alguns nós de dispositivos precisam ser graváveis por todos para
        que um sistema UNIX funcione corretamente.  Por exemplo, o
        dispositivo <filename>/dev/null</filename> deve ser sempre
        gravável.
      </para>
    </note>

    <para>
      A notação simbólica dos parâmetros <emphasis>-perm</emphasis> usa
      a mesma notação que o comando <command>chmod</command>.
      Permissões simbólicas são construídas com um modo de arquivo em
      que todos os bits são zerados, então nunca será preciso usar um
      hífen para desmarcar permissões.  Isto também evita ambiguidade que
      poderia se ter com o uso do prefixo hífen de permissões.  Como a
      sintaxe octal, prefixar a permissão com um hífen irá casar com
      objetos que tenham pelo menos os bits de permissão especificados.
      O uso de nomes simbólicos é bastante previsível - os dois comandos
      seguintes repetem os exemplos anteriores com permissões
      simbólicas:
    </para>

    <screen>
$ <userinput>find . -perm u+rw</userinput>
./secret/report.txt
    </screen>

    <screen>
$ <userinput>find /dev -perm -o+w</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
    </screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-time">
    <title>Operandos que limitam pelo horário de criação do objeto</title>

    <para>
      Há três operando que funcionam sobre intervalos de tempo.  A
      sintaxe do operando é <emphasis>operando n</emphasis>, onde
      <emphasis>n</emphasis> é o tempo em dias.  Todos os três operandos
      calculam a diferença de tempo em segundos que é dividida pelo
      número de segundos de um dia (86400), descartando o resto.  Então,
      se a diferença for de um dia, <emphasis>operando 1</emphasis> irá
      casar com o objeto.  Os três operandos são:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>-atime n</emphasis> - o operando resulta em
          verdadeiro se o momento de execução do <command>find</command>
          menos o horário do último acesso do objeto for igual a
          <emphasis>n</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>-ctime n</emphasis> - este operando resulta em
          verdadeiro se o momento de execução do <command>find</command>
          menos o horário da última alteração na informação de status do
          arquivo for igual a <emphasis>n</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>-mtime n</emphasis> - este operando resulta em
          verdadeiro se o momento de execução do <command>find</command>
          menos o horário da última modificação no arquivo for igual a
          <emphasis>n</emphasis>.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      Assim, estes operandos correspondem se o último acesso, última
      alteração e última modificação, respectivamente, tiverem sido a
      <emphasis>n</emphasis> dias atrás.  Para dar um exemplo, o comando
      seguinte mostra todos os objetos em <filename>/etc</filename> que
      tenham sido modificados há um dia:
    </para>

    <screen>
$ <userinput>find /etc -mtime 1</userinput>
/etc
/etc/group
/etc/master.passwd
/etc/spwd.db
/etc/passwd
/etc/pwd.db
    </screen>

    <para>
      O sinal de mais ou de menos pode ser usado como modificadores para
      o significado de <emphasis>n</emphasis>.  <emphasis>+n</emphasis>
      significa mais do que <emphasis>n</emphasis> dias,
      <emphasis>-n</emphasis> significa menos do que
      <emphasis>n</emphasis> dias.  Assim, para encontrar todos os
      arquivos em <filename>/etc</filename> que tiverem sido modificados
      há menos de dois dias, você poderia executar:
    </para>

    <screen>
$ <userinput>find /etc -mtime -2</userinput>
/etc
/etc/network/run
/etc/network/run/ifstate
/etc/resolv.conf
/etc/default
/etc/default/locale
[...]
    </screen>

    <para>
      Outro operando temporal útil é o <emphasis>-newer
      reffile</emphasis>.  Este irá casar com todos os arquivos que
      tiverem sido modificados depois das modificações no arquivo
      chamado <filename>reffile</filename>.  O exemplo a seguir mostra
      como você poderia usar isto para listar todos os arquivos
      modificados depois de <filename>economic/report2.txt</filename>:
    </para>

    <screen>
$ <userinput>find . -newer economic/report2.txt</userinput>
.
./technical
./technical/report2.txt
./technical/report.txt
./secret
./secret/report.txt
    </screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-depth">
    <title>Operandos que afetam o percurso da árvore</title>

    <para>
      Alguns operandos afetam a maneira na qual o comando
      <command>find</command> percorre a árvore.  O primeiro desses
      operandos é o <emphasis>-xdev</emphasis>.  O
      <emphasis>-xdev</emphasis> evita que o <command>find</command>
      desça nos diretórios que têm um ID de dispositivo diferente,
      evitando efetivamente a varredura de outros sistemas de arquivos.
      O diretório no qual o sistema de arquivos é montado é exibido,
      pois este operando sempre retorna <emphasis>true</emphasis>.  Um
      bom exemplo é um sistema em que o <filename>/usr</filename> seja
      montado num outro sistema de arquivos que o
      <filename>/</filename>.  Por exemplo, se procurarmos pelos
      diretórios com o nome <emphasis>bin</emphasis>, o que pode gerar
      o seguinte resultado:
    </para>

    <screen>
$ <userinput>find / -name 'bin' -type d</userinput>
/usr/bin
/bin
    </screen>

    <para>
      Mas se adicionarmos <emphasis>-xdev</emphasis>,
      <filename>/usr/bin</filename> não será encontrado, porque está num
      sistema de arquivo (e um dispositivo) diferente :
    </para>

    <screen>
$ <userinput>find / -name 'bin' -type d -xdev</userinput>
/bin
    </screen>

    <para>
      O operando <emphasis>-depth</emphasis> modifica a ordem em que
      cada diretório é avaliado.  Com <emphasis>-depth</emphasis>, o
      conteúdo de um diretório é verificado primeiro, e só então o
      diretório em si.  Isto pode ser ilustrado com o seguinte exemplo:
    </para>

    <screen>
$ <userinput>find . -depth</userinput>
./economic/report.txt
./economic/report2.txt
./economic
./technical/report2.txt
./technical/report.txt
./technical
.
    </screen>

    <para>
      Como você pode ver na saída, os arquivos no diretório
      <emphasis>./economic</emphasis> são verificados antes de
      <filename>.</filename>, e
      <filename>./economic/report.txt</filename> antes de
      <filename>./economic</filename>.  O <emphasis>-depth</emphasis>
      sempre avalia para <emphasis>true</emphasis>.
    </para>

    <para>
      Finalmente, o operando <emphasis>-prune</emphasis> faz com que o
      find não desça dentro do diretório que está sendo avaliado.
      <emphasis>-prune</emphasis> é descartado se o operando
      <emphasis>-depth</emphasis> também for usado.
      <emphasis>-depth</emphasis> também sempre avalia para
      <emphasis>true</emphasis>.
    </para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-exec">
    <title>Operandos que executam utilitários externos</title>

    <para>
      O <command>find</command> se torna uma ferramenta muito poderosa
      quando combinado com utilitários externos.  Isto pode ser feito
      com o operando <emphasis>-exec</emphasis>.  Há duas sintaxes para
      o operando <emphasis>-exec</emphasis>.  A primeira sintaxe é
      <emphasis>-exec comando argumentos;</emphasis>.  O comando
      <emphasis>comando</emphasis> será executado com os argumentos
      especificados para cada objeto que estiver sendo avaliado.  Se
      algum dos argumentos for <emphasis>{}</emphasis>, estas chaves
      serão substituídas pelo arquivo que estiver sendo avaliado.  Isto
      é bastante útil, especialmente quando consideramos que, se não
      usarmos nenhuma expressão de sintaxe adicional, os operandos irão
      ser avaliados da esquerda para a direita.  Vamos dar um exemplo:
    </para>

    <screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} \;</userinput>
    </screen>

    <para>
     O primeiro operando retorna verdadeiro para arquivos que tenham
     suas permissões atribuídas para <emphasis>0666</emphasis>.  O
     segundo operando executa <emphasis>chmod 0644 filename</emphasis>
     para cada arquivo que estiver sendo avaliado.  Se você está se
     perguntando porque não executar este comando para cada arquivo,
     esta é uma boa pergunta.  Como muitos outros interpretadores de
     expressões, o <command>find</command> usa avaliação em
     <quote>curto-circuito</quote>.  Como nenhum outro operando for
     especificado, o operador lógico <emphasis>and</emphasis> é
     automaticamente assumido entre ambos os operandos.  Se o primeiro
     operando avaliar para falso, <emphasis>false</emphasis>, não faz
     sentido avaliar quaisquer outros operandos, pois a expressão
     completa será avaliada para falso.  Então, o operando
     <emphasis>-exec</emphasis> só será avaliado se o primeiro operando
     for verdadeiro.  Outra particularidade é que o ponto-e-vírgula que
     encerra o <emphasis>-exec</emphasis> é escapado para prevenir que o
     shell tente interpretá-lo.
    </para>

    <para>
      Uma ótima coisa sobre o operador <emphasis>-exec</emphasis> é que
      ele avaliado para <emphasis>true</emphasis> se o comando for
      concluído com sucesso.  Então, você também poderia usar o comando
      <emphasis>-exec</emphasis> para adicionar condições extras não
      representadas por operandos do <command>find</command>.  Por
      exemplo, o seguinte comando exibe todos os objetos que terminem
      com <emphasis>.txt</emphasis> e que contenham a string
      <emphasis>gross income</emphasis>:
    </para>

    <screen>
$ <userinput>find . -name '*.txt' -exec grep -q 'gross income' {} \; -print</userinput>
./economic/report2.txt
    </screen>

    <para>
      O comando <command>grep</command> será abordado mais à frente.
      <!-- XXX - xref --> Mas por hora, nos basta saber que ele pode ser
      usado para encontrar padrões de texto.  O operando
      <emphasis>-print</emphasis> exibe o caminho atual do objeto.  Ele
      é sempre usado implicitamente, exceto quando os operandos
      <emphasis>-exec</emphasis> ou <emphasis>-ok</emphasis> são usados.
      <!-- XXX - move to introduction? -->
    </para>

    <para>
      A segunda sintaxe do operando <emphasis>-exec</emphasis> é
      <emphasis>-exec utility arguments {} +</emphasis>.  Esta, pega um
      conjunto de todos os objetos correspondidos para os quais a
      expressão é verdadeira, e provê este conjunto de arquivos como um
      argumento para o utilitário que foi especificado.  O primeiro
      exemplo do operando <emphasis>-exec</emphasis> também pode ser
      escrito como:
    </para>

    <screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} +</userinput>
    </screen>

    <para>
      Isto irá executar o comando <command>chmod</command> apenas uma
      vez, com todos os arquivos com os quais a expressão for verdadeira
      como seus argumentos.  Este operando sempre returna
      <emphasis>true</emphasis>.
    </para>

    <para>
      Se um comando executado pelo find retorna um valor diferente de
      zero (significando que a execução do comando não foi bem
      sucedida), o <command>find</command> deveria retornar um valor
      diferente de zero.
    </para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-operators">
    <title>Operadores para construção de expressões complexas</title>

    <para>
      O <command>find</command> provê alguns operadores que podem ser
      combinados para fazer expressões mais complexas:
    </para>

    <variablelist>
      <title>Operadores</title>

      <varlistentry>
        <term>( expr )</term>
        <listitem>
          <para>
        Resulta em <emphasis>true</emphasis> se
        <emphasis>expr</emphasis> resultar em
        <emphasis>true</emphasis>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>expr1 [-a] expr2</term>
        <listitem>
          <para>
        Resulta em <emphasis>true</emphasis> se tanto
        <emphasis>expr1</emphasis> quanto <emphasis>expr2</emphasis>
        forem true.  Se <emphasis>-a</emphasis> for omitido,
        este operador é assumido implicitamente.
          </para>

          <para>
        O <command>find</command> usará avaliação em curto-circuito
        quando este operador for avaliado: <emphasis>expr2</emphasis>
        não será avaliada quando <emphasis>expr1</emphasis> resultar em
        <emphasis>false</emphasis>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>expr1 -o expr2</term>
        <listitem>
          <para>
        Resulta em <emphasis>true</emphasis> se ou um ou outro, ou ambos
        <emphasis>expr1</emphasis> e <emphasis>expr2</emphasis> forem
        true.
          </para>

          <para>
        O <command>find</command> usa avaliação em curto-circuito também
        quando este operador é avaliado: <emphasis>expr2</emphasis> não
        será avaliada quando <emphasis>expr1</emphasis> resultar em
        <emphasis>true</emphasis>
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>! expr</term>
        <listitem>
          <para>
        Nega <emphasis>expr</emphasis>.  Assim, se a expressão
        <emphasis>expr</emphasis> avaliar para true, o resultado irá
        avaliar para <emphasis>false</emphasis> e vice-versa.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>
      Uma vez que tanto os parênteses quanto a exclamação são
      interpretados pela maioria dos shells, comumente eles devem ser
      precedidos de um caractere de escape.
    </para>

    <para>
      O exemplo seguinte mostra alguns operadores em ação.  Este comando
      executa <command>chmod</command> para todos os arquivos que tenham
      ou permissão <emphasis>0666</emphasis> ou
      <emphasis>0664</emphasis>.
    </para>

    <screen>
$ <userinput>find . \( -perm 0666 -o -perm 0664 \) -exec chmod 0644 {} \;</userinput>
    </screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-which">
      <title>which</title>

      <para>
       O comando <command>which</command> não é parta da Especificação
       Única do UNIX versão 3, mas está disponível na maioria dos
       sistemas.  <command>which</command> localiza um comando que
       estiver no path do usuário (como definido pela variável de
       ambiente PATH), exibindo seu caminho completo.  Informando o nome
       de um comando como seu parâmetro irá mostrar o caminho completo
       correspondente:
      </para>

      <screen>
$ <userinput>which ls</userinput>
/bin/ls
      </screen>

      <para>
       Você também pode descobrir os caminhos de múltiplos comandos:
      </para>

      <screen>
$ <userinput>which ls cat</userinput>
/bin/ls
/bin/cat
      </screen>

      <para>
       O <command>which</command> retorna um valor não-zero se o caminho
       do comando não puder se encontrado.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-whereis">
      <title>whereis</title>

      <para>
       Este comando <command>whereis</command> procura por binários,
       páginas de manual e arquivos-fonte de um comando em alguns locais
       pré-definidos.  Por exemplo, o comando a seguir mostra o caminho
       de <command>ls</command> e da página de manual de
       <citerefentry><refentrytitle>ls</refentrytitle><manvolnum>1</manvolnum></citerefentry>:
      </para>

      <screen>
$ <userinput>whereis ls</userinput>
ls: /bin/ls /usr/share/man/man1/ls.1.gz
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-locate">
      <title>locate</title>

      <para>
       O Slackware Linux também provê o comando
       <command>locate</command> que realiza buscas em uma base de dados
       de arquivos que pode ser gerada periodicamente com o comando
       <command>updatedb</command>.  Como este comando usa uma base de
       dados pré-construída no sistema de arquivos, ele é muito mais
       rápido que <command>command</command>, especialmente quando as
       informações de entradas de diretórios ainda não estiverem sendo
       mantidas em cache.  Porém, a dupla
       <command>locate</command>/<command>updatedb</command> tem alguns
       pontos fracos:
      </para>

      <itemizedlist>
    <listitem>
      <para>
        Novos arquivos não farão parte da base de dados até a próxima
        execução de <command>updatedb</command>.
      </para>
    </listitem>
    <listitem>
      <para>
        O <command>locate</command> não tem conceito de permissões,
        então os usuários podem localizar arquivos que normalmente não
        seriam visíveis por eles.
      </para>
    </listitem>
    <listitem>
      <para>
        Uma implementação mais nova, chamada de
        <emphasis>slocate</emphasis> já lida com permissões, mas
        necessita de privilégios elevados.  Esta é a variação do
        <command>locate</command> que é incluída com o Slackware Linux.
      </para>
    </listitem>
      </itemizedlist>

      <para>
       Com os sistemas de arquivo cada vez mais velozes, e usando-se o
       bom senso ao realizar consultas com o <command>find</command>, o
       <command>locate</command> não parece valer tanto a pena assim.  É
       claro que sua impressão sobre isso pode variar.  Dito isto, temos
       o uso básico do <command>locate</command> que é <emphasis>locate
       filename</emphasis>. Por exemplo:
      </para>

      <screen>
$ <userinput>locate locate</userinput>
/usr/bin/locate
/usr/lib/locate
/usr/lib/locate/bigram
/usr/lib/locate/code
/usr/lib/locate/frcode
[...]
      </screen>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-archives">
    <title>Pacotes de Arquivos</title>

    <sect2 xml:id="basics-filesystem-archives-introduction">
      <title>Introdução</title>

      <para>
       Mesmo usuários GNU/Linux mais antigos ou mais novos certamente
       irão encontrar arquivos <acronym>tar</acronym>, tar é o formato
       padrão para empacotamento de arquivos no GNU/Linux.  É
       frequentemente usado juntamente com o <command>gzip</command> ou
       <command>bzip2</command>.  Ambos os comandos podem compactar
       arquivos e diretórios.  <xref linkend="archive-extentions" />
       lista as extensões de empacotamento e compactação mais
       frequentemente usadas, e o que significam.
      </para>

      <table xml:id="archive-extentions">
    <title>Extensões de arquivos</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <thead>
        <row>
          <entry>Extensão</entry>
          <entry>Significado</entry>
        </row>
      </thead>
      <tbody>
        <row>
          <entry>.tar</entry>
          <entry>Um pacote tar sem compactação</entry>
        </row>
        <row>
          <entry>.tar.gz</entry>
          <entry>Um pacote tar compactado com gzip</entry>
        </row>
        <row>
          <entry>.tgz</entry>
          <entry>Um pacote tar compactado com gzip</entry>
        </row>
        <row>
          <entry>.tar.bz2</entry>
          <entry>Um pacote tar compactado com bzip2</entry>
        </row>
        <row>
          <entry>.tbz</entry>
          <entry>Um pacote tar compactado com bzip2</entry>
        </row>
      </tbody>
    </tgroup>
      </table>

      <para>
       A diferença entre o <command>bzip2</command> e o
       <command>gzip</command> é que o <command>bzip2</command> pode
       encontrar informações repetidas em blocos maiores, resultando
       numa compactação melhor.  Mas o <command>bzip2</command> também
       é bem mais lento, pois afinal faz maior análise de dados.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-extracting">
      <title>Descompactando (extraindo) arquivos</title>

      <para>
       No mundo GNU/Linux, como muitos softwares e dados são
       distribuídos com <command>tar</command>, é importante
       acostumar-se a extrair pacotes tar.  Provavelmente a primeira
       coisa que você vai querer fazer quando receber um arquivo tar é
       verificar seu conteúdo.  Isto pode ser feito usando-se o
       parâmetro <parameter class="command">t</parameter>.  No entanto,
       se você apenas executar o <command>tar</command> com este
       parâmetro mais o nome do arquivo, ele irá apenas sentar e
       aguardar até que você informe algo na entrada padrão:
      </para>

      <screen>
$ <userinput>tar t test.tar</userinput>
      </screen>

      <para>
       Isto acontece porque o <command>tar</command> lê os dados a
       partir de sua entrada padrão.  Se você se esqueceu como os
       redirecionamentos funcionam, é uma boa idéia reler <xref
       linkend="chap-shell-inout" />.  Vamos ver o que acontece se nós
       redirecionarmos nossa arquivo tar para o comando tar:
      </para>

      <screen>
$ <userinput>tar t &lt; test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
       Isto é mais parecido com a saída que você provavelmente estava
       esperando.  Este arquivo parece conter um diretório
       <filename>test</filename>, que contém os arquivos
       <filename>test2</filename> e <filename>test2</filename>.  Também
       é possível especificar o nome do arquivo como um parâmetro para
       o <command>tar</command>, com o parâmetro <parameter
       class="command">f</parameter>:
      </para>

      <screen>
$ <userinput>tar tf test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
       Parece ser um pacote que contém arquivos úteis ;).  Vamos avançar
       agora e extrair o conteúdo deste pacote usando o parâmetro
       <parameter class="command">x</parameter>:
      </para>

      <screen>
$ <userinput>tar xf test.tar</userinput>
      </screen>

      <para>
       Agora podemos verificar que o tar realmente extraiu o conteúdo do
       pacote através de uma listagem do diretório com
       <command>ls</command>:
      </para>

      <screen>
$ <userinput>ls test/</userinput>
test1  test2
      </screen>

      <para>
    Extrair ou listar arquivos de um pacote gzipado ou bzipado não é
    muito mais difícil.  Isto pode ser feito adicionando-se um
    <parameter class="command">z</parameter> ou <parameter
    class="command">j</parameter>, respectivamente, para pacotes
    compactados com <command>gzip</command> ou
    <command>bzip2</command>.  Por exemplo, podemos listar o conteúdo de
    um pacote gzipado com:
      </para>

      <screen>
$ <userinput>tar ztf archive2.tar.gz</userinput>
      </screen>

      <para>
       Enquanto que um pacote bzipado pode ser extraído com:
      </para>

      <screen>
$ <userinput>tar jxf archive3.tar.bz2</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-creating">
      <title>Criando pacotes</title>

      <para>
       Você pode empacotar arquivos com o parâmetro <parameter
       class="command">c</parameter>.  Suponha que temos o diretório
       <filename>test</filename> mostrado no exemplo anterior.  Podemos
       criar um pacote com o diretório <filename>test</filename> e os
       arquivos dentro dele com:
      </para>

      <screen>
$ <userinput>tar cf important-files.tar test</userinput>
      </screen>

      <para>
    Isto irá criar o pacote <filename>important-files.tar</filename>
    (que é especificado com o parâmetro <parameter
    class="command">f</parameter>).  Agora nós podemos verificar o
    conteúdo deste arquivo:
      </para>

      <screen>
$ <userinput>tar tf important-files.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
       Criar um pacote compactado com gzip ou bzip2 é análogo a extrair
       arquivos compactados: adicione um <parameter
       class="command">z</parameter> para compactar o arquivo no formato
       gzip ou <parameter class="command">b</parameter> para usar bzip2.
       Suponha queiramos criar uma versão compactada com
       <command>gzip</command> do arquivo criado acima.  Podemos fazer
       isso com:
      </para>

      <screen>
<userinput>tar zcf important-files.tar.gz test</userinput>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-mounting">
    <title>Montando sistemas de arquivos</title>

    <sect2 xml:id="basics-filesystem-mounting-introduction">
      <title>Introdução</title>

      <para>
       Como a maioria dos Unices, o Linux uma técnica chamada de
       <quote>montagem</quote> para acessar sistemas de arquivos.
       Montagem significa que um sistema de arquivos está conectado a
       um diretório no sistema de arquivos raiz.  Alguém poderia, por
       exemplo, montar um drive de CD-ROM no diretório
       <filename>/mnt/cdrom</filename>.  O Linux suporta muitos tipos de
       sistemas de arquivos, como Ext2, Ext3, ReiserFS, JFS, XFS,
       ISO9660 (usado por CD-ROMs), UDF (usado por alguns DVDs) além de
       sistemas de arquivos DOS/Windows, como FAT, FAT32 e NTFS.  Estes
       sistemas de arquivos podem residir em muitos tipos de mídia, como
       por exemplo discos rígidos, CD-ROMs e dispositivos Flash.  Esta
       seção explica como os sistemas de arquivos podem ser montados e
       desmontados.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-mount">
      <title>mount</title>

      <para>
       O <command>mount</command> é usado para montar sistemas de
       arquivos.  A sintaxe básica é: <quote>mount /dev/nome_do_device
       /ponto_para_montagem</quote>.  O dispositivo pode ser qualquer dispositivo
       de bloco, como discos rígidos ou drives de CD-ROM.  O ponto de
       montagem pode ser um ponto qualquer no sistema de arquivos raiz.
       Vamos ver um exemplo:
      </para>

      <screen>
# <userinput>mount /dev/cdrom /mnt/cdrom</userinput>
      </screen>

      <para>
       Isto monta o dispositivo <filename>/dev/cdrom</filename> no ponto
       de montagem <filename>/mnt/cdrom</filename>.  O dispositivo
       <filename>/dev/cdrom</filename> normalmente é um link para o nome
       do dispositivo real do CD-ROM (por exemplo,
       <filename>/dev/hdc</filename>).  Como você pode ver, o conceito
       é, de fato, muito simples, apenas demanda algum tempo para
       aprender os nomes dos dispositivos ;).  Algumas vezes é
       necessário especificar que tipo de sistema de arquivos você está
       tentando montar.  O tipo de sistema de arquivos pode ser
       especificado com o parâmetro
       <parameter class="command">-t</parameter>:
      </para>

      <screen>
# <userinput>mount -t vfat /dev/sda1 /mnt/flash</userinput>
      </screen>

      <para>
       Isto monta o sistema de arquivos vfat de
       <filename>/dev/sda1</filename> em
       <filename>/mnt/flash</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-umount">
      <title>umount</title>

      <para>
       O comando <command>umount</command> é usado para desmontar
       sistemas de arquivos.  <command>umount</command> aceita dois
       tipos de parâmetros, sejam pontos de montagem ou dispositivos.
       Por exemplo:
      </para>

      <screen>
# <userinput>umount /mnt/cdrom</userinput>
# <userinput>umount /dev/sda1</userinput>
      </screen>

      <para>
       O primeiro comando desmonta o sistema de arquivos que estava
       montado em <filename>/mnt/cdrom</filename>, o segundo comando
       desmonta o sistema de arquivos em <filename>/dev/sda1</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-fstab">
      <title>O arquivo fstab</title>

      <para>
       O sistema GNU/Linux possui um arquivo especial, o
       <filename>/etc/fstab</filename>, que especifica quais sistemas de
       arquivos devem ser montados durante a inicialização do sistema.
       Vamos ver um exemplo:
      </para>

      <screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
      </screen>

      <para>
       Como você pode ver, cada linha no arquivo
       <filename>fstab</filename> possui cinco entradas: fs_spec,
       fs_file, fs_vfstype, fs_mntops, fs_freq, e fs_passno.  Agora
       vamos dar uma olhada em cada uma dessas entradas.
      </para>

      <sect3>
    <title>fs_spec</title>

    <para>
      A opção fs_spec option especifica o dispositivo de bloco, ou o
      sistema de arquivos remoto que deve ser montado.  Como você pode
      ver no exemplo, diversas partições de /dev/hda são especificadas,
      bem como o drive de CD-ROM e o drive de disquete.  Quando volumes
      NFS forem montados, um endereço IP e um diretório podem ser
      especificados, por exemplo:
      <filename>192.168.1.10:/exports/data</filename>.
    </para>
      </sect3>

      <sect3>
    <title>fs_file</title>

    <para>
      fs_file especifica o ponto de montagem.  Este pode ser um
      diretório qualquer no sistema de arquivos.
    </para>
      </sect3>

      <sect3>
    <title>fs_vfstype</title>

    <para>
      Este campo especifica que tipo de sistema de arquivos a entrada
      representa.  Por exemplo, este campo pode ser: ext2, ext3,
      reiserfs, xfs, nfs, vfat, ou ntfs.
    </para>
      </sect3>

      <sect3>
    <title>fs_mntops</title>

    <para>
      A opção fs_mntops especifica quais parâmetros devem ser usados na
      montagem do sistema de arquivo.  A página de manual do comando
      <command>mount</command> tem uma extensiva descrição das opções
      disponíveis.  Estas são as opções mais interessantes:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>noauto</emphasis>: os sistemas de arquivos que são
          listados no <filename>/etc/fstab</filename> normalmente são
          montados automaticamente.  Quando a opção
          <quote>noauto</quote> é especificada, o sistema de arquivos
          não será montado durante a inicialização do sistema, mas
          apenas depois de se executar um comando
          <command>mount</command>.  Para montar sistemas de arquivos
          dessa maneira, apenas o ponto de montagem ou o nome do
          dispositivo podem ser especificados, por exemplo:
          <command>mount /mnt/cdrom</command>
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>user</emphasis>: adicionando-se a opção
          <quote>user</quote> irá permitir que usuários normais montem
          o sistema de arquivos (normalmente, apenas o superusuário tem
          permissão para montar sistemas de arquivos).
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>owner</emphasis>: a opção <quote>owner</quote>
          permitirá que o dono do dispositivo especificado monte seu
          referido dispositivo.  Você pode ver o dono de um dispositivo
          usando <command>ls</command>, p.ex.,  <command>ls -l
          /dev/cdrom</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>noexec</emphasis>: com esta opção habilitada, os
          usuários não podem executar os arquivos no sistema de arquivos
          montado.  Isto pode ser usado para oferecer mais segurança.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>nosuid</emphasis>: esta opção é comparável à opção
          <quote>noexec</quote>.  Com
          <quote>nosuid</quote> habilitado, não serão permitidos bits
          SUID no sistema de arquivos montado.  SUID é usado por certos
          binários para deixar que um usuário normal faça algo com
          maiores privilégios.  Isto é certamente uma falha de
          segurança, então esta opção deveria realmente ser usada para
          mídias removíveis e etc.  Uma montagem de usuário normal irá
          forçar a opção nosuid, mas uma montagem feita pelo
          superusuário, não!
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis>unhide</emphasis>: esta opção só é relevante para
          CD-ROMs normais com o sistema de arquivo ISO9660.  Se
          <quote>unhide</quote> for especificado, arquivos ocultos
          também serão visíveis.
        </para>
      </listitem>
    </itemizedlist>
      </sect3>

      <sect3>
    <title>fs_freq</title>

    <para>
      Se <quote>fs_freq</quote> for definido para o valor 1 ou mais
      alto, ele indica depois de quantos dias um despejo
      (dump, backup) será feito.  Esta
      opção só é usada quando o <ulink
      url="http://dump.sourceforge.net/">dump</ulink> está instalado e
      configurado adequadamente para manipular este campo do arquivo.
    </para>
      </sect3>

      <sect3>
    <title>fs_passno</title>

    <para>
      Este campo é usado pelo <command>fsck</command> para determinar a
      ordem na qual os sistema de arquivos são verificados durante a
      inicialização do sistema.
    </para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="basics-filesystem-gnupg">
    <title>Criptografando e assinando arquivos</title>

    <sect2>
      <title>Introdução</title>

      <para>
    Há dois mecanismos de para segurança de arquivos: assinatura digital
    e criptografia.  Assinar um arquivo significa que uma assinatura
    digital especial é gerada para o arquivo.  Você, ou outras pessoas
    podem usar a assinatura para verificar a integridade do arquivo.  Já
    a criptografia codifica o arquivo de tal maneira que apenas a pessoa
    a qual o arquivo se destina seja capaz de lê-lo.
      </para>

      <para>
    Este sistema depende de um par de chaves: uma privada e uma pública.
    Chaves públicas são usadas para criptografar arquivos, e os arquivos
    só podem ser descriptografados com a respectiva chave privada.  Isto
    significa que alguém pode enviar essa chave pública para outras
    pessoas.  Os outros podem usar essa chave para enviar arquivos
    criptografados, que apenas a pessoa com a respectiva chave privada
    possa decodificar.  É claro, isto quer dizer que a segurança desse
    sistema depende do quão a chave privada seja mantida secreta.
      </para>

      <para>
    O Slackware Linux oferece uma excelente ferramenta para assinatura
    e criptografia de arquivos, chamada GnuPG.  O GnuPG pode ser
    instalado a partir do grupo <quote>n</quote> de discos.
      </para>
    </sect2>

    <sect2>
      <title>Gerando suas chaves pública e privada</title>

      <para>
    Gerar as chaves pública e privada é um pouquinho complicado, porque
    o GnuPG usa chaves DSA por padrão.  DSA é um algoritmo de
    criptografia, o problema é que o tamanho máximo do DSA é 1024 bits,
    o que é considerado muito pequeno a longo prazo.  Por isso é uma boa
    idéia usar chaves RSA de 2048 bits.  Esta seção descreve como isso
    pode ser feito.
      </para>

      <note>
    <para>
      Por muito tempo acreditou-se que chaves de 1024 bits eram seguras.
      Mas o artigo de Bernstein's paper <emphasis>Circuits for Integer
      Factorization: a Proposal</emphasis> contestou isto.  A questão é
      que é bastante viável para órgãos nacionais de segurança
      produzirem hardware que podem quebrar chaves desse tamanho em um
      espaço de tempo razoavelmente curto.  Também sabe-se ainda que
      chaves RSA de 512 bits podem ser quebradas relativamente em pouco
      tempo mesmo usando hardware comum.  Mais informações sobre estes
      tópicos podem ser encontradas neste e-mail da lista cypherpunks
      list:
    <ulink url="http://lists.saigon.com/vault/security/encryption/rsa1024.html" />
    </para>
      </note>

      <para>
    Vamos gerar uma chave executando:
      </para>

      <screen>
$ <userinput>gpg --gen-key</userinput>
      </screen>

      <para>
    A primeira pergunta é que tipo de chave você gostaria de gerar.
    Vamos escolher <emphasis>(4) RSA (sign only)</emphasis>:
      </para>

      <screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <userinput>4</userinput>
      </screen>

      <para>
    Você então será perguntado sobre o tamanho da chave que gostaria que
    fosse gerada.  Digite <emphasis>2048</emphasis> para gerar uma chave
    de 2048 bits, e pressione enter para continuar.
      </para>

      <screen>
What keysize do you want? (1024) <userinput>2048</userinput>
      </screen>

      <para>
    A próxima pergunta é simples de responder, apenas escolha a que
    melhor lhe agradar.  Falando de uma forma geral, não é uma má idéia
    fazer com que a chave seja válida indefinidamente.  Você sempre pode
    desativar a chave com um certificado especial de revogação.
      </para>

      <screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
    O GnuPG então irá pedir confirmação.  Depois de confirmar seu nome e
    endereço de e-mail solicitados.  O GnuPG também irá solicitar um
    comentário, que você pode deixar em branco, ou você pode preencher
    com algo como <quote>Trabalho</quote> ou <quote>Pessoal</quote>,
    para indicar para o que usará essa chave.  Por exemplo:
      </para>

      <screen>
Real name: <userinput>John Doe</userinput>
Email address: <userinput>john@doe.com</userinput>
Comment: <userinput>Work</userinput>
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
    O GnuPG irá solicitar que você confirme seu ID de usuário.  Depois
    de confirmá-lo, o GnuPG irá solicitar que entre com uma senha.
    Assegure-se de usar uma boa senha:
      </para>

      <screen>
You need a Passphrase to protect your secret key.

Enter passphrase:
      </screen>

      <para>
    Depois de digitar a senha duas vezes, o GnuPG irá gerar efetivamente
    as chaves.  Mas ainda não terminamos.  O GnuPG gerou apenas uma
    chave para informações de assinatura, e não para criptografia de
    dados.  Para continuar, dê uma olhada na saída, e procure pelo ID
    da chave.  Na informação sobre a chave você irá ver
    <emphasis>pub 2048R/</emphasis>.  O ID da chave é exibido depois
    deste trecho.  Neste exemplo:
      </para>

      <screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
      </screen>

      <para>
    o ID da chave é <emphasis>8D080768</emphasis>.  Se você perdeu a
    saída da geração da chave você ainda pode encontrar o ID da chave na
    saída do comando <command>gpg --list-keys</command>.  Use este ID
    para informar ao GnuPG que você quer editar sua chave:
      </para>

      <screen>
$ <userinput>gpg --edit-key &lt;Key ID&gt;</userinput>
      </screen>

      <para>
    Com a chave de exemplo acima, o comando seria:
      </para>

      <screen>
$ <userinput>gpg --edit-key 8D080768</userinput>
      </screen>

      <para>
    O GnuPG agora irá exibir um prompt de comando.  Execute o comando
    <command>addkey</command> neste prompt:
      </para>

      <screen>
Command&gt; <userinput>addkey</userinput>
      </screen>

      <para>
    O GnuPG agora irá solicitar a senha que você usou para sua chave:
      </para>

      <screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
    Depois que você informar a senha, o GnuPG irá solicitar que tipo de
    chave você gostaria de criar.  Escolha <emphasis>RSA (encrypt
    only)</emphasis>, e preencha a informação como você fez
    anteriormente (certifique-se de usar chaves de 2048 bits).  Por
    exemplo:
      </para>

      <screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <userinput>5</userinput>
What keysize do you want? (1024) <userinput>2048</userinput>
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
    E confirme se a informação estiver correta.  Depois que a chave for
    gerada você pode deixar o prompt de comando do GnuPG e salvar a
    nova chave com o comando <command>save</command>:
      </para>

      <screen>
Command&gt; <userinput>save</userinput>
      </screen>

      <para>
    Parabéns!  Você acabou de gerar as chaves necessárias para
    criptografar e descriptografar e-mails e arquivos.  Você agora pode
    configurar seu cliente de e-mail para usar o GnuPG.  É uma boa idéia
    armazenar o conteúdo do diretório <filename>.gnupg</filename> em
    alguma mídia confiável, e guardá-la em algum lugar seguro!  Se sua
    chave privada for perdida, você não conseguirá descriptografar
    arquivos e mensagens que tiverem sido criptografados com sua chave
    pública.  Se a chave privada, e sua senha forem roubadas, então a
    segurança do sistema está completamente comprometida.
      </para>
    </sect2>

    <sect2>
      <title>Exportando sua chave pública</title>

      <para>
    Para tornar o GnuPG útil, você tem que disponibilizar sua chave
    pública às pessoas que lhe enviam arquivos ou e-mails.  Elas podem
    usar sua chave pública para criptografar arquivos, ou usá-la para
    verificar se um arquivo tem uma assinatura correta ou não.  A chave
    pode ser exportada usando-se o parâmetro
    <parameter class="command">--export</parameter>.  Também é uma boa
    idéia especificar o parâmetro <parameter
    class="command">--output</parameter>, isto irá salvar a chave em um
    arquivo.  O comando a seguir deveria salvar a chave pública de
    <emphasis>John Doe</emphasis><footnote><para>N.T.: John Doe é um nome
    fictício genérico usado na língua inglesa para se referir a alguém
    inespecífico.  Algo mais ou menos equivalente ao nosso
    <quote>João Ninguém</quote>.</para></footnote>, usado nos exemplos
    anteriores, para o arquivo <filename>key.gpg</filename>:
      </para>

      <screen>
$ <userinput>gpg --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
    Isto salva a chave num formato binário.  Quase sempre é mais
    conveniente usar a assim chamada <quote>saída codificada em
    ASCII</quote> (ASCII armored), a qual
    é mais adequada para publicação da chave em e-mails ou websites.
    Você exporta uma versão codificada em ASCII da chave adicionando o
    parâmetro <parameter class="command">--armor</parameter>:
      </para>

      <screen>
$ <userinput>gpg --armor --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
    Se você vir o conteúdo do arquivo <filename>key.gpg</filename> você
    irá notar que a chave codificada em ASCII está num formato muito
    mais confortável.
      </para>
    </sect2>

    <sect2>
      <title>Assinaturas</title>

      <para>
    Com o GPG você pode fazer uma assinatura para um arquivo.  Esta
    assinatura é única, porque sua assinatura só pode ser feita com sua
    chave privada.  Isto quer dizer que outras pessoas podem verificar
    se o arquivo realmente foi enviado por você, ou mesmo se o arquivo
    sofreu alguma alteração ou não.  Arquivos podem ser assinados com o
    parâmetro <parameter class="command">--detach-sign</parameter>.
    Vamos ver um exemplo.  Este comando fará uma assinatura para o
    arquivo <filename>memo.txt</filename>.  A assinatura será armazenada
    em <filename>memo.txt.sig</filename>.
      </para>

      <screen>
$ <userinput>gpg --output memo.txt.sig --detach-sign memo.txt</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
    Como você pode ver, o GnuPG irá pedir que você entre com a senha de
    sua chave privada.  Depois de você ter entrado corretamente com a
    senha, o arquivo de assinatura (<filename>memo.txt.sig</filename>)
    será criado.
      </para>

      <para>
    Você pode verificar um arquivo com sua assinatura usando o parâmetro
    <parameter class="command">--verify</parameter>.  Especifique o
    arquivo de assinatura para o parâmetro <parameter
    class="command">--verify</parameter>.  O arquivo que precisa ser
    verificado pode ser especificado por último:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
    Isto irá confirmar que o arquivo havia sido assinado por
    <emphasis>John Doe (Work) &lt;john@doe.com&gt;</emphasis>, com a
    chave <emphasis>8D080768</emphasis>, e que o arquivo está
    inalterado.  Agora suponha que o arquivo tivesse sofrido alguma
    alteração, o GnuPG deveria apontar isso com bastante estardalhaço:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>
    </sect2>

    <sect2>
      <title>Criptografia</title>

      <para>
    Um dos principais recursos do GnuPG é a criptografia.  Devido seu
    uso de criptografia assimétrica, a pessoa que criptografa um arquivo
    e a pessoa que o descriptografa não precisam compartilhar uma mesma
    chave.  Você pode criptografar um arquivo com a chave pública de
    outra pessoa, e aquela outra pessoa pode descriptografá-lo com sua
    chave privada.  Você pode criptografar arquivos com <parameter
    class="command">--encrypt</parameter>.  Se você não especificar um ID
    de usuário, o GnuPG irá solicitá-lo.  Você pode especificar o ID de
    usuário com o parâmetro <parameter class="command">-r</parameter>.
    No exemplo seguinte, o arquivo <filename>secret.txt</filename> será
    criptografado para outra pessoa chamada <emphasis>John
    Doe</emphasis>:
      </para>

      <screen>
$ <userinput>gpg --encrypt -r "John Doe" secret.txt</userinput>
      </screen>

      <para>
    O ID de usuário está entre aspas duplas para garantir que o ID seja
    interpretado como um único argumento do programa.  Depois que a
    criptografia esteja completada, a versão criptografada do arquivo
    estará disponível como <filename>secret.txt.gpg</filename>.
      </para>

      <para>
    O usuário que receber o arquivo pode descriptografá-lo com o
    parâmetro <parameter class="command">--decrypt</parameter> do
    comando <command>gpg</command>:
      </para>

      <screen>
$ <userinput>gpg --output secret.txt --decrypt secret.txt.gpg</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16 (main key ID EC3ED1AB)

Enter passphrase:

gpg: encrypted with 2048-bit RSA key, ID 8D080768, created 2004-07-16
      "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
    Neste exemplo, o parâmetro <parameter
    class="command">--output</parameter> é usado para armazenar o
    conteúdo descriptografado no arquivo <filename>secret.txt</filename>.
      </para>
    </sect2>
  </sect1>
</chapter>
