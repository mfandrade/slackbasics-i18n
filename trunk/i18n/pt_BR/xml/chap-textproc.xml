<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="en"
  xml:id="chap-textproc">
  <title>Processamento de Texto</title>

  <para>
    A manipulação de texto é algo que é o UNIX faz bem, isso porque
    é parte do coração de sua filosofia, como descrito em
    <xref linkend="chap-intro-unix" />. A maioria dos comandos UNIX
    são programas simples que lêem dados da entrada padrão,
    realizam algumas operações nestes e enviam o resultado para a
    saída padrão. Esses programas agem basicamente como filtros, que
    podem se conectar como um duto. Isso permite que o usuário
    empregue as ferramentas UNIX de modo que seus criadores
    nunca tenham vislumbrado. Nos capítulos seguintes veremos como
    você pode construir filtros simples para si mesmo.
    <!-- XXX - xref -->
  </para>

  <para>
    Este capítulo descreve alguns comandos UNIX simples, mas
    importantes, que podem ser utilizados para a manipulação de texto.
    Depois disso, veremos as expressões regulares, uma sub-linguagem
    que pode ser utilizada para encontrar padrões de correspondência
    em textos.
  </para>

  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulação simples de texto</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Repetindo o que foi dito</title>

      <para>
    O filtro de texto mais simples é o <command>cat</command>, ele
    não faz mais que enviar os dados da stdin para a stdout:
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
    Outra característica útil, é que você pode fazer com que ele
    envie o conteúdo de um arquivo para a saída padrão:
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
    <command>cat</command> faz o que seu nome diz quando múltiplos
    arquivos são adicionados como seus argumentos. Ele concatena os
    arquivos, no sentido de enviar o conteúdo de todos os arquivos
    para a saída padrão, na mesma ordem em que foram especificados
    como argumento. O seguinte trecho de tela demonstra isso:
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Estatísticas de texto</title>

      <para>
    O comando <command>wc</command> provê estatísticas sobre um
    arquivo texto ou uma stream de texto. Sem parâmetros, irá imprimir
    o número de linhas, o número de palavras e o número de bytes
    respectivamente. Uma palavra é delimitada por um caractere de
    espaço em branco ou uma sequência de caracteres em branco.
      </para>

      <para>
    O seguinte exemplo mostra o número de linhas, palavras e bytes no
    exemplo canônico <quote>Hello world!</quote>:
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput>
       1       2      13
      </screen>

      <para>
    Se quiser imprimir somente um desses componentes, você pode usar
    um dos parâmetros <parameter class="command">-l</parameter>
    (linhas), <parameter class="command">-w</parameter> (palavras) ou
    <parameter class="command">-c</parameter> (bytes).
    Por enquanto, adicionando somente o parâmetro <parameter
    class="command">-l</parameter> mostrará o número de linhas de um
    arquivo:
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command>
  235882 /usr/share/dict/words
      </screen>

      <para>
    Ou você pode imprimir campos adicionais adicionando o parâmetro:
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
    Note que, não importa a ordem em que as opções foram
    especificadas, a ordem de saída será sempre a mesma (linhas,
    palavras, bytes).
      </para>

      <para>
    O parâmetro <parameter class="command">-c</parameter> imprime o
    número de bytes, esse parâmetro pode não representar o número de
    caracteres que um texto possui, porque o conjunto de caracteres
    em uso pode ser de comprimento maior que um byte. Finalmente, o
    parâmetro <parameter class="command">-m</parameter> foi adicionado
    e imprime o número de caracteres no texto, independentemente do
    conjunto de caracteres. Os parâmetros <parameter
    class="command">-c</parameter> e <parameter class="command">-m
    </parameter> são substitutos e podem nunca serem utilizados ao
    mesmo tempo.
      </para>

      <para>
    As estatísticas que <command>wc</command> provê são mais úteis
    que podem aparentar. Por exemplo, o parâmetro <parameter
    class="command">-l</parameter> é utilizado geralmente em
    contagens da saída de um comando. Isso é conveniente, pois muitos
    comandos separam unidades lógicas por novas linhas. Suponha que
    você queira contar o número de arquivos em seu diretório home
    que possuam seu nome terminado com <filename>.txt</filename>.
    Você poderia fazer isso combinando <command>find</command> para
    encontrar arquivos relevantes e <command>wc</command> para contar
    o número de ocorrências:
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Manipulando caracteres</title>

      <para>
	O comando <command>tr</command> pode ser utilizado para operações
    comuns a caracteres, como troca de caracteres, remoção de
    caracteres e misturando sequências de caracteres. Dependendo da
    operação, um ou mais conjuntos de caracteres podem ser
    especificados. Com exceção dos caracteres normais, existem algumas
    sequências de caracteres especiais que podem ser utilizadas:
      </para>

      <variablelist>
	<varlistentry>
	  <term>\caractere</term>
	  <listitem>
	    <para>
          Essa notação é utilizada para especificar caracteres que
          precisam ser escapados, mais notavelmente <emphasis>\n
          </emphasis> (nova linha), <emphasis>\t</emphasis>
          (tabulação horizontal), e <emphasis>\\</emphasis> (barra
          invertida).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>character1-character2</term>
	  <listitem>
	    <para>
	      Insere implicitamente todos os caracteres de
	      <emphasis>character1</emphasis> até
	      <emphasis>character2</emphasis>. Essa notação deve ser usada
	      com cuidado, pois nem sempre gera o resultado esperado. Por
          exemplo, a sequência <emphasis>a-d</emphasis> pode
          substituir <emphasis>abcd</emphasis> pela localidade POSIX
          (configurações de linguagem), mas isso pode não ser verdade
          para outras localidades.
	      <!-- XXX - notas de cabeçalho sobre localidade -->
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:class:]</term>
	  <listitem>
	    <para>
	      Acerta uma classe de caracteres pré-definidos. Todas as
          possíveis classes são mostradas em <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*]</term>
	  <listitem>
	    <para>
	      Repete o <emphasis>character</emphasis> até que o segundo
          conjunto seja tão longo quanto o primeiro conjunto de
          caracteres.  Esta notação só pode ser usada no segundo
          conjunto.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*n]</term>
	  <listitem>
	    <para>
	      Repete o <emphasis>character</emphasis> 
	      <emphasis>n</emphasis> vezes.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>Classes de caracteres do tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Classe</entry><entry>Significado</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Todas as letras e números.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Letras.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Espaços horizontais (p.ex., espaços em branco e
          tabulações).</entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Caracteres de controle.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Todos os dígitos (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Todos os caracteres imprimíveis, exceto os espaços em
          branco.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Letras minúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Todos os caracteres imprimíveis, incluindo espaços em
          branco, mas excluindo espaços verticais.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Caracteres de pontuação.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
          <entry>Todos os caracteres de espaço.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Letras maiúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Dígitos hexadecimais (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Trocando caracteres</title>

    <para>
      A operação padrão do <command>tr</command> é trocar
      (traduzir) caracteres.  Isso quer dizer que o
      <emphasis>n</emphasis>-ésimo caractere no primeiro conjunto é
      substituído pelo <emphasis>n</emphasis>-ésimo caractere no segundo
      conjunto.  Por exemplo, você pode substituir todos os 
	  <emphasis>e</emphasis>'s por <emphasis>i</emphasis>'s e todos os
	  <emphasis>o</emphasis>'s por <emphasis>a</emphasis>'s com uma
      execução do <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
      Quando o segundo conjunto for menor que o primeiro, o último
      caractere no segundo conjunto será considerado repetido.  Porém,
      isto não é necessariamente aplicável a outros sistemas UNIX.
      Assim, se você quiser usar o <command>tr</command> de uma forma
      independente de sistema, defina explicitamente que caractere deve
      ser repetido.  Por exemplo
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
      Outra peculiaridade é o uso da sintaxe de repetição no meio do
      conjunto.  Suponha que o conjunto 1 seja 
	  <emphasis>abcdef</emphasis>, e que o conjunto 2 seja
	  <emphasis>@[-*]!</emphasis>.  O <command>tr</command> irá
      substituir o <emphasis>a</emphasis> por <emphasis>@</emphasis>,
	  <emphasis>b</emphasis>, <emphasis>c</emphasis>,
	  <emphasis>d</emphasis>, e <emphasis>e</emphasis> por
	  <emphasis>-</emphasis>, <emphasis>f</emphasis> e
	  <emphasis>!</emphasis>.
      Alguns outros sistemas UNIX seguiria substituindo 
      <emphasis>a</emphasis> por <emphasis>@</emphasis>, e os demais
      caracteres do conjunto por <emphasis>-</emphasis>.  Então, uma
      notação mais correta deveria ser <emphasis>@[-*4]!</emphasis>, que
      é mais explícita e tem o mesmo resultado virtualmente em todos os
      sistemas UNIX:
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Espremendo sequências de caracteres</title>

	<para>
      Quando o parâmetro <parameter class="command">-s</parameter> é
      usado, o <command>tr</command> irá espremer todos os caracteres
      que estão no segundo conjunto.  Isto quer dizer que uma sequência
      de mesmos caracteres será reduzida a um caractere.  Vamos espremer
      o caractere &quot;<emphasis>e</emphasis>&quot;:
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
      Vamos combinar isto com a substituição para mostrar um exemplo
      útil do <command>tr</command> em ação.  Suponha que queiramos
      marcar todas as vogais com o símbolo de
      <emphasis>arroba</emphasis> (<emphasis>@</emphasis>), com vogais
      consecutivas representadas por um <emphasis>at</emphasis>.  Isto
      pode ser feito canalizando-se dois comandos <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Excluindo caracteres</title>

	<para>
      Finalmente, o <command>tr</command> pode ser usado para excluir
      caracteres.  Se o parâmetro <parameter
      class="command">-d</parameter> for usado, todos os caracteres do
      primeiro conjunto são removidos:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Recortando e colando colunas de texto</title>

      <para>
        O comando <command>cut</command> está disponível em sistemas
        UNIX a partir de um arquivo ou de um fluxo de caracteres,
        imprimindo-o para a saída padrão.  Frequentemente é útil obter
        seletivamente alguma informação de um texto.  O
        <command>cut</command> possui três opções para recortar
        informação de arquivos:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Byte a byte.
	  </para>
	</listitem>
	<listitem>
	  <para>
        Por caractere, o que não é o mesmo que o recorte por byte em
        sistemas que utilizem uma codificação de caracteres maior que
        oito bits.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Por campo, que é delimitado por um caractere.
	  </para>
	</listitem>
      </orderedlist>

      <para>
        Em todas essas três abordagens, você pode especificar o elemento
        escolhido a partir de seu número começando em
        <emphasis>1</emphasis> ou especificar um intervalo usando um
        hífen (<emphasis>-</emphasis>).  Dessa forma,
        <emphasis>M-N</emphasis> se refere ao intervalo do M-ésimo ao
        N-ésimo elemento.  Se deixarmos M de fora,
        (<emphasis>-N</emphasis>) seleciona todos os elementos desde o
        primeiro até o N-ésimo elemento.  Deixar N de fora
        (<emphasis>M-</emphasis>) vai selecionar do M-ésimo até o último
        elemento.  Múltiplos elementos ou intervalos de elementos podem
        ser combinados se separados por vírgulas
        (<emphasis>,</emphasis>).  Assim, por exemplo,
        <emphasis>1,3-</emphasis> seleciona o primeiro elemento além dos
        que estiverem entre o terceiro e o último elemento.
      </para>

      <para>
        Os dados podem ser recortados por campo usando-se o parâmetro
        <parameter class="command">-f campos</parameter>.  Por padrão,
        uma tabulação horizontal é usada como separador.  Vamos dar uma
        olhada no comando <command>cut</command> em ação em um pequeno
        dicionário alemão-inglês:
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
        Podemos obter todas as palavras em inglês selecionando o
        segundo campo:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
        Isso foi bem fácil.  Agora vamos fazer a mesma coisa com um
        arquivo que usa o caractere de dois-pontos como separados.
        Podemos facilmente tentar isso convertendo o dicionário com o
        próprio <command>tr</command> que já vimos para substituir todas
        as tabulações por dois-pontos:
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
        Agora se usarmos o mesmo comando do exemplo anterior não teremos
        uma saída correta:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
        O que aconteceu aqui é que o delimitador não pôde ser
        encontrado.  Se uma linha não contiver o delimitador que está
        sendo usado, o comportamento padrão do <command>cut</command> é
        exibir a linha completa.  Você pode evitar isso com o parâmetro 
        <parameter class="command">-s</parameter>.
      </para>

      <para>
        Para usar um delimitador diferente da tabulação horizontal
        padrão, inclua o parâmetro <parameter class="command">-d
        caractere_delimitador</parameter> para definir o caractere
        delimitador.  Então, no caso do nosso arquivo 
        <filename>dictionary-new</filename>, vamos fazer o
        <command>cut</command> usar o dois-pontos como um delimitador:
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
        Se um campo que foi especificado não existir na linha, tal campo
        em particular não é exibido.
      </para>

      <para>
        As opções <parameter class="command">-b bytes</parameter> e
        <parameter class="command">-c caracteres</parameter>
        selecionam, respectivamente, bytes e caracteres a partir do
        texto.  Em sistemas mais antigos, um caractere costuma
        corresponder a um byte.  Mas novos sistemas podem dispor de
        codificações de caracteres que sejam maiores que apenas um byte.
        Assim, se você quiser se assegurar de obter caracteres
        completos, use sempre o parâmetro <parameter
        class="command">-c</parameter>.  Um exemplo divertido para
        vermos o parâmetro <parameter class="command">-c</parameter> em
        ação consiste em procurarmos os dez conjuntos mais comuns para
        os três primeiros caracteres de uma palavras.  A maioria dos
        sistemas UNIX possui uma lista de palavras que são separadas por
        caracteres de nova linha.  Podemos usar o comando
        <command>cut</command> para obter os primeiros três caracteres
        das palavras da lista, adicionar o comando <parameter
        class="command">uniq</parameter> <!-- XXX a where? --> para
        contar sequências idênticas de três caracteres, e usar o comando         
        <command>sort</command> para ordená-las numericamente em ordem
        decrescente (o <command>sort</command> é descrito em <xref
        linkend="chap-textproc-simple-sort" />).  Por fim, vamos usar o
        comando <command>head</command> para filtrar as dez sequências
        mais comuns:
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
        Agora que vimos essa simples e poderosa utilização de comandos
        do UNIX em ação, vamos ver agora o comando
        <command>paste</command>, o qual combina arquivos em colunas em
        um único fluxo de texto.
      </para>

      <para>
        O uso do <command>paste</command> é muito simples, ele irá
        combinar todos os arquivos dados como um argumento, separados
        por uma tabulação.  Com a lista de palavras em inglês e em
        alemão, podemos gerar um dicionário simples:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
        Você também pode combinar mais de dois arquivos:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput>
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
        Se um dos arquivos for mais longo, a ordem das colunas é
        mantida, e espaços vazios são usados para preencher as entradas
        correspondentes que faltarem nos arquivos menores.
      </para>

      <para>
        Você pode usar outro delimitador incluindo o parâmetro
        <parameter class="command">-d delimitador</parameter>.  Por
        exemplo, se quisermos que nosso dicionário tenha palavras
        separadas por dois-pontos:
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
        Normalmente o <command>paste</command> combina arquivos em
        diferentes colunas.  Você também pode fazer o
        <command>paste</command> usar as linhas de cada arquivo como
        colunas, e deixar as colunas de cada arquivo em linhas
        separadas.  Isto é feito com o parâmetro <parameter
        class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Ordenando texto</title>

      <para>
        O UNIX oferece o comando <command>sort</command> para ordenação
        de texto.  O <command>sort</command> também pode verificar se
        um arquivo já está ordenado, e também mesclar dois arquivos
        ordenados.  O <command>sort</command> também pode fazer tanto
        ordenação léxica (ordem do dicionário) quanto numérica.  A
        ordem padrão é a ordem do dicionário.  Isso quer dizer que as
        linhas de texto são comparadas caractere a caractere, e ordenadas
        como especificado pela sequência collate da localização atual
        (que é definida pela variável de ambiente LC_COLLATE).  Isto
        pode ser uma pegadinha quando você estiver ordenando números,
        por exemplo, se você tem os números de 1 a 10 em diferentes
        linhas, a sequência será 1, 10, 2, 3, etc.  Isto se deve a
        interpretação por caractere da ordem de dicionário.  Se você
        quiser ordenar as linhas pela numeração, utilize a ordenação
        numérica.
      </para>

      <para>
        Se nenhum parâmetro adicional for especificado, o
        <command>sort</command> ordena as linhas de entrada na ordem do
        dicionário.  Por exemplo:
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
        Como você pode ver, a entrada é ordenada corretamente.  Algumas
        vezes pode haver linhas idênticas.  Você pode mesclar linhas
        idênticas adicionando o parâmetro
        <parameter class="command">-u</parameter>.  Os dois exemplos
        listados abaixo ilustram isso.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
        Há alguns parâmetros adicionais que podem ser úteis para
        modificar um pouco o resultado:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
        O parâmetro <parameter class="command">-f</parameter> faz com
        que a ordenação seja insensível a maiúsculas e minúsculas.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Se <parameter class="command">-d</parameter> for adicionado,
	    apenas caracteres em branco e alfanuméricos são usados para
	    determinar a ordem.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    O parâmetro <parameter class="command">-i</parameter> faz com
	    que o <command>sort</command> ignore caracteres não imprimíveis.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
        Você pode ordenar arquivos numericamente adicionando o parâmetro
        <parameter class="command">-n</parameter>.  Este parâmetro pára
        de ler a entrada quando um caractere não numérico for encontrado.
        O sinal de menos, ponto decimal, separador de milhar, caractere
        de base (que diferente um número exponencial de um número
        normal), e espaços em branco podem ser usados como partes de um
        número.  Esses caracteres são interpretados adequadamente.
      </para>

      <para>
        O exemplo a seguir mostra a ordenação numérica em ação,
        canalizando a saída de um comando <command>du</command> para o
        <command>sort</command>.  Isso funciona porque o 
        <command>du</command> especifica o tamanho de cada arquivo como
        o primeiro campo.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
        Neste caso, a saída provavelmente não é muito útil se você
        quiser ler a saída em um paginador, porque os arquivos menores
        são listados primeiro.  É aí que entra o parâmetro <parameter
        class="command">-r</parameter>.  Isso reverte a ordem de
        ordenação.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
        O parâmetro <parameter class="command">-r</parameter> também
        funciona com a ordenação léxica.
      </para>

      <para>
        Frequentemente, os arquivos utilizam estrutura de múltiplas
        comuns, e você pode querer ordenar um arquivo por uma outra
        coluna que não a primeira.  Por exemplo, considere o seguinte
        arquivo de pontuação chamado <filename>score.txt</filename>:
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>

    <para>
      Suponha que queiramos ordenar as entradas deste arquivo pelo campo
      de duas letras do país.  O <command>sort</command> nos permite 
      ordenar um arquivo por uma coluna com o parâmetro <parameter
      class="command">-k col1[,col2]</parameter>.  Sendo que as colunas
      de <emphasis>col1</emphasis> a <emphasis>col2</emphasis> são
      usadas como campos para ordenação da entrada.  Se 
      <emphasis>col2</emphasis> não for especificada, todos os campos
      até o final da linha são considerados.  Assim, se você quiser usar
      apenas uma coluna, utilize
      <parameter class="command">-k col1,col1</parameter>.  Você também
      pode especificar o caractere inicial de uma coluna adicionando um
      ponto (<emphasis>.</emphasis>) e um caractere de índice.  Por
      exemplo, <parameter class="command">-k 2.3,4.2</parameter>
      se refere à segunda coluna começando no terceiro caractere, a
      terceira coluna e a quarta coluna até (e incluindo) o segundo
      caractere.
    </para>

    <!-- XXX - document -b? Mentioned lateron (-k) -->

    <para>
      Ainda há uma outra peculiaridade sobre ordenação de colunas: por
      padrão, o <command>sort</command> usa um caractere em branco como
      separador de colunas.  Se você usar um caractere separador
      distinto, você tem que usar o parâmetro <parameter>-t
      char</parameter> para especificar o separador de campos.
    </para>

    <para>
      Combinando os parâmetros <parameter class="command">-t</parameter>
      e <parameter class="command">-k</parameter>, podemos ordenar o
      arquivo de pontuação pelo código do país:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Então, como podemos ordenar o arquivo pela pontuação em si?  
      Obviamente, podemos indicar para que o sort use a terceira coluna.
      Mas o sorte usa um dicionário de ordenação por
      padrão<footnote><para>É claro, isso realmente não faz diferença
      neste caso, pois não usamos números maiores que 9, e virtualmente
      todos os conjuntos de caracteres representam números em ordem
      numérica).</para></footnote>.  Você poderia usar o <parameter
      class="command">-n</parameter>, mas o <command>sort</command> 
      também permite uma abordagem mais sofisticada.  Você pode incluir
      <emphasis>n</emphasis>, <emphasis>r</emphasis>,
      <emphasis>f</emphasis>, <emphasis>d</emphasis>,
      <emphasis>i</emphasis>, ou <emphasis>b</emphasis> como
      especificador de coluna.  Essas letras representam parâmetros do
      <command>sort</command> com mesmo nome.  Se você adicionar apenas
      a coluna inicial, inclua-o àquela coluna, ou então, adicione-o à
      coluna final.
    </para>

    <para>
      O comando a seguir ordena o arquivo pela pontuação:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      É uma boa seguir esta abordagem, ao invés de usar as variantes de
      parâmetros, pois o <command>sort</command> permite que você use
      mais parâmetros que o <parameter class="command">-k</parameter>.
      E, adicionando essas opções à especificação de coluna também vai
      lhe permitir fazer ordenação por diferentes colunas de diferentes
      maneiras.  Por exemplo, usar o <command>sort</command> com os
      parâmetros <parameter class="command">-k 3,3n -k 2,2</parameter> 
      irá ordenar todas as linhas numericamente a partir da terceira
      coluna.  Se algumas linhas tiverem números idênticos nessa coluna,
      a ordenação dessas linhas será feita lexicalmente a partir da 
      segunda coluna.
    </para>

    <para>
      Se você quiser apenas verificar se um arquivo já está ordenado, 
      você pode usar o parâmetro
      <parameter class="command">-c</parameter>.  Se o arquivo já
      estiver ordenado, o sort retornará o valor <emphasis>0</emphasis>, 
      e caso contrário, <emphasis>1</emphasis>.  Podemos conferir isso
      exibindo a variável <emphasis>?</emphasis>, que armazena o valor
      de retorno do último comando executado.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      O segundo comando mostra que funciona, canalizando a saída da
      ordenação do arquivo <filename>scores.txt</filename> para o
      <command>sort</command>.
    </para>

    <para>
      Finalmente, você pode mesclar dois arquivos ordenados com o
      parâmetro <parameter class="command">-m</parameter>, mantendo a
      ordem correta.  Isso é mais rápido que concatenar dois arquivos
      e reordená-los.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Diferenças entre arquivos</title>

      <para>
	Como fluxos e arquivos de texto são algo muito importante no UNIX, é
	bastante útil poder mostrar as diferenças entre dois arquivos de texto.  
	Os principais utilitários para se trabalhar com diferenças em arquivos
	são o <command>diff</command> e o <command>patch</command>.  O comando
	<command>diff</command> mostra as diferenças entre arquivos.  A saída do
	<command>diff</command> pode ser processada pelo 
	<command>patch</command> para se aplicar as diferenças entre os dois 
	arquivos de entrada para um arquivo.  Essas diferenças entre arquivos
	(<quote>diffs</quote>) também são a base para sistemas de gerenciamento
	e controle de versão. <!-- XXX - xref to version management chapters -->
	As seções seguintes descrevem os comandos <command>diff</command> e <command>patch</command>.  Para ter algum material com o qual trabalhar,
	os dois seguintes arquivos fontes em C são usados para demonstrar esses
	comandos.  Estes arquivos são chamados <filename>hello.c</filename> ane
	<filename>hello2.c</filename>, respectivamente.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Listando as diferenças entre arquivos</title>

	<para>
	  Suponha que você tenha recebido o programa
	  <filename>hello.c</filename> de um amigo, e que você o tenha
	  modificado para informar ao usuário a data e hora atuais.  Você
	  poderia apenas enviar o programa atualizado de volta para seu amigo.
	  Mas se um arquivo crescer muito, isso pode se tornar inconveniente, 
	  pois as mudanças ficam mais difíceis de se gerenciar.  Além disso, seu
	  amigo pode também ter recebido versões modificadas do programa de
	  outras pessoas.  Estas é uma situação típica em que o 
	  <command>diff</command> se torna útil.  O <command>diff</command>
	  mostra as diferenças entre dois arquivos.  Sua sintaxe mais básica é
	  <command>diff file file2</command>, que mostra as diferenças entre os
	  arquivos <filename>file</filename> e <filename>file2</filename>.  
	  Vamos tentar isto com nossos arquivos fontes:
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  As adições de <filename>hello2.c</filename> são visíveis nesta
	  saída, mas o formato pode lhe ser um pouco estranho.  Atualmente, 
	  estes são comandos que podem ser interpretados pelo editor de linha
	  de comando, <command>ed</command>.  Vamos ver um formato de saída
	  mais confortável depois de examinar o básico do formato de saída
	  padrão.
	</para>

	<para>
	  Dois elementos distintos podem ser destacados nesta saída:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      Este é um comando do <application>ed</application> que é
	      especificado que especifica que o texto deve ser anexado 
	      (<literal>a</literal>) depois da linha <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      Este é o texto atual a ser anexado depois da segunda linha.  O 
	      sinal <quote><emphasis>&gt;</emphasis></quote> é usado para marcar
	      as linhas a serem adicionadas.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Os mesmos elementos são usados para adicionar o segundo bloco de
	  texto.  Mas e sobre as linhas que são removidas?  Podemos facilmente
	  ver como elas são representadas trocando os dois parâmetros do comando
	  <command>diff</command>, mostrando as diferenças entre 
	  <filename>hello2.c</filename> e
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Os seguintes elementos podem ser destacados:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      Este é o comando de exclusão do <application>ed</application>
	      (<literal>d</literal>), indicando que a linha 2 deveria ser
	      excluída.  O segundo comando de exclusão utiliza um intervalo 
	      (da linha 14 à linha 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      O texto que está para ser removido é precedido por um sinal de 
	      <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>

	<!-- XXX - Changed lines? -->

	<para>
	  Isso é o suficiente para a saída no estilo do comando 
	  <application>ed</application>.  O programa GNU diff incluído no
	  Slackware Linux suporta os, assim chamados, diffs unificados.  Diffs
	  unificados são bastante legíveis, e provêem um contexto por padrão. 
	  O <command>diff</command> pode gerar saída no padrão de diff unificado
	  com a opção <parameter class="command">-u</parameter>:
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Os seguintes elementos podem ser encontrados na saída:
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      O nome do arquivo original, e o registro de tempo do horário da
	      última modificação.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      O nome do arquivo modificado, e o registro de tempo do horário da
	      última modificação.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Este par de números mostra a localização e o tamanho do trecho 
	      cujo texto abaixo foi afetado no arquivo original e no arquivo
	      modificada.  Assim, neste caso os números significam que o trecho
	      modificado começa na linha 1, e tem o tamanho de quatro linhas.
	      No arquivo modificado, o trecho respectivo começa na linha 1, e 
	      tem o tamanho de cinco linhas.  Trechos diferentes na saída do
	      diff começam com este cabeçalho.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Uma linha que não inicie por um sinal de menos 
	      (<emphasis>-</emphasis>) ou por um sinal de mais
	      (<emphasis>+</emphasis>) foi mantida intacta.  Linhas que não
	      foram modificadas são incluídas para dar alguma informação
	      contextual, e para evitar a listagem de muitos trechos
	      modificados em sequência.  Se houver algumas poucas linhas
	      intactas entre as modificações, o <command>diff</command> irá
	      considerar apenas um único trecho, ao invés de dois trechos.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Uma linha indicada por um sinal de mais 
	      (<emphasis>+</emphasis>) é uma adição ao arquivo modificado, em
	      relação ao arquivo original.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Tal como fizemos com o formato no estilo do editor ed, podemos ver
	  algumas exclusões trocando os nomes dos arquivos:
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Como você vê nesta saída, as linhas que são excluídas do arquivo
	  modificado em relação ao arquivo original são iniciadas com um sinal
	  de menos (<emphasis>-</emphasis>).
	</para>

	<para>
	  Quando você estiver trabalhando com conjuntos maiores de arquivos, 
	  quase sempre é útil comparar diretórios inteiros.  Como exemplo, se
	  você tem uma versão original dos fontes de um programa em um diretório
	  chamado <filename>hello.orig</filename>, e uma versão modificada do
	  mesmo em um diretório chamado <filename>hello</filename>, você pode
	  usar o parâmetro <parameter class="command">-r</parameter> para fazer
	  uma comparação recursiva de ambos os diretórios.  Por exemplo:
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  Deve-se notar que isto irá comparar apenas os arquivos que estiverem
	  presentes em ambos os diretórios.  A versão GNU do diff, que é a 
	  utilizada pelo Slackware Linux, dispõe do parâmetro 
	  <parameter class="command">-N</parameter>.  Este parâmetro trata
	  arquivos que existem em apenas um dos diretórios como se estivessem
	  vazios no outro.  Assim, no caso, se adicionarmos um arquivo chamado
	  <filename>Makefile</filename> ao diretório <filename>hello</filename>,
	  usar o parâmetro <parameter class="command">-N</parameter> nos daria a
	  seguinte saída:
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Como você pode ver, o indicador de trechos diz que o trecho no arquivo
	  original inicia na linha 0 e tem um tamanho de 0 linhas.
	</para>

	<para>
	  Usuários de UNIX quase sempre utilizam a saída do comando 
	  <command>diff</command>, chamados de <quote>diffs</quote> ou de 
	  <quote>patches</quote>.  A próxima seção irá lhe mostrar como você
	  pode manipular esses arquivos de diffs.  Mas agora você mesmo já é
	  capaz de criar tais arquivos, redirecionando a saída do comando diff
	  para um arquivo.  Por exemplo:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Se você tiver múltiplos diffs, você pode combiná-los facilmente para
	  apenas um diff, concatenando-os:
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Mas, assegure-se de que os arquivos tenham sido criados a partir do
	  mesmo diretório se você quiser usar o utilitário
	  <command>patch</command>, abordado na próxima seção.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Modifying files with diff output</title>

	<para>
	  Suponha que alguém lhe envie a saída de um <command>diff</command>
	  para um arquivo que você tenha criado.  Seria tedioso tentar
	  incorporar manualmente todas as modificações que foram feitas.  
	  Felizmente, o comando <command>patch</command> pode fazer isso para
	  você.  O <command>patch</command> aceita diffs na entrada padrão, e
	  tentará aplicar as modificações no arquivo original, tal como
	  registradas no arquivo diff.  Então, por exemplo, se temos o arquivo
	  <filename>hello.c</filename>, e o patch que geramos com as
	  modificações que fizemos anteriormente baseadas nas modificações entre
	  nossos arquivos <filename>hello.c</filename> e
	  <filename>hello2.c</filename>, podemos aplicar as modificações ao 
	  <filename>hello.c</filename> para que este fique igual à sua
	  contraparte:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  If you have <filename>hello2.c</filename>, you can check
	  whether the files are identical now:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  Não há nenhuma saída, mas é assim mesmo.  Uma das melhores coisas
	  sobre o <command>patch</command> é que ele pode reverter as alterações
	  feitas a partir de um diff, usando o parâmetro <parameter
	  class="command">-R</parameter>:
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  Nestes exemplos, alterações são aplicadas ao arquivo original.  
	  Algumas vezes, você pode querer aplicar o patch a um arquivo com um
	  nome diferente.  Você pode fazer isso informando o nome de um arquivo
	  como último argumento:
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  Você também pode usar o comando <command>patch</command> com diffs que
	  tiverem sido gerados com o parâmetro <parameter
	  class="command">-r</parameter>, mas você precisa ter um pouco de
	  cuidado.  Suponha que o cabeçalho de um dado arquivo no diff seja o
	  seguinte:
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Se você processar este diff com o <command>patch</command>, ele
	  tentará modificar o arquivo <filename>hello.c</filename>.  Assim, o
	  diretório que contém este arquivo precisa ser o diretório atual.  Você
	  pode usar o caminho completo com o parâmetro <parameter
	  class="command">-p n</parameter>, sendo <emphasis>n</emphasis> o
	  número de componentes do caminho que devem ser considerados.
	  <!-- is the number of pathname components that should be stripped -->
	  Um valor <emphasis>0</emphasis> implicará no uso do caminho como
	  especificado pelo arquivo do patch, um valor <emphasis>1</emphasis>
	  vai considerar o primeiro componente do caminho, e etc.  Neste
	  exemplo, considerar o primeiro componente irá resultar na execução de
	  um patch em <filename>hello.c</filename>.  De acordo com a versão 3 do 
	  padrão Single UNIX Specification, um caminho que for precedido por
	  <emphasis>---</emphasis> deveria ser usado para construir o arquivo
	  no qual o patch deveria ser aplicado.  A versão GNU do comando patch
	  não segue este padrão aqui.  Então, é melhor é considerar sempre um
	  ponto onde ambos os nomes de diretórios forem iguais (normalmente o 
	  diretório pai da árvore que está sendo modificada).  Na maioria dos 
	  casos em que caminhos relativos são usados, isto pode ser feito 
	  especificando-se <emphasis>-p 1</emphasis>.  Por exemplo:
	</para>

	<!-- XXX - add more examples for -p n -->

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  Ou, você pode usar o parâmetro <parameter
	  class="command">-d</parameter> para especificar em qual diretório as
	  modificações devem ser aplicadas:
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Se você quiser manter um backup ao aplicar as modificações a um
	  arquivo, você pode usar o parâmetro <parameter class="command">-b</parameter> do comando <command>patch</command>.  
	  Isto irá fazer uma cópia de segurança de cada arquivo afetado chamada
	  <filename>filename.orig</filename>, antes de efetivamente modificar o
	  arquivo:
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Algumas vezes, modificações não podem ser aplicadas a arquivos.  Por
	  exemplo, se o arquivo já tiver sofrido um patch, se as modificações
	  realizadas foram tantas a ponto de dificultar uma clara criação de um
	  patch, ou se o arquivo meramente não existir.  Nesses casos, os
	  trechos que não puderem ser salvos são armazenados em um arquivo
	  chamado <filename>filename.rej</filename>, sendo 
	  <emphasis>filename</emphasis> o nome do arquivo de 
	  <command>patch</command> que se tentou aplicar.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Expressões regulares</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Introdução</title>

      <para>Nos dias de hoje, frequentemente você pode querer manipular textos
      que casem com um determinado padrão, ao invés de com uma string literal.
      Muitos utilitários UNIX implementam uma linguagem para tratamento de 
      padrões de texto, as <emphasis>regular expressions</emphasis> (regexps). 
      Ao longo do tempo, expressões regulares se desenvolveram, sendo que hoje 
      existem basicamente três sintaxes para expressões regulares:</para>

      <itemizedlist>
        <listitem>
          <para>Expressões regulares tradicionais tipo UNIX.</para>
        </listitem>
        <listitem>
          <para>Expressões regulares estendidas do padrão POSIX. </para>
        </listitem>
        <listitem>
          <para>Expressões regulares compatíveis com Perl (do inglês,
          <foreignphrase>Perl-compatible regular expressions</foreignphrase>, ou
	  (PCRE).</para>
        </listitem>
      </itemizedlist>

      <para>
	Expressões regulares no padrão POSIX são praticamente um superconjunto
	das expressões tradicionais tipo UNIX, e as PCREs são um superconjunto
	das expressões regulares POSIX.  A sintaxe a que um dado aplicativo vai 
	dar suporte em geral fica a cargo dos próprios aplicativos, mas a
	maioria dos programas existentes suporta pelo menos as expressões no
	padrão POSIX.
      </para>

      <para>
	Cada unidade sintática em uma expressão regular pode representar um dos
	seguintes itens:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">Um caractere</emphasis>: esta é a unidade
	    básica de cada expressão regular: um caractere ou um conjunto de 
	    caracteres.  Uma letra <emphasis>p</emphasis> ou o 
	    símbolo <emphasis>,</emphasis>, são exemplos de caracteres. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Quantificação</emphasis>: um quantificador 
	    especifica quantas vezes o caractere ou o conjunto de caracteres que
	    o precede pode constar no padrão. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternância</emphasis>: alternância é usada 
	    para fazer a correspondência <quote>a ou b</quote>, em que 
            <emphasis>a</emphasis> e <emphasis>b</emphasis> podem ser ambos
	    caracteres ou expressões regulares.</para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Agrupamento</emphasis>: é usado para agrupar
	    sub-expressões, de forma que um quantificador ou um indicador de
	    alternância podem ser aplicados a um grupo.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Expressões regulares tradicionais do tipo UNIX</title>

      <para>
	Esta seção descreve as expressões regulares tradicionais do tipo UNIX. 
	Por uma falta de padronização, a sintaxe exata pode ser um pouco
	diferente dependendo do programa utilitário em questão.  Normalmente, a
	página de manual ou a ajuda do comando dispõe de informação detalhada
	sobre o suporte a expressões regulares básicas ou tradicionais.  É uma
	boa idéia aprender as expressões regulares tradicionais, mas prefira
	utilizar as do padrão POSIX ao criar seus próprios scripts.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Correspondência de caracteres</title>

        <para>
	  Caracteres fazem correspondência consigo próprios.  Se um caractere
	  específico for usado como um caractere sintático para expressões
	  regulares, você pode referenciar àquele caractere adicionando uma
	  barra invertida na frente.  Por exemplo, <emphasis>\+</emphasis> 
	  corresponde com o sinal de mais.</para>

        <para>
	  Um ponto (<emphasis>.</emphasis>) corresponde a qualquer caractere, por
	  exemplo, a expressão <emphasis>b.g</emphasis> corresponde com 
	  <emphasis>bag</emphasis>, <emphasis>big</emphasis>, e com
	  <emphasis>blg</emphasis>, mas não com
	  <emphasis>bit</emphasis>. </para>

        <para>
	  O caractere ponto, quase sempre acaba lhe dando muita liberdade.  Você
	  pode usar colchetes (<emphasis>[]</emphasis>) para especificar 
	  caracteres que podem constar no padrão.  Por exemplo, a expressão
	  <emphasis>b[aei]g</emphasis> casa com
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, e com
	  <emphasis>big</emphasis>, mas com nada mais.  Você também pode fazer a
	  correspondência com qualquer caracter exceto os de um dado conjunto
	  usando colchetes com um circunflexo (<emphasis>^</emphasis>) como 
	  primeiro caracter.  Por exemplo, <emphasis>b[^aei]g</emphasis> vai 
	  casar com qualquer strings de três caracteres que comecem com
	  <emphasis>b</emphasis> e terminem com <emphasis>g</emphasis>, exceto
	  as sequências <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, e
	  <emphasis>big</emphasis>.  Também é possível especificar uma
	  sequência de caracteres para correspondência com um hífen 
	  (<emphasis>-</emphasis>).  Por exemplo,  <emphasis>a[0-9]</emphasis> 
	  casa com uma letra a seguida de um único dígito caracter de 0 a 9.</para>

        <para>
	  Dois caracteres especiais, o circunflexo (<emphasis>^</emphasis>) e
	  o cifrão (<emphasis>$</emphasis>) correspondem, respectivamente com o
	  começo e com o final de uma linha.  Isto é muito útil ao analisar
	  arquivos.  Por exemplo, você pode encontrar todas as linhas que 
	  comecem com uma tralha (<emphasis>#</emphasis>) com a expressão
	  <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Quantificação</title>

        <para>
	  O sinal mais simples de quantificação que uma expressão regular
	  tradicional suporta é o asterisco, ou também chamada de estrela de
	  Kleene (<emphasis>*</emphasis>).  Este quantificador especifica
	  zero ou mais correspondências do caracter precedente.  Por exemplo,
	  <emphasis>ba*</emphasis> corresponde às sequências
	  <emphasis>b</emphasis>, <emphasis>ba</emphasis>,
	  <emphasis>baa</emphasis>, etc.  Você deve atentar que um único 
	  caracter seguido por uma estrela sem qualquer contexto pode 
	  corresponder a qualquer string, pois <emphasis>c*</emphasis> também
	  corresponde à string que não possui nenhum caracter
	  <emphasis>c</emphasis>.</para>

        <para>
	  Repetições mais específicas podem ser especificadas por sinais de
	  abre e fecha chaves, devidamente escapados com barras invertidas.
	  <emphasis>\{x,y\}</emphasis> casa com o caracter precedente repetido
	  pelo menos <emphasis>x</emphasis> vezes, mas não mais que
	  <emphasis>y</emphasis> vezes.  Assim, <emphasis>ba\{1,3\}</emphasis> 
	  corresponderá às sequências <emphasis>ba</emphasis>,
	  <emphasis>baa</emphasis>, e <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Agrupamento</title>

        <para>
	  Parênteses escapados com barras invertidas agrupam vários caracteres
	  juntos, de forma que você pode aplicar quantificadores ou indicadores
	  de alternância a um grupo de caracteres.  Por exemplo,
	  <emphasis>\(ab\)\{1,3\}</emphasis> vai corresponder a 
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, e
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternância</title>

        <para>
	  Uma barra vertical (pipe) escapada com uma barra invertida 
	  (<emphasis>\|</emphasis>) permite que você faça correspondência com
	  apenas uma dentre duas expressões.  Isso não é muito útil para
	  caracteres isolados já que <emphasis>a\|b</emphasis> é equivalente a
	  <emphasis>[ab]</emphasis>, mas é muito útil quando usado com
	  agrupamento.  Suponha que você quer uma expressão que corresponda a
	  <emphasis>apple</emphasis> e a <emphasis>pear</emphasis>, e nada mais.
	  Isto pode ser feito facilmente com a barra vertical:
	  <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>Expressões regulares estendidas do padrão POSIX</title>

	<para>
	  Expressões regulares POSIX foram construídas em cima das expressões
	  tradicionais do UNIX, adicionando algumas outras primitivas úteis.
	  Outra diferença confortável é que os parênteses de agrupamento, os
	  quantificadores e o indicador de alternância (<emphasis>|</emphasis>)
	  não precisam ser escapados.  Porém, se forem escapados, esses símbolos 
	  irão corresponder literalmente com os próprios caracteres, resultando
	  no comportamento oposto ao das expressões regulares tradicionais.  A
	  maioria das pessoas consideram as expressões regulares POSIX muito
	  mais confortáveis, o que faz com que elas sejam mais comumente usadas.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	<title>Correspondência de caracteres</title>

	  <para>
	    A correspondência de caracteres normais não muda em nada nas
	    expressões regulares POSIX quando comparadas com as tradicionais
	    descritas em <xref
	    linkend="chap-textproc-regexps-traditional-characters" />
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Quantificação</title>

	  <para>
	    Além da estrela de Kleene (<emphasis>*</emphasis>), que corresponde
	    a repetição de zero ou mais vezes do caracter ou grupo precedente,
	    expressões regulares POSIX incluem mais dois novos quantificadores.
	    O sinal de mais (<emphasis>+</emphasis>) faz correspondência com o 
	    caracter ou grupo precedente repetido pelo menos uma ou mais vezes.  
	    Por exemplo, a expressão <emphasis>a+</emphasis>, corresponde à
	    string <emphasis>a</emphasis> (bem como com qualquer outra string
	    que contenha sequências de <emphasis>a</emphasis>'s repetidos), mas
	    não faz correspondência com a sequência vazia de zero
	    <emphasis>a</emphasis>'s.  O caracter de interrogação
	    (<emphasis>?</emphasis>) faz correspondência do caracter precedente
	    por zero ou uma vez.  Assim, <emphasis>ba?d</emphasis> corresponde a
	    <emphasis>bd</emphasis> e <emphasis>bad</emphasis>, mas não com
	    not <emphasis>baad</emphasis> nem com <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Chaves são usadas para repetição, como nas expressões regulares
	    tradicionais.  Porém a barra invertida para escape pode ser omitida.
	    Para corresponder às strings <emphasis>ba</emphasis> e
	    <emphasis>baa</emphasis>, alguém poderia usar 
	    <emphasis>ba{1,2}</emphasis> ao invés de 
	    <emphasis>ba\{1,2\}</emphasis> nas expressões tradicionais.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Agrupamento</title>

	  <para>
	    Agrupamento é feito da mesma maneira que em expressões regulares
	    tradicionais, também dispensando as barras invertidas para escape
	    antes dos parênteses.  Por exemplo, <emphasis>(ab){1,3}</emphasis>
	    corresponde a <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, e
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	<title>Alternância</title>

	  <para>
	    Alternância também é feita da mesma maneira que nas expressões
	    regulares tradicionais, também dispensando as barras invertidas para
	    escape antes da barra vertical.  Assim, a expressão
	    <emphasis>(apple)|(pear)</emphasis> corresponde a 
	    <emphasis>apple</emphasis> e também a <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

      <!--
      <sect2 xml:id="chap-textproc-regexps-perl"> <title>Perl</title>
      </sect2>
    -->

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>

    <!-- XXX - document -c, -l, -x, -n, -q parameters -->

    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Utilização básica do grep</title>

      <para>
	Chegamos agora a um dos mais importantes utilitários dos sistemas UNIX,
	e à nossa primeira oportunidade de utilizar expressões regulares.  O 
	comando <command>grep</command> é usado para procurar padrões de textos
	em fluxos ou em arquivo de texto.  Esses tais padrões são expressões
	regulares, e podem ser tanto as expressões regulares básicas como
	expressões estendidas do padrão POSIX (quando o parâmetro
	<parameter class="command">-E</parameter> for usado).  Por padrão, o 
	<command>grep</command> irá escrever na saída as linhas onde ocorrem
	correspondências.  Em sua sintaxe mais básica, você pode especificar uma
	expressão regular como argumento, e o <command>grep</command> irá
	procurar ocorrências do padrão no texto dado na entrada padrão.  Esta é
	uma boa maneira de praticar um pouco com expressões regulares.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	O exemplo listado acima mostra em ação uma expressão regular básica que
	faz correspondência em uma linha que consiste apenas na repetição da
	string <emphasis>ab</emphasis> por duas ou três vezes.  Você pode fazer
	o mesmo com expressões regulares estendidas POSIX, adicionando o
	parâmetro <parameter class="command">-E</parameter> (de Estendida):
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Como o comportamento padrão do <command>grep</command> é ler da entrada
	padrão, você pode colocá-lo em um duto (ou pipeline) para pegar partes
	interessantes da saída de comandos precedentes em um pipeline.  Por 
	exemplo, se você quiser procurar pela string <emphasis>2006</emphasis> 
	na terceira coluna de um arquivo, você pode combinar o
	<command>grep</command> com o comando <command>cut</command>:
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>Executando o grep com arquivos</title>

      <para>
	Naturalmente, o <command>grep</command> também pode ler diretamente sua
	entrada a partir de um arquivo, ao invés da entrada padrão.  Isso é
	feito normalmente incluindo-se os arquivos a serem lidos como últimos
	argumentos do grep.  O exemplo a seguir vai imprimir todas as linha do
	arquivo <filename>/etc/passwd</filename> que comecem com a string 
	<emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <!-- XXX - filename notation when multiple files are specified -->

      <para>
        Com a opção <parameter class="command">-r</parameter>, o 
	<command>grep</command> irá percorrer uma estrutura de diretórios
	recursivamente, tentando procurar por correspondências em cada arquivo
	que encontrar durante o percurso.  No entanto, é melhor combinar o 
	<command>grep</command> com o comando <command>find</command> e o
	operando <emphasis>-exec</emphasis> em scripts que precisam ser
	portáveis.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	é uma forma não-portável que faz a mesma coisa que seu equivalente
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Comportamentos de padrões</title>

      <para>
	O <command>grep</command> também pode exibir todas as linhas que não
	correspondem com o padrão especificado.  Isso é feito adicionando-se o
	parâmetro <parameter class="command">-v</parameter>:
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	Se você quiser usar o padrão de uma forma insensível à caixa (não
	diferenciando maiúsculas e minúsculas), você pode adicionar o parâmetro
	<parameter class="command">-i</parameter>.  Por exemplo:
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	Você também pode fazer correspondências de strings literais com o
	parâmetro <parameter class="command">-F</parameter>:
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Usando múltiplos padrões</title>

      <para>
	Como já vimos, você pode usar o caracter de alternância
	(<emphasis>|</emphasis>) para fazer correspondências com um de dois
	ou mais subpadrões.  Se dois padrões com os quais você gostaria de
	encontrar correspondências diferirem muito, pode ser mais adequado
	deixá-los como dois padrões separados.  O <command>grep</command> 
	permite que você utilize mais do que um padrão ao mesmo tempo,
	separando-os por uma quebra de linha.  Assim, por exemplo, se você
	quiser exibir as linhas que correspondam tanto com o padrão 
	<emphasis>a</emphasis> quanto com o padrão
	<emphasis>b</emphasis>, isso pode ser feito facilmente iniciando uma
	nova linha, como:
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	Este exemplo funciona porque aspas simples foram usadas, e o shell
	interpreta parâmetros entre aspas literalmente.  Porém, é de se esperar
	que isso pode não ser muito adequado.  O <command>grep</command> aceita
	um ou mais parâmetros como <parameter class="command">-e
	pattern</parameter>, dando-lhe a oportunidade de especificar mais do que
	um parâmetro em uma linha.  Uma execução equivalente do comando 
	<command>grep</command> do exemplo anterior poderia ser feita como:
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
