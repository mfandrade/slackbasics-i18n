<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="en"
  xml:id="chap-textproc">
  <title>Processamento de Texto</title>

  <para>
    A manipulação de texto é algo que é o UNIX faz bem, isso porque
    é parte do coração de sua filosofia, como descrito em
    <xref linkend="chap-intro-unix" />. A maioria dos comandos UNIX
    são programas simples que lêem dados da entrada padrão,
    realizam algumas operações nestes e enviam o resultado para a
    saída padrão. Esses programas agem basicamente como filtros, que
    podem se conectar como um duto. Isso permite que o usuário
    empregue as ferramentas UNIX de modo que seus criadores
    nunca tenham vislumbrado. Nos capítulos seguintes veremos como
    você pode construir filtros simples para si mesmo.
    <!-- XXX - xref -->
  </para>

  <para>
    Este capítulo descreve alguns comandos UNIX simples, mas
    importantes, que podem ser utilizados para a manipulação de texto.
    Depois disso, veremos as expressões regulares, uma sub-linguagem
    que pode ser utilizada para encontrar padrões de correspondência
    em textos.
  </para>

  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulação simples de texto</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Repetindo o que foi dito</title>

      <para>
    O filtro de texto mais simples é o <command>cat</command>, ele
    não faz mais que enviar os dados da stdin para a stdout:
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
    Outra característica útil, é que você pode fazer com que ele
    envie o conteúdo de um arquivo para a saída padrão:
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
    <command>cat</command> faz o que seu nome diz quando múltiplos
    arquivos são adicionados como seus argumentos. Ele concatena os
    arquivos, no sentido de enviar o conteúdo de todos os arquivos
    para a saída padrão, na mesma ordem em que foram especificados
    como argumento. O seguinte trecho de tela demonstra isso:
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Estatísticas de texto</title>

      <para>
    O comando <command>wc</command> provê estatísticas sobre um
    arquivo texto ou uma stream de texto. Sem parâmetros, irá imprimir
    o número de linhas, o número de palavras e o número de bytes
    respectivamente. Uma palavra é delimitada por um caractere de
    espaço em branco ou uma sequência de caracteres em branco.
      </para>

      <para>
    O seguinte exemplo mostra o número de linhas, palavras e bytes no
    exemplo canônico <quote>Hello world!</quote>:
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput>
       1       2      13
      </screen>

      <para>
    Se quiser imprimir somente um desses componentes, você pode usar
    um dos parâmetros <parameter class="command">-l</parameter>
    (linhas), <parameter class="command">-w</parameter> (palavras) ou
    <parameter class="command">-c</parameter> (bytes).
    Por enquanto, adicionando somente o parâmetro <parameter
    class="command">-l</parameter> mostrará o número de linhas de um
    arquivo:
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command>
  235882 /usr/share/dict/words
      </screen>

      <para>
    Ou você pode imprimir campos adicionais adicionando o parâmetro:
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
    Note que, não importa a ordem em que as opções foram
    especificadas, a ordem de saída será sempre a mesma (linhas,
    palavras, bytes).
      </para>

      <para>
    O parâmetro <parameter class="command">-c</parameter> imprime o
    número de bytes, esse parâmetro pode não representar o número de
    caracteres que um texto possui, porque o conjunto de caracteres
    em uso pode ser de comprimento maior que um byte. Finalmente, o
    parâmetro <parameter class="command">-m</parameter> foi adicionado
    e imprime o número de caracteres no texto, independentemente do
    conjunto de caracteres. Os parâmetros <parameter
    class="command">-c</parameter> e <parameter class="command">-m
    </parameter> são substitutos e podem nunca serem utilizados ao
    mesmo tempo.
      </para>

      <para>
    As estatísticas que <command>wc</command> provê são mais úteis
    que podem aparentar. Por exemplo, o parâmetro <parameter
    class="command">-l</parameter> é utilizado geralmente em
    contagens da saída de um comando. Isso é conveniente, pois muitos
    comandos separam unidades lógicas por novas linhas. Suponha que
    você queira contar o número de arquivos em seu diretorio home
    que possuam seu nome terminado com <filename>.txt</filename>.
    Você poderia fazer isso combinando <command>find</command> para
    encontrar arquivos relevantes e <command>wc</command> para contar
    o número de ocorrências:
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Manipulando caracteres</title>

      <para>
	O comando <command>tr</command> pode ser utilizado para operações
    comuns a caracteres, como troca de caracteres, remoção de
    caracteres e misturando sequências de caracteres. Dependendo da
    operação, um ou mais conjuntos de caracteres podem ser
    especificados. Com exceção dos caracteres normais, existem algumas
    sequências de caracteres especiais que podem ser utilizadas:
      </para>

      <variablelist>
	<varlistentry>
	  <term>\caractere</term>
	  <listitem>
	    <para>
          Essa notação é utilizada para especificar caracteres que
          precisam ser escapados, mais notavelmente <emphasis>\n
          </emphasis> (nova linha), <emphasis>\t</emphasis>
          (tabulação horizontal), e <emphasis>\\</emphasis> (barra
          invertida).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>character1-character2</term>
	  <listitem>
	    <para>
	      Insere implicitamente todos os caracteres de
	      <emphasis>character1</emphasis> até
	      <emphasis>character2</emphasis>. Essa notação deve ser usada
	      com cuidado, pois nem sempre gera o resultado esperado. Por
          exemplo, a sequência <emphasis>a-d</emphasis> pode
          substituir <emphasis>abcd</emphasis> pela localidade POSIX
          (configurações de linguagem), mas isso pode não ser verdade
          para outras localidades.
	      <!-- XXX - notas de cabeçalho sobre localidade -->
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:class:]</term>
	  <listitem>
	    <para>
	      Acerta uma classe de caracteres pré-definidos. Todas as
          possíveis classes são mostradas em <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*]</term>
	  <listitem>
	    <para>
	      Repete o <emphasis>character</emphasis> até que o segundo
          conjunto seja tão longo quanto o primeiro conjunto de
          caracteres.  Esta notação só pode ser usada no segundo
          conjunto.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*n]</term>
	  <listitem>
	    <para>
	      Repete o <emphasis>character</emphasis> 
	      <emphasis>n</emphasis> vezes.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>Classes de caracteres do tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Classe</entry><entry>Significado</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Todas as letras e números.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Letras.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Espaços horizontais (p.ex., espaços em branco e
          tabulações).</entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Caracteres de controle.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Todos os dígitos (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Todos os caracteres imprimíveis, exceto os espaços em
          branco.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Letras minúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Todos os caracteres imprimíveis, incluindo espaços em
          branco, mas excluindo espaços verticais.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Caracteres de pontuação.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
          <entry>Todos os caracteres de espaço.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Letras maiúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Dígitos hexadecimais (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Trocando caracteres</title>

    <para>
      A operação padrão do <command>tr</command> é trocar
      (traduzir) caracteres.  Isso quer dizer que o
      <emphasis>n</emphasis>-ésimo caracter no primeiro conjunto é
      substituído pelo <emphasis>n</emphasis>-ésimo caracter no segundo
      conjunto.  Por exemplo, você pode substituir todos os 
	  <emphasis>e</emphasis>'s por <emphasis>i</emphasis>'s e todos os
	  <emphasis>o</emphasis>'s por <emphasis>a</emphasis>'s com uma
      execução do <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
      Quando o segundo conjunto for menor que o primeiro, o último
      caracter no segundo conjunto será considerado repetido.  Porém,
      isto não é necessariamente aplicável a outros sistemas UNIX.
      Assim, se você quiser usar o <command>tr</command> de uma forma
      independente de sistema, defina explicitamente que caracter deve
      ser repetido.  Por exemplo
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
      Outra peculiaridade é o uso da sintaxe de repetição no meio do
      conjunto.  Suponha que o conjunto 1 seja 
	  <emphasis>abcdef</emphasis>, e que o conjunto 2 seja
	  <emphasis>@[-*]!</emphasis>.  O <command>tr</command> irá
      substituir o <emphasis>a</emphasis> por <emphasis>@</emphasis>,
	  <emphasis>b</emphasis>, <emphasis>c</emphasis>,
	  <emphasis>d</emphasis>, e <emphasis>e</emphasis> por
	  <emphasis>-</emphasis>, <emphasis>f</emphasis> e
	  <emphasis>!</emphasis>.
      Alguns outros sistemas UNIX seguiria substituindo 
      <emphasis>a</emphasis> por <emphasis>@</emphasis>, e os demais
      caracteres do conjunto por <emphasis>-</emphasis>.  Então, uma
      notação mais correta deveria ser <emphasis>@[-*4]!</emphasis>, que
      é mais explícita e tem o mesmo resultado virtualmente em todos os
      sistemas UNIX:
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Espremendo sequências de caracteres</title>

	<para>
      Quando o parâmetro <parameter class="command">-s</parameter> é
      usado, o <command>tr</command> irá espremer todos os caracteres
      que estão no segundo conjunto.  Isto quer dizer que uma sequência
      de mesmos caracteres será reduzida a um caracter.  Vamos espremer
      o caracter &quot;<emphasis>e</emphasis>&quot;:
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
      Vamos combinar isto com a substituição para mostrar um exemplo
      útil do <command>tr</command> em ação.  Suponha que queiramos
      marcar todas as vogais com o símbolo de
      <emphasis>arroba</emphasis> (<emphasis>@</emphasis>), com vogais
      consecutivas representadas por um <emphasis>at</emphasis>.  Isto
      pode ser feito canalizando-se dois comandos <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Excluindo caracteres</title>

	<para>
      Finalmente, o <command>tr</command> pode ser usado para excluir
      caracteres.  Se o parâmetro <parameter
      class="command">-d</parameter> for usado, todos os caracteres do
      primeiro conjunto são removidos:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Recortando e colando colunas de texto</title>

      <para>
        O comando <command>cut</command> está disponível em sistemas
        UNIX a partir de um arquivo ou de um fluxo de caracteres,
        imprimindo-o para a saída padrão.  Frequentemente é útil obter
        seletivamente alguma informação de um texto.  O
        <command>cut</command> possui três opções para recortar
        informação de arquivos:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Byte a byte.
	  </para>
	</listitem>
	<listitem>
	  <para>
        Por caracter, o que não é o mesmo que o recorte por byte em
        sistemas que utilizem uma codificação de caracteres maior que
        oito bits.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Por campo, que é delimitado por um caracter.
	  </para>
	</listitem>
      </orderedlist>

      <para>
        Em todas essas três abordagens, você pode especificar o elemento
        escolhido a partir de seu número começando em
        <emphasis>1</emphasis> ou especificar um intervalo usando um
        hífen (<emphasis>-</emphasis>).  Dessa forma,
        <emphasis>M-N</emphasis> se refere ao intervalo do M-ésimo ao
        N-ésimo elemento.  Se deixarmos M de fora,
        (<emphasis>-N</emphasis>) seleciona todos os elementos desde o
        primeiro até o N-ésimo elemento.  Deixar N de fora
        (<emphasis>M-</emphasis>) vai selecionar do M-ésimo até o último
        elemento.  Múltiplos elementos ou intervalos de elementos podem
        ser combinados se separados por vírgulas
        (<emphasis>,</emphasis>).  Assim, por exemplo,
        <emphasis>1,3-</emphasis> seleciona o primeiro elemento além dos
        que estiverem entre o terceiro e o último elemento.
      </para>

      <para>
        Os dados podem ser recortados por campo usando-se o parâmetro
        <parameter class="command">-f campos</parameter>.  Por padrão,
        uma tabulação horizontal é usada como separador.  Vamos dar uma
        olhada no comando <command>cut</command> em ação em um pequeno
        dicionário alemão-inglês:
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
        Podemos obter todas as palavras em inglês selecionando o
        segundo campo:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
        Isso foi bem fácil.  Agora vamos fazer a mesma coisa com um
        arquivo que usa o caracter de dois-pontos como separados.
        Podemos facilmente tentar isso convertendo o dicionário com o
        próprio <command>tr</command> que já vimos para substituir todas
        as tabulações por dois-pontos:
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
        Agora se usarmos o mesmo comando do exemplo anterior não teremos
        uma saída correta:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
        O que aconteceu aqui é que o delimitador não pôde ser
        encontrado.  Se uma linha não contiver o delimitador que está
        sendo usado, o comportamento padrão do <command>cut</command> é
        exibir a linha completa.  Você pode evitar isso com o parâmetro 
        <parameter class="command">-s</parameter>.
      </para>

      <para>
        Para usar um delimitador diferente da tabulação horizontal
        padrão, inclua o parâmetro <parameter class="command">-d
        caracter_delimitador</parameter> para definir o caracter
        delimitador.  Então, no caso do nosso arquivo 
        <filename>dictionary-new</filename>, vamos fazer o
        <command>cut</command> usar o dois-pontos como um delimitador:
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
        Se um campo que foi especificado não existir na linha, tal campo
        em particular não é exibido.
      </para>

      <para>
        As opções <parameter class="command">-b bytes</parameter> e
        <parameter class="command">-c caracteres</parameter>
        selecionam, respectivamente, bytes e caracteres a partir do
        texto.  Em sistemas mais antigos, um caracter costuma
        corresponder a um byte.  Mas novos sistemas podem dispor de
        codificações de caracteres que sejam maiores que apenas um byte.
        Assim, se você quiser se assegurar de obter caracteres
        completos, use sempre o parâmetro <parameter
        class="command">-c</parameter>.  Um exemplo divertido para
        vermos o parâmetro <parameter class="command">-c</parameter> em
        ação consiste em procurarmos os dez conjuntos mais comuns para
        os três primeiros caracteres de uma palavras.  A maioria dos
        sistemas UNIX possui uma lista de palavras que são separadas por
        caracteres de nova linha.  Podemos usar o comando
        <command>cut</command> para obter os primeiros três caracteres
        das palavras da lista, adicionar o comando <parameter
        class="command">uniq</parameter> <!-- XXX a where? --> para
        contar sequências idênticas de três caracteres, e usar o comando         
        <command>sort</command> para ordená-las numericamente em ordem
        descrescente (o <command>sort</command> é descrito em <xref
        linkend="chap-textproc-simple-sort" />).  Por fim, vamos usar o
        comando <command>head</command> para filtrar as dez sequências
        mais comuns:
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
        Agora que vimos essa simples e poderosa utilização de comandos
        do UNIX em ação, vamos ver agora o comando
        <command>paste</command>, o qual combina arquivos em colunas em
        um único fluxo de texto.
      </para>

      <para>
        O uso do <command>paste</command> é muito simples, ele irá
        combinar todos os arquivos dados como um argumento, separados
        por uma tabulação.  Com a lista de palavras em inglês e em
        alemão, podemos gerar um dicionário simples:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
        Você também pode combinar mais de dois arquivos:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput>
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
        Se um dos arquivos for mais longo, a ordem das colunas é
        mantida, e espaços vazios são usados para preencher as entradas
        correspondentes que faltarem nos arquivos menores.
      </para>

      <para>
        Você pode usar outro delimitador incluindo o parâmetro
        <parameter class="command">-d delimitador</parameter>.  Por
        exemplo, se quisermos que nosso dicionário tenha palavras
        separadas por dois-pontos:
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
        Normalmente o <command>paste</command> combina arquivos em
        diferentes colunas.  Você também pode fazer o
        <command>paste</command> usar as linhas de cada arquivo como
        colunas, e deixar as colunas de cada arquivo em linhas
        separadas.  Isto é feito com o parâmetro <parameter
        class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Ordenando texto</title>

      <para>
        O UNIX oferece o comando <command>sort</command> para ordenação
        de texto.  O <command>sort</command> também pode verificar se
        um arquivo já está ordenado, e também mesclar dois arquivos
        ordenados.  O <command>sort</command> também pode fazer tanto
        ordenação léxica (ordem do dicionário) quanto numérica.  A
        ordem padrão é a ordem do dicionário.  Isso quer dizer que as
        linhas de texto são comparadas caracter a caracter, e ordenadas
        como especificado pela sequência collate da localização atual
        (que é definida pela variável de ambiente LC_COLLATE).  Isto
        pode ser uma pegadinha quando você estiver ordenando números,
        por exemplo, se você tem os números de 1 a 10 em diferentes
        linhas, a sequência será 1, 10, 2, 3, etc.  Isto se deve a
        interpretação por caracter da ordem de dicionário.  Se você
        quiser ordenar as linhas pela numeração, utilize a ordenação
        numérica.
      </para>

      <para>
        Se nenhum parâmetro adicional for especificado, o
        <command>sort</command> ordena as linhas de entrada na ordem do
        dicionário.  Por exemplo:
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
        Como você pode ver, a entrada é ordenada corretamente.  Algumas
        vezes pode haver linhas idênticas.  Você pode mesclar linhas
        idênticas adicionando o parâmetro
        <parameter class="command">-u</parameter>.  Os dois exemplos
        listados abaixo ilustram isso.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
        Há alguns parâmetros adicionais que podem ser úteis para
        modificar um pouco o resultado:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
        O parâmetro <parameter class="command">-f</parameter> faz com
        que a ordenação seja insensível a maiúsculas e minúsculas.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Se <parameter class="command">-d</parameter> for adicionado,
	    apenas caracteres em branco e alfanuméricos são usados para
	    determinar a ordem.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    O parâmetro <parameter class="command">-i</parameter> faz com
	    que o <command>sort</command> ignore caracteres não imprimíveis.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
        Você pode ordenar arquivos numericamente adicionando o parâmetro
        <parameter class="command">-n</parameter>.  Este parâmetro pára
        de ler a entrada quando um caracter não numérico for encontrado.
        O sinal de menos, ponto decimal, separador de milhar, caracter
        de base (que diferente um número exponencial de um número
        normal), e espaços em branco podem ser usados como partes de um
        número.  Esses caracteres são interpretados adequadamente.
      </para>

      <para>
        O exemplo a seguir mostra a ordenação numérica em ação,
        canalizando a saída de um comando <command>du</command> para o
        <command>sort</command>.  Isso funciona porque o 
        <command>du</command> especifica o tamanho de cada arquivo como
        o primeiro campo.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
        Neste caso, a saída provavelmente não é muito útil se você
        quiser ler a saída em um paginador, porqur os arquivos menores
        são listados primeiro.  É aí que entra o parâmetro <parameter
        class="command">-r</parameter>.  Isso reverte a ordem de
        ordenação.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
        O parâmetro <parameter class="command">-r</parameter> também
        funciona com a ordenação léxica.
      </para>

      <para>
        Frequentemente, os arquivos utilizam estrutura de múltiplas
        comuns, e você pode querer ordenar um arquivo por uma outra
        coluna que não a primeira.  Por exemplo, considere o seguinte
        arquivo de pontuação chamado <filename>score.txt</filename>:
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>

    <para>
      Suponha que queiramos ordenar as entradas deste arquivo pelo campo
      de duas letras do país.  O <command>sort</command> nos permite 
      ordenar um arquivo por uma coluna com o parâmetro <parameter
      class="command">-k col1[,col2]</parameter>.  Sendo que as colunas
      de <emphasis>col1</emphasis> a <emphasis>col2</emphasis> são
      usadas como campos para ordenação da entrada.  Se 
      <emphasis>col2</emphasis> não for especificada, todos os campos
      até o final da linha são considerados.  Assim, se você quiser usar
      apenas uma coluna, utilize
      <parameter class="command">-k col1,col1</parameter>.  Você também
      pode especificar o caracter inicial de uma coluna adicionando um
      ponto (<emphasis>.</emphasis>) e um caracter de índice.  Por
      exemplo, <parameter class="command">-k 2.3,4.2</parameter>
      se refere à segunda coluna começando no terceiro caracter, a
      terceira coluna e a quarta coluna até (e incluindo) o segundo
      caracter.
    </para>

    <!-- XXX - document -b? Mentioned lateron (-k) -->

    <para>
      Ainda há uma outra peculiaridade sobre ordenação de colunas: por
      padrão, o <command>sort</command> usa um caracter em branco como
      separador de colunas.  Se você usar um caracter separador
      distinto, você tem que usar o parâmetro <parameter>-t
      char</parameter> para especificar o separador de campos.
    </para>

    <para>
      Combinando os parâmetros <parameter class="command">-t</parameter>
      e <parameter class="command">-k</parameter>, podemos ordenar o
      arquivo de pontuação pelo código do país:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Então, como podemos ordenar o arquivo pela pontuação em si?  
      Obviamente, podemos indicar para que o sort use a terceira coluna.
      Mas o sorte usa um dicionário de ordenação por
      padrão<footnote><para>É claro, isso realmente não faz diferença
      neste caso, pois não usamos números maiores que 9, e virtualmente
      todos os conjuntos de caracteres representam números em ordem
      numérica).</para></footnote>.  Você poderia usar o <parameter
      class="command">-n</parameter>, mas o <command>sort</command> 
      também permite uma abordagem mais sofisticada.  Você pode incluir
      <emphasis>n</emphasis>, <emphasis>r</emphasis>,
      <emphasis>f</emphasis>, <emphasis>d</emphasis>,
      <emphasis>i</emphasis>, ou <emphasis>b</emphasis> como
      especificador de coluna.  Essas letras representam parâmetros do
      <command>sort</command> com mesmo nome.  Se você adicionar apenas
      a coluna inicial, inclua-o àquela coluna, ou então, adicione-o à
      coluna final.
    </para>

    <para>
      O comando a seguir ordena o arquivo pela pontuação:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      É uma boa seguir esta abordagem, ao invés de usar as variantes de
      parâmetros, pois o <command>sort</command> permite que você use
      mais parâmetros que o <parameter class="command">-k</parameter>.
      E, adicionando essas opções à especificação de coluna também vai
      lhe permitir fazer ordenação por diferentes colunas de diferentes
      maneiras.  Por exemplo, usar o <command>sort</command> com os
      parâmetros <parameter class="command">-k 3,3n -k 2,2</parameter> 
      irá ordenar todas as linhas numericamente a partir da terceira
      coluna.  Se algumas linhas tiverem números idênticos nessa coluna,
      a ordenação dessas linhas será feita lexicamente a partir da 
      segunda coluna.
    </para>

    <para>
      Se você quiser apenas verificar se um arquivo já está ordenado, 
      você pode usar o parâmetro
      <parameter class="command">-c</parameter>.  Se o arquivo já
      estiver ordenado, o sort retornará o valor <emphasis>0</emphasis>, 
      e caso contrário, <emphasis>1</emphasis>.  Podemos conferir isso
      exibindo a variável <emphasis>?</emphasis>, que armazena o valor
      de retorno do último comando executado.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      O segundo comando mostra que funciona, canalizando a saída da
      ordenação do arquivo <filename>scores.txt</filename> para o
      <command>sort</command>.
    </para>

    <para>
      Finalmente, você pode mesclar dois arquivos ordenados com o
      parâmetro <parameter class="command">-m</parameter>, mantendo a
      ordem correta.  Isso é mais rápido que concatenar dois arquivos
      e reordená-los.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Diferenças entre arquivos</title>

      <para>
	Como fluxos e arquivos de texto são algo muito importante no UNIX, é
	bastante útl poder mostrar as diferenças entre dois arquivos de texto.  
	Os principais utilitários para se trabalhar com diferenças em arquivos
	são o <command>diff</command> e o <command>patch</command>.  O comando
	<command>diff</command> mostra as diferenças entre arquivos.  A saída do
	<command>diff</command> pode ser processada pelo 
	<command>patch</command> para se aplicar as diferenças entre os dois 
	arquivos de entrada para um arquivo.  Essas diferenças entre arquivos
	(<quote>diffs</quote>) também são a base para sistemas de gerenciamento
	e controle de versão. <!-- XXX - xref to version management chapters -->
	As seções seguintes descrevem os comandos <command>diff</command> e <command>patch</command>.  Para ter algum material com o qual trabalhar,
	os dois seguintes arquivos fontes em C são usados para demonstrar esses
	comandos.  Estes arquivos são chamados <filename>hello.c</filename> ane
	<filename>hello2.c</filename>, respectivamente.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Listando as diferenças entre arquivos</title>

	<para>
	  Suponha que você tenha recebido o programa
	  <filename>hello.c</filename> de um amigo, e que você o tenha
	  modificado para informar ao usuário a data e hora atuais.  Você
	  poderia apenas enviar o programa atualizado de volta para seu amigo.
	  Mas se um arquivo crescer muito, isso pode se tornar inconveniente, 
	  pois as mudanças ficam mais difíceis de se gerenciar.  Além disso, seu
	  amigo pode também ter recebido versões modificadas do progama de
	  outras pessoas.  Estas é uma situação típica em que o 
	  <command>diff</command> se torna útil.  O <command>diff</command>
	  mostra as diferenças entre dois arquivos.  Sua sintaxe mais básica é
	  <command>diff file file2</command>, que mostra as diferenças entre os
	  arquivos <filename>file</filename> e <filename>file2</filename>.  
	  Vamos tentar isto com nossos arquivos fontes:
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  As adições de <filename>hello2.c</filename> são visíveis nesta
	  saída, mas o formato pode lhe ser um pouco estranho.  Atualmente, 
	  estes são comandos que podem ser interpretados pelo editor de linha
	  de comando, <command>ed</command>.  Vamos ver um formato de saída
	  mais confortável depois de examinar o básico do formato de saída
	  padrão.
	</para>

	<para>
	  Dois elementos distintos podem ser destacados nesta saída:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      Este é um comando do <application>ed</application> que é
	      especificado que especifica que o texto deve ser anexado 
	      (<literal>a</literal>) depois da linha <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      Este é o texto atual a ser anexado depois da segunda linha.  O 
	      sinal <quote><emphasis>&gt;</emphasis></quote> é usado para marcar
	      as linhas a serem adicionadas.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Os mesmos elementos são usados para adicionar o segundo bloco de
	  texto.  Mas e sobre as linhas que são removidas?  Podemos facilmente
	  ver como elas são representadas trocando os dois parâmetros do comando
	  <command>diff</command>, mostrando as diferenças entre 
	  <filename>hello2.c</filename> e
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Os seguintes elementos podem ser destacados:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      Este é o comando de exclusão do <application>ed</application>
	      (<literal>d</literal>), indicando que a linha 2 deveria ser
	      excluída.  O segundo comando de exclusão utiliza um intervalo 
	      (da linha 14 à linha 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      O texto que está para ser removido é precedido por um sinal de 
	      <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>

	<!-- XXX - Changed lines? -->

	<para>
	  Isso é o suficiente para a saída no estilo do comando 
	  <application>ed</application>.  O programa GNU diff incluído no
	  Slackware Linux suporta os, assim chamados, diffs unificados.  Diffs
	  unificados são bastante legíveis, e provêem um contexto por padrão. 
	  O <command>diff</command> pode gerar saída no padrão de diff unificado
	  com a opção <parameter class="command">-u</parameter>:
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Os seguintes elementos podemm ser encontrados na saída:
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      O nome do arquivo original, e o registro de tempo do horário da
	      última modificação.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      O nome do arquivo modificado, e o registro de tempo do horário da
	      última modificação.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Este par de números mostra a localização e o tamanho do trecho 
	      cujo texto abaixo foi afetado no arquivo original e no arquivo
	      modificada.  Assim, neste caso os números significam que o trecho
	      modificado começa na linha 1, e tem o tamanho de quatro linhas.
	      No arquivo modificado, o trecho respectivo começa na linha 1, e 
	      tem o tamanho de cinco linhas.  Trechos diferentes na saída do
	      diff começam com este cabeçalho.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Uma linha que não inicie por um sinal de menos 
	      (<emphasis>-</emphasis>) ou por um sinal de mais
	      (<emphasis>+</emphasis>) foi mantida intacta.  Linhas que não
	      foram modificadas são incluídas para dar alguma informação
	      contextual, e para evitar a listagem de muitos trechos
	      modificados em sequência.  Se houver algumas poucas linhas
	      intactas entre as modificações, o <command>diff</command> irá
	      considerar apenas um único trecho, ao invés de dois trechos.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Uma linha inicada por um sinal de mais 
	      (<emphasis>+</emphasis>) é uma adição ao arquivo modificado, em
	      relação ao arquivo original.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Tal como fizemos com o formato no estilo do editor ed, podemos ver
	  algumas exclusões trocando os nomes dos arquivos:
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Como você vê nesta saída, as linhas que são excluídas do arquivo
	  modificado em relação ao arquivo original são iniciadas com um sinal
	  de menos (<emphasis>-</emphasis>).
	</para>

	<para>
	  Quando você estiver trabalhando com conjuntos maiores de arquivos, 
	  quase sempre é útil comparar diretórios inteiros.  Como exemplo, se
	  você tem uma versão original dos fontes de um programa em um diretório
	  chamado <filename>hello.orig</filename>, e uma versão modificada do
	  mesmo em um diretório chamado <filename>hello</filename>, você pode
	  usar o parâmetro <parameter class="command">-r</parameter> para fazer
	  uma comparação recursiva de ambos os diretórios.  Por exemplo:
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  Deve-se notar que isto irá comparar apenas os arquivos que estiverem
	  presentes em ambos os diretórios.  A versão GNU do diff, que é a 
	  utilizada pelo Slackware Linux, dispõe do parâmetro 
	  <parameter class="command">-N</parameter>.  Este parâmetro trata
	  arquivos que existem em apenas um dos diretórios como se estivessem
	  vazios no outro.  Assim, no caso, se adicionarmos um arquivo chamado
	  <filename>Makefile</filename> ao diretório <filename>hello</filename>,
	  usar o parâmetro <parameter class="command">-N</parameter> nos daria a
	  seguinte saída:
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Como você pode ver, o indicador de trechos diz que o trecho no arquivo
	  original inicia na linha 0 e tem um tamanho de 0 linhas.
	</para>

	<para>
	  Usuários de UNIX quase sempre utilizam a saída do comando 
	  <command>diff</command>, chamados de <quote>diffs</quote> ou de 
	  <quote>patches</quote>.  A próxima seção irá lhe mostrar como você
	  pode manipular esses arquivos de diffs.  Mas agora você mesmo já é
	  capaz de criar tais arquivos, redirecionando a saída do comando diff
	  para um arquivo.  Por exemplo:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Se você tiver múltplos diffs, você pode combiná-los facilmente para
	  apenas um diff, concatenando-os:
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Mas, assegure-se de que os arquivos tenham sido criados a partir do
	  mesmo diretório se você quiser usar o utilitário
	  <command>patch</command>, abordado na próxima seção.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Modifying files with diff output</title>

	<para>
	  Suponha que alguém lhe envie a saída de um <command>diff</command>
	  para um arquivo que você tenha criado.  Seria tedioso tentar
	  incorporar manualmente todas as modificações que foram feitas.  
	  Felizmente, o comando <command>patch</command> pode fazer isso para
	  você.  O <command>patch</command> aceita diffs na entrada padrão, e
	  tentará aplicar as modificações no arquivo original, tal como
	  registradas no arquivo diff.  Então, por exemplo, se temos o arquivo
	  <filename>hello.c</filename>, e o patch que geramos com as
	  modificações que fizemos anteriormente baseadas nas modificações entre
	  nossos arquivos <filename>hello.c</filename> e
	  <filename>hello2.c</filename>, podemos aplicar as modificações ao 
	  <filename>hello.c</filename> para que este fique igual à sua
	  contraparte:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  If you have <filename>hello2.c</filename>, you can check
	  whether the files are identical now:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  Não há nenhuma saída, mas é assim mesmo.  Uma das melhores coisas
	  sobre o <command>patch</command> é que ele pode reverter as alterações
	  feitas a partir de um diff, usando o parâmetro <parameter
	  class="command">-R</parameter>:
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  Nestes exemplos, alterações são aplicadas ao arquivo original.  
	  Algumas vezes, você pode querer aplicar o patch a um arquivo com um
	  nome diferente.  Você pode fazer isso informando o nome de um arquivo
	  como último argumento:
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  Você também pode usar o comando <command>patch</command> com diffs que
	  tiverem sido gerados com o parâmetro <parameter
	  class="command">-r</parameter>, mas você precisa ter um pouco de
	  cuidado.  Suponha que o cabeçalho de um dado arquivo no diff seja o
	  seguinte:
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Se você processar este diff com o <command>patch</command>, ele
	  tentará modificar o arquivo <filename>hello.c</filename>.  Assim, o
	  diretório que contém este arquivo precisa ser o diretório atual.  Você
	  pode usar o caminho completo com o parâmetro <parameter
	  class="command">-p n</parameter>, sendo <emphasis>n</emphasis> o
	  número de componentes do caminho que devem ser considerados.
	  <!-- is the number of pathname components that should be stripped -->
	  Um valor <emphasis>0</emphasis> implicará no uso do caminho como
	  especificado pelo arquivo do patch, um valor <emphasis>1</emphasis>
	  vai considerar o primeiro componente do caminho, e etc.  Neste
	  exemplo, considerar o primeiro componente irá resultar na execução de
	  um patch em <filename>hello.c</filename>.  De acordo com a versão 3 do 
	  padrão Single UNIX Specification, um caminho que for precedido por
	  <emphasis>---</emphasis> deveria ser usado para construir o arquivo
	  no qual o patch deveria ser aplicado.  A versão GNU do comando patch
	  não segue este padrão aqui.  Então, é melhor é considerar sempre um
	  ponto onde ambos os nomes de diretórios forem iguais (normalmente o 
	  diretório pai da árvore que está sendo modificada).  Na maioria dos 
	  casos em que caminhos relativos são usados, isto pode ser feito 
	  especificando-se <emphasis>-p 1</emphasis>.  Por exemplo:
	</para>

	<!-- XXX - add more examples for -p n -->

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  Ou, você pode usar o parâmetro <parameter
	  class="command">-d</parameter> para especificar em qual diretório as
	  modificações devem ser aplicadas:
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Se você quiser manter um backup ao aplicar as modificações a um
	  arquivo, você pode usar o parâmetro <parameter class="command">-b</parameter> do comando <command>patch</command>.  
	  Isto irá fazer uma cópia de segurança de cada arquivo afetado chamada
	  <filename>filename.orig</filename>, antes de efetivamente modificar o
	  arquivo:
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Algumas vezes, modificações não podem ser aplicadas a arquivos.  Por
	  exemplo, se o arquivo já tiver sofrido um patch, se as modificações
	  realizadas foram tantas a ponto de dificultar uma clara criação de um
	  patch, ou se o arquivo meramente não existir.  Nesses casos, os
	  trechos que não puderem ser salvos são armazenados em um arquivo
	  chamado <filename>filename.rej</filename>, sendo 
	  <emphasis>filename</emphasis> o nome do arquivo de 
	  <command>patch</command> que se tentou aplicar.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Regular expressions</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Introduction</title>

      <para> In daily life, you will often want to some text that
      matches to a certain pattern, rather than a literal string. Many
      UNIX utilities implement a language for matching text patterns,
      <emphasis>regular expressions</emphasis> (regexps). Over time
      the regular expression language has grown, there are now
      basically three regular expression syntaxes: </para>

      <itemizedlist>
        <listitem>
          <para> Traditional UNIX regular expressions. </para>
        </listitem>
        <listitem>
          <para> POSIX extended regular expressions. </para>
        </listitem>
        <listitem>
          <para> Perl-compatible regular expressions (PCRE). </para>
        </listitem>
      </itemizedlist>

      <para>
	POSIX regexps are mostly a superset of traditional UNIX
	regexps, and PCREs a superset of POSIX regexps. The syntax
	that an application supports differs per application, but
	almost all applications support at least POSIX
	regexps.
      </para>

      <para>
	Each syntactical unit in a regexp expresses one of the
	following things:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">A character</emphasis>: this is the
            basis of every regular expression, a character or a set of
            characters to be matched. For instance, the letter
            <emphasis>p</emphasis> or the the sign
            <emphasis>,</emphasis>. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Quantification</emphasis>: a
            quantifier specifies how many times the preceding
            character or set of characters should be matched. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternation</emphasis>: alternation
            is used to match <quote>a or b</quote> in which
            <emphasis>a</emphasis> and <emphasis>b</emphasis> can be a
            character or a regexp. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Grouping</emphasis>: this is used to
            group subexpressions, so that quantification or
            alternation can be applied to the group. </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Traditional UNIX regexps</title>

      <para>
	This section describes traditional UNIX regexps. Because of a
	lack of standardisation, the exact syntax may differ a bit per
	utility. Usually, the manual page of a command provides more
	detailed information about the supported basic or traditional
	regular expressions. It is a good idea to learn traditional
	regexps, but to use POSIX regexps for your own
	scripts.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Matching characters</title>

        <para>
	  Characters are matched by themselves. If a specific
	  character is used as a syntactic character for regexps, you
	  can match that character by adding a backslash. For
	  instance, <emphasis>\+</emphasis> matches the plus
	  character. </para>

        <para>
	  A period (<emphasis>.</emphasis>) matches any character, for
	  instance, the regexp <emphasis>b.g</emphasis> matches
	  <emphasis>bag</emphasis>, <emphasis>big</emphasis>, and
	  <emphasis>blg</emphasis>, but not
	  <emphasis>bit</emphasis>. </para>

        <para>
	  The period character, often provides too much freedom. You
	  can use square brackets (<emphasis>[]</emphasis>) to specify
	  characters which can be matched. For instance, the regexp
	  <emphasis>b[aei]g</emphasis> matches
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, and
	  <emphasis>big</emphasis>, but nothing else. You can also
	  match any character but the characters in a set by using the
	  square brackets, and using the caret
	  (<emphasis>^</emphasis>) as the first character. For
	  instance, <emphasis>b[^aei]g</emphasis> matches any three
	  character string that starts with <emphasis>b</emphasis> and
	  ends with <emphasis>g</emphasis>, with the exception of
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, and
	  <emphasis>big</emphasis>. It is also possible to match a
	  range of characters with a dash
	  (<emphasis>-</emphasis>). For example,
	  <emphasis>a[0-9]</emphasis> matches a followed by a single
	  number character. </para>

        <para>
	  Two special characters, the caret (<emphasis>^</emphasis>)
	  and the dollar sign (<emphasis>$</emphasis>), respectively
	  match the start and end of a line. This is very handy for
	  parsing files. For instance, you can match all lines that
	  start with a hash (<emphasis>#</emphasis>) with the regexp
	  <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Quantification</title>

        <para>
	  The simplest quantification sign that traditional regular
	  expressions support is the (Kleene) star
	  (<emphasis>*</emphasis>). This matches zero or arbitrary
	  instances of the preceding character. For instance,
	  <emphasis>ba*</emphasis> matches <emphasis>b</emphasis>,
	  <emphasis>ba</emphasis><emphasis>baa</emphasis>, etc. You
	  should be aware that a single character folowed by a star
	  without any context matches every string, because
	  <emphasis>c*</emphasis> also matches a string that has zero
	  <emphasis>c</emphasis> characters. </para>

        <para>
	  More specific repetitions can be specified with
	  backslash-escaped curly braces.
	  <emphasis>\{x,y\}</emphasis> matches the preceding character
	  at least <emphasis>x</emphasis> times, but not more than
	  <emphasis>y</emphasis> times. So,
	  <emphasis>ba\{1,3\}</emphasis> matches
	  <emphasis>ba</emphasis>, <emphasis>baa</emphasis>, and
	  <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Grouping</title>

        <para>
	  Backslash-escaped parentheses group various characters
	  together, so that you can apply quantification or
	  alternation to a group of characters. For instance,
	  <emphasis>\(ab\)\{1,3\}</emphasis> matches
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, and
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternation</title>

        <para>
	  A backslash-escaped pipe vertical bar
	  (<emphasis>\|</emphasis>) allows you to match either of two
	  expressions. This is not useful for single characters,
	  because <emphasis>a\|b</emphasis> is equivalent to
	  <emphasis>[ab]</emphasis>, but it is very useful in
	  conjunction with grouping. Suppose that you would like an
	  expression that matches <emphasis>apple</emphasis> and
	  <emphasis>pear</emphasis>, but nothing else. This can be
	  done easily with the vertical bar:
	  <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>POSIX extended regular expressions</title>

	<para>
	  POSIX regular expressions build upon traditional regular
	  expressions, adding some other useful primitives. Another
	  comforting difference is that grouping parenthesises,
	  quantification accolades, and the alternation sign
	  (<emphasis>|</emphasis>) are not backslash-escaped.  If they
	  are escaped, they will match the literal characters instead,
	  thus resulting in the opposite behavior of traditional
	  regular expressions. Most people find POSIX extended regular
	  expressions much more comfortable, making them more widely
	  used.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	  <title>Matching characters</title>

	  <para>
	    Normal character matching has not changed compared to the
	    traditional regular expressions described in <xref
	    linkend="chap-textproc-regexps-traditional-characters" />
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Quantification</title>

	  <para>
	    Besides the Kleene star (<emphasis>*</emphasis>), that
	    matches the preceding character or group zero or more
	    times, POSIX extended regular expressions add two new
	    simple quantification primitives. The plus sign
	    (<emphasis>+</emphasis>) matches the preceding character
	    or group one or more times. For example,
	    <emphasis>a+</emphasis>, matches <emphasis>a</emphasis>
	    (or any string with more consecutive
	    <emphasis>a</emphasis>'s), but does not match zero
	    <emphasis>a</emphasis>'s. The questions mark character
	    (<emphasis>?</emphasis>) matches the preceding character
	    zero or one time. So, <emphasis>ba?d</emphasis> matches
	    <emphasis>bd</emphasis> and <emphasis>bad</emphasis>, but
	    not <emphasis>baad</emphasis> or <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Curly braces are used for repetition, like traditional
	    regular expressions. Though the backslash should be
	    omitted. To match <emphasis>ba</emphasis> and
	    <emphasis>baa</emphasis>, one should use
	    <emphasis>ba{1,2}</emphasis> rather than
	    <emphasis>ba\{1,2\}</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Grouping</title>

	  <para>
	    Grouping is done in the same manner as traditional regular
	    expressions, leaving out the escape-backslashes before the
	    parenthesises. For example, <emphasis>(ab){1,3}</emphasis>
	    matches <emphasis>ab</emphasis>,
	    <emphasis>abab</emphasis>, and
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	  <title>Alternation</title>

	  <para>
	    Alternation is done in the same manner as with traditional
	    regular expressions, leaving out the escape-backslashes
	    before the vertical bar. So,
	    <emphasis>(apple)|(pear)</emphasis> matches
	    <emphasis>apple</emphasis> and <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

      <!--
      <sect2 xml:id="chap-textproc-regexps-perl"> <title>Perl</title>
      </sect2>
    -->

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>

    <!-- XXX - document -c, -l, -x, -n, -q parameters -->

    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Basic grep usage</title>

      <para>
	We have now arrived at one of the most important utilties of
	the UNIX System, and the first occasion to try and use regular
	expressions. The <command>grep</command> command is used to
	search a text stream or a file for a pattern. This pattern is
	a regular expression, and can either be a basic regular
	expression or a POSIX extended regular expression (when the
	<parameter class="command">-E</parameter> parameter is
	used). By default, <command>grep</command> will write the
	lines that were matched to the standard output. In the most
	basic syntax, you can specify a regular expression as an
	argument, and <command>grep</command> will search matches in
	the text from the standard input. This is a nice manner to
	practice a bit with regular expressions.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	The example listed above shows a basic regular expression in
	action, that matches a line solely consisting of two or three
	times the <emphasis>ab</emphasis> string. You can do the same
	thing with POSIX extended regular expressions, by adding the
	<parameter class="command">-E</parameter> (for extended)
	parameter:
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Since the default behavior of <command>grep</command> is to
	read from the standard input, you can add it to a pipeline to
	get the interesting parts of the output of the preceding
	commands in the pipeline. For instance, if you would like to
	search for the string <emphasis>2006</emphasis> in the third
	column in a file, you could combine the <command>cut</command>
	and <command>grep</command> command:
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>grepping files</title>

      <para>
	Naturally, <command>grep</command> can also directly read a
	file, rather than the standard input. As usual, this is done
	by adding the files to be read as the last arguments. The
	following example will print all lines from the
	<filename>/etc/passwd</filename> file that start with the
	string <emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <!-- XXX - filename notation when multiple files are specified -->

      <para>
        With the <parameter class="command">-r</parameter> option,
	<command>grep</command> will recursively traverse a directory
	structure, trying to find matches in each file that was encountered
	during the traversal.
	Though, it is better to combine <command>grep</command> with
	<command>find</command> and the <emphasis>-exec</emphasis>
	operand in scripts that have to be portable.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	is the non-portable functional equivalent of
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Pattern behavior</title>

      <para>
	<command>grep</command> can also print all lines that do not
	match the pattern that was used.  This is done by adding the
	<parameter class="command">-v</parameter> parameter:
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	If you want to use the pattern in a case-insensitive manner,
	you can add the <parameter class="command">-i</parameter>
	parameter. For example:
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	You can also match a string literally with the <parameter
	class="command">-F</parameter> parameter:
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Using multiple patterns</title>

      <para>
	As we have seen, you can use the alternation character
	(<emphasis>|</emphasis>) to match either of two or more
	subpatterns. If two patterns that you would like to match
	differ a lot, it is often more comfortable to make two
	separate patterns. <command>grep</command> allows you to use
	more than one pattern by separating patterns with a newline
	character. So, for example, if you would like to print lines
	that match either the <emphasis>a</emphasis> or
	<emphasis>b</emphasis> pattern, this can be done easily by
	starting a new line:
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	This works, because quotes are used, and the shell passes
	quoted parameters literally. Though, it must be admitted that
	this is not quite pretty. <command>grep</command> accepts one
	or more <parameter class="command">-e pattern</parameter>
	parameters, giving the opportunity to specify more than one
	parameter on one line. The <command>grep</command> invocation
	in the previous example could be rewritten as:
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
