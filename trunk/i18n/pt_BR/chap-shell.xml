<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xml:id="chap-shell">
  <title>O shell</title>

  <sect1 xml:id="chap-shell-intro">
    <title>Introdução</title>

    <para>
      Neste capítulo iremos ver um ambiente tradicional em sistemas 
      UNIX: o shell. O shell é um interpretador que pode ser usado 
      interativamente e não-interativamente. Quando o shell é usado 
      não-interativamente, ele funciona como uma simples, porém 
      poderosa linguagem de script.
    </para>

    <para>
      O procedimento para começar com o shell depende se você loga 
      no sistema em modo gráfico ou em modo texto. Se você utiliza 
      o modo texto, o shell é imediatamente iniciado depois que você 
      digita a senha corretamente. Se você usa um gerenciador gráfico 
      de login como o KDM, faça o login como você faz normalmente e 
      procure no menu do seu gerenciador de janelas por um item 
      chamado <quote>XTerm</quote>, <quote>Terminal</quote> ou 
      <quote>Konsole</quote>. XTerm é um emulador de terminal que após 
      iniciado abre o shell.
    </para>

    <para>
      Antes de irmos adiante, temos que alertar você que o Slackware 
      Linux dispõe de mais de um shell. Há dois sabores de shell que 
      se tornaram populares ao longo do tempo, o Bourne shell e o 
      C shell. Neste capítulo iremos tratar do Bourne shells que 
      seguem o padrão IEEE 1003.1. Os shells Bash (Bourne Again Shell) 
      e ksh (Korn Shell) seguem bem este padrão. Então é uma boa idéia 
      utilizar um destes dois. Você pode facilmente ver qual o shell o 
      seu sistema está utilizando executando 
      <command>echo $SHELL</command>. Isto é o que um shell Bash irá 
      mostrar:
    </para>

    <screen>
$ <userinput>echo $SHELL</userinput>
/bin/bash
    </screen>
		
    <para>
      Se você está usando um shell diferente, você pode alterar o seu 
      shell padrão. Antes de mudar, você tem que saber o caminho 
      completo para o shell. Você pode fazer isso com o comando 
      <command>which</command>. Por exemplo:
    </para>

    <screen>
$ <userinput>which bash</userinput>
/bin/bash
$ <userinput>which ksh</userinput>
/bin/ksh
    </screen>

    <para>
      Neste sistema Slackware, o caminho completo do shell bash é 
      <filename>/bin/bash</filename>, e do shell ksh é 
      <filename>/bin/ksh</filename>. Com esta informação e o comando 
      <command>chsh</command> você pode mudar o seu shell padrão. O 
      exemplo seguinte irá definir o bash como shell padrão:
    </para>

    <screen>
$ <userinput>chsh -s /bin/bash</userinput>
Changing shell for daniel.
Password:
Shell changed.
    </screen>

    <para>
      O novo shell irá ser ativado após fechar a sessão do shell 
      atual (com <command>logout</command> ou <command>exit</command>), 
      ou abrindo outra janela de terminal se você estiver rodando o X11.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-executing">
    <title>Executando comandos</title>

    <para>
      Um shell interativo é usado para iniciar programas executando 
      um comando. Há dois tipos de comando que o shell pode iniciar:
    </para>

    <itemizedlist>
      <listitem>
	<para>
      <emphasis>Comandos embutidos:</emphasis> comandos embutidos 
      são integrados ao shell. Os mais comuns são:
	  <command>cd</command>, <command>fg</command>,
	  <command>bg</command>, e <command>jobs</command>.
	</para>
      </listitem>
      <listitem>
	<para>
      <emphasis>Comandos externos:</emphasis> comandos externos 
      são programas que não fazem parte do shell, e são guardados 
      em diretórios separados. Os mais comuns são:
	  <command>ls</command>, <command>cat</command>,
	  <command>rm</command>, e <command>mkdir</command>.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Todos os comandos shell são executados utilizando a mesma sintaxe:
    </para>
		
    <screen>
<command>nomedocomando [argumento1 argumento2 ... argumenton]</command>
    </screen>

    <para>
      O número de argumentos é arbitrário e sempre são passados para o 
      comando. O comando decide o que fazer com eles.
    </para>

    <para>
      Todos os comandos embutidos podem ser executados, porque eles 
      fazem parte do shell. Comando externos podem ser executados pelo 
      nome quando o programa está em um caminho que o shell procura. 
      Este caminho é armazenado em uma variável chamada 
      <emphasis>PATH</emphasis>. Uma variável é uma parte da memória 
      que possui um nome, e seu conteúdo pode ser alterado. Nós podemos 
      ver o conteúdo da variável PATH da seguinte maneira:
    </para>

    <screen>
$ <userinput>echo $PATH</userinput>
/usr/kerberos/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/daniel/bin
    </screen>

    <para>
      Os caminhos dos diretórios na variável <emphasis>PATH</emphasis> 
      são separados pelo caracter dois-pontos (<emphasis>:</emphasis>).
      Você pode usar o comando <commando>which</command> para verificar 
      se um comando está no caminho de pesquisa do shell atual. Você 
      pode fazer isto passando um argumento para o 
      <command>which</command>. Por exemplo:
    </para>

    <screen>
$ <userinput>which pwd</userinput>
/bin/pwd
$ <userinput>which sysstat</userinput>
/usr/bin/which: no sysstat in (/usr/kerberos/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/daniel/bin)
    </screen>

    <para>
      Se o programa não está no caminho de pesquisa, você pode 
      digitar o seu caminho absoluto ou relativo.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-moving">
    <title>Movimentando-se</title>

    <para>
      Muitas vezes, é necessário saltar por várias partes de uma linha, 
      e então alterá-la, quando você está editando comandos longos. 
      Ambos <command>bash</command> and <command>ksh</command> possuem 
      atalhos para operações comuns. Há dois modos no shell, em que os 
      atalhos diferem. Estes modos correspondem em seu comportamento à 
      dois populares editores do UNIX. Os editores são o <command>vi</command> 
      e o <command>emacs</command>. Neste livro nós iremos apenas ver 
      os atalhos correspondentes ao modo EMACS. Você pode ver qual o 
      modo que o seu shell está rodando imprimindo a variável 
      <emphasis>SHELLOPTS</emphasis>. Neste primeiro exemplo o shell 
      é utilizado no modo <emphasis>emacs</emphasis>, e no segundo 
      é utilizado o modo <emphasis>vi</emphasis>. Você pode verificar 
      o modo utilizado procurando por <emphasis>emacs</emphasis> ou 
      <emphasis>vi</emphasis> no conteúdo da variável.
    </para>

    <screen>
$ <userinput>echo $SHELLOPTS</userinput>
braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
    </screen>

    <screen>
$ <userinput>echo $SHELLOPTS</userinput>
braceexpand:hashall:histexpand:history:interactive-comments:monitor:vi
    </screen>

    <para>
      Se o seu shell estiver utilizando o modo <emphasis>vi</emphasis>, 
      você pode mudar para o modo <emphasis>emacs</emphasis> setando a 
      opção <emphasis>emacs</emphasis>:
    </para>

    <screen>
$ <userinput>set -o emacs</userinput>
    </screen>

    <para>
      Com o modo de edição <emphasis>emacs</emphasis> habilitado, você pode
      começar a usar atalhos.  Vamos ver aqui três tipos de atalhos: atalhos
      edição de caracter, atalhos de edição de palavra, e atalhos de edição de
      linha.  Posteriormente neste capítulo, vamos ver também alguns atalhos
      que são usados para obter entradas a partir do histórico de comandos.
    </para>

    <sect2 xml:id="chap-shell-moving-char">
      <title>Edição de caracter</title>

      <para>
       O primeiro grupo de atalhos usam caracteres como sua unidade lógica,
       significando que eles lhe permitem operações de edição de caracteres em
       linha de comando.  <xref
       linkend="chap-shell-moving-char-shortcuts-move" /> dá uma visão geral
       dos atalhos que podem ser usados para se movimentar em uma linha a
       distância de alguns caracteres.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-move">
	<title>Movimentando-se por um caracter</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-b</entry>
	      <entry>Move-se um caracter para trás.</entry>
	    </row>
	    <row>
	      <entry>Ctrl-f</entry>
	      <entry>Move-se um caracter para frente.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Esses atalhos são simples, e não fazem nada de inesperado.  Suponha que
       você tenha digitado a seguinte linha:
      </para>

      <screen>
find ~/music -name '*.ogg' - -print<emphasis role="cursor">&#32;</emphasis>
      </screen>

      <para>
       O cursor estará ao final.  Agora você pode mover-se para o começo da linha
       segurando <emphasis>Ctrl-b</emphasis>:
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music - -name '*.ogg' -print
      </screen>

      <para>
       Da mesma forma, você também pode retornar ao final da linha segurando 
       <emphasis>Ctrl-f</emphasis>.  Há um erro nessa linha, pois há um hífen
       incorreto.  Para remover este hífem, você pode usar um dos atalhos de
       exclusão de caracter.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-delete">
	<title>Excluindo caracteres</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-h</entry>
          <entry>Exclui um caracter antes do cursor.  Isto tem o mesmo efeito
             de se usar a tecla Backspace na maioria dos computadores
             pessoais.</entry>
	    </row>
	    <row>
	      <entry>Ctrl-d</entry>
	      <entry>Exclui o caracter que está sob o cursor.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Você pode excluir o hífem de duas maneiras.  A primeira é mover o cursor
       até o hífen:
      </para>

      <screen>
find ~/music <emphasis role="cursor">-</emphasis> -name '*.ogg' -print
      </screen>

      <para>
       e então pressionar <emphasis>Ctrl-d</emphasis> duas vezes.  Isto irá
       excluir o caracter hífem e o espaço logo após ele:
      </para>

      <screen>
find ~/music <emphasis role="cursor">-</emphasis>name '*.ogg' -print
      </screen>

      <para>
       Olhando para o fragmento original, a outra maneira de fazer a mesma coisa é
       posicionar o cursor no espaço após o hífem:
      </para>

      <screen>
find ~/music -<emphasis role="cursor">&#32;</emphasis> -name '*.ogg' -print
      </screen>

      <para>
       e então pressionar <emphasis>Ctrl-h</emphasis> duas vezes para excluir os
       dois caracteres anteriores, o hífem em si e o espaço imediatamente
       anterior.  O resultado será o mesmo, exceto pela movimentação do cursor:
      </para>

      <screen>
find ~/music<emphasis role="cursor">&#32;</emphasis>-name '*.ogg' -print
      </screen>

      <para>
       Uma das melhores características da maioria dos shells modernos é que você
       pode transpor (trocar) caracteres.  Isso é útil se você teve um erro de
       digitação invertendo dois caracteres.  <xref
       linkend="chap-shell-moving-char-shortcuts-swap" /> lista o atalho para
       transposição de caracteres.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-swap">
	<title>Trocando caracteres</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-t</entry>
          <entry>Troca (transpõe) o caracter que está sob o cursor, e o
          caracter imediatamente antes do cursor.  Isso é útil para corrigir
          erros de digitação rapidamente.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Suponha que você tenha digitado o seguinte comando:
      </para>

      <screen>
cat myreport.ttx
      </screen>

      <para>
       A extensão contém um erro de digitação se você pretendia executar
       <command>cat</command> <filename>myreport.txt</filename>.  Isto pode ser
       corrigido com o atalho de transposição de caracteres.  Primeiro, mova-se
       para o segundo caracter dos dois que estão trocados:
      </para>

      <screen>
cat myreport.tt<emphasis role="cursor">x</emphasis>
      </screen>

      <para>
       Agora você pode pressionar <emphasis>Ctrl-t</emphasis>.  Os caracteres
       serão trocados, e o cursor se posicionará após os caracteres que foram
       trocados:
      </para>

      <screen>
cat myreport.txt<emphasis role="cursor">&#32;</emphasis>
      </screen>
    </sect2>

    <sect2 xml:id="chap-shell-moving-word">
      <title>Edição de palavra</title>

      <para>
       Na maioria das vezes é muito tedioso se mover em nível de caracter.
       Felizmente os shell Korn e Bash também permitem movimentações em nível
       de palavras.  Palavras são sequências de caracteres separadas por um
       caracter especial, como um espaço em branco.  <xref
       linkend="chap-shell-moving-word-shortcuts-move" /> resume os atalhos que
       podem ser usados para mover-se pelas palavras de uma linha.
      </para>

      <table xml:id="chap-shell-moving-word-shortcuts-move">
	<title>Movendo-se uma palavra</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Esc b</entry>
	      <entry>
		Move-se de volta para o começo da palavra atual ou da anterior.
	      </entry>
	    </row>
	    <row>
	      <entry>Esc f</entry>
	      <entry>
		Avança para o último caracter da palavra atual ou da próxima palavra.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Como você pode ver, as letras nesses atalhos são iguais àquelas da
       movimentação para frente e para trás em nível de caracter.  A lógica de
       movimentação é um pouco curiosa.  Mover-se para frente coloca o cursor
       ao final da palavra atual, e não no primeiro caracter da próxima palavra
       como você poderia supor.  Vamos ver um breve exemplo.  No início, o
       cursor está no primeiro caracter da linha.
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music -name '*.ogg' -print
      </screen>

      <para>
       Digitar <emphasis>Esc f</emphasis> irá mover o cursor para depois do
       último caracter da primeira palavra, que neste caso é
       <emphasis>find</emphasis>:
      </para>

      <screen>
find<emphasis role="cursor">&#32;</emphasis>~/music -name '*.ogg' -print
      </screen>

      <para>
       Avançar mais uma vez irá posicionar o cursor depois de
       <emphasis>~/music</emphasis>:
      </para>

      <screen>
find ~/music<emphasis role="cursor">&#32;</emphasis>-name '*.ogg' -print
      </screen>

      <para>
       Um movimento para trás pôe o cursor no primeiro caracter da palavra
       atual, ou no primeiro caracter da palavra anterior se no momento o
       cursor estiver no primeiro caracter da palavra.  Então, mover-se uma
       palavra para trás no exemplo anterior irá pôr o cursor na primeira letra
       de <quote>music</quote>:
      </para>

      <screen>
find ~/<emphasis role="cursor">m</emphasis>usic -name '*.ogg' -print
      </screen>

      <para>
       Excluir palavras funciona da mesma forma que se mover pelas palavras,
       sendo que os caracteres que são encontrados são excluídos.  <xref
       linkend="chap-shell-moving-word-shortcuts-delete" /> lista os atalhos
       usados para excluir palavras.
      </para>

      <table  xml:id="chap-shell-moving-word-shortcuts-delete">
	<title>Excluindo palavras</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		Alt-d
	      </entry>
	      <entry>
		Exclui a palavra, a partir da posição atual do cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>
		Alt-Backspace
	      </entry>
	      <entry>
		Exclui cada caracter a partir da posição atual do cursor até o primeiro
		caracter que é encontrado na palavra.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Finalmente, há alguns atalhos que são úteis para manipular palavras.
       Esses atalhos estão listados em <xref
       linkend="chap-shell-moving-word-shortcuts-modify" />.
      </para>

      <table  xml:id="chap-shell-moving-word-shortcuts-modify">
	<title>Modificando palavras</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Alt-t</entry>
	      <entry>
		Troca (transpôe) a palavra atual pela palavra anterior.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-u</entry>
	      <entry>
		Converte a palavra para maiúsculas, a partir da posição atual do 
		cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-l</entry>
	      <entry>
		Converte a palavra para minúsculas, a partir da posição atual do
		cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-c</entry>
	      <entry>
		Capitaliza (deixa a inicial em caixa alta) a palavra atual ou o próximo
		caracter encontrado na palavra.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Transposição é uma troca de palavras.  Se palavras normais são usadas, é
       um comportamento predizível.  Por exemplo, se tivermos a linha a seguir
       com o cursor em <quote>two</quote>
      </para>

      <screen>
one <emphasis role="cursor">t</emphasis>wo three
      </screen>

      <para>
       A transposição irá permutar as palavras <quote>two</quote> e
       <quote>one</quote>:
      </para>

      <screen>
two one three
      </screen>

      <para>
       Mas se houver caracteres não-alfabéticos, o shell irá trocar a palavra
       com sua anterior preservando a ordem dos caracteres não-alfabéticos.
       Isso é muito adequado para editar argumentos para comandos.  Suponha que
       você tenha se enganado, trocando a extensão do arquivo que você queria
       procurar e o parâmetro <emphasis>print</emphasis>:
      </para>

      <screen>
find ~/music -name '*.print' -ogg
      </screen>

      <para>
       Você pode corrigir isto colocando o cursor na segunda palavra
       problemática (neste caso, <quote>ogg</quote>) e transpondo as duas
       palavras.  Isto irá resultar no que efetivamente queríamos:
      </para>

      <screen>
find ~/music -name '*.ogg' -print
      </screen>

      <para>
       Finalmente, há alguns atalhos que trocam a capitalização de palavras.  O
       atalho Alt-u deixa todos os caracteres em maiúsculas, desde a posição
       atual do cursor até o final da palavra.  Então, se nós tivermos o nome
       <quote>alice</quote> em minúsculas, deixar o nome em maiúsculas, com o
       cursor em <quote>i</quote> resultará em <quote>alICE</quote>.  Alt-l tem
       o mesmo comportamento, mas troca as letras para minúsculas.  Então,
       usar Alt-l em <quote>alICE</quote> com o cursor em <quote>I</quote> irá
       resultar na string <quote>alice</quote>.  Alt-c troca apenas o caracter
       no qual o cursor estiver, ou o caracter inicial da próxima palavra
       encontrada para maiúsculas.  Por exemplo, pressionando-se Alt-c com o
       cursor no <quote>a</quote> de <quote>alice</quote> irá resultar em
       <quote>Alice</quote>.
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-moving-line">
      <title>Edição de linha</title>

      <para>
       O nível mais alto de edição que podemos ter é editar a própria linha de
       comando em si.  <xref linkend="chap-shell-moving-line-shortcuts-move" />
       relaciona os dois atalhos para movimentação em nível de linha.
      </para>

      <table xml:id="chap-shell-moving-line-shortcuts-move">
	<title>Movendo-se por linhas</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-a</entry>
	      <entry>
		Move-se para o começo da linha atual.
	      </entry>
	    </row>
	    <row>
	      <entry>Ctrl-e</entry>
	      <entry>
		Move-se para o final da linha atual.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
       Suponha que o cursor esteja em algum lugar no meio de uma linha de
       comando:
      </para>

      <screen>
find ~/music -name<emphasis role="cursor">&#32;</emphasis>'*.ogg' -print
      </screen>

      <para>
       Pressionando-se Ctrl-e uma vez irá mover o cursor para o final da linha
       de comando:
      </para>

      <screen>
find ~/music -name '*.ogg' -print<emphasis role="cursor">&#32;</emphasis>
      </screen>

      <para>
       Pressionar Ctrl-a irá mover o cursor para o começo da linha:
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music -name '*.ogg' -print
      </screen>

      <para>
       Você também pode excluir caracteres em nível de linha.  Os atalhos estão
       listados em <xref linkend="chap-shell-moving-line-shortcuts-delete" />.
       Esses atalhos funcionam como os de movimentação, mas excluem todos os
       caracteres que forem encontrados.  Ctrl-k irá excluir o caracter sob o
       cursor, mas Ctrl-x Backspace não.  Mover-se para o começo da linha com
       Ctrl-a, seguido de um Ctrl-k, é um truque rápido para remover a linha
       completamente.
      </para>

      <table xml:id="chap-shell-moving-line-shortcuts-delete">
	<title>Excluindo linhas</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-k</entry>
	      <entry>
		Exclui todos os caracteres na linha, a partir da posição do cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>Ctrl-x Backspace</entry>
	      <entry>
		Exclui todos os caractres na linha até a posição atual do cursor.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-shell-history">
    <title>Histórico de comandos</title>

    <para>
      É muito comum você ter que executar comandos que já tinha executado
      anteriormente.  Felizmente, você não precisa digitá-los todos de novo.
      Você sempre pode navegar pelo histórico de comandos executados com as
      teclas de seta para cima e seta para baixo.  Além disso, também é
      possível procurar por um comando.  Pressione Control-r e comece a digitar
      o comando que você quer executar.  Você irá perceber que o bash irá
      mostrar a primeira correspondência que puder encontrar no histórico de
      comandos.  Se isso não resultar no comando que você estava procurando
      você pode continuar digitando o comando (até que um resultado único
      apareça), ou pressionar Control-r mais uma vez para obter a próxima
      ocorrência.  Quando você tiver encontrado o comando pelo qual estava
      procurando, você pode executá-lo pressionando &lt;Enter&gt;.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-completion">
    <title>Completion</title>

    <para>
      Completion is one of the most useful functionalities of
      UNIX-like shells.  Suppose that you have a directory with two
      files named <filename>websites</filename> and
      <filename>recipe</filename>. And suppose you want to
      <command>cat</command> the file <filename>websites</filename>
      (<command>cat</command> shows the contents of a file), by
      specifying <filename>websites</filename> as a parameter to
      cat. Normally you would type <quote>cat websites</quote>, and
      execute the command. Try typing <quote>cat w</quote>, and hit
      the &lt;Tab&gt; key. Bash will automatically expand what you
      typed to <quote>cat websites</quote>.
    </para>

    <para>
      But what happens if you have files that start with the same
      letter? Suppose that you have the
      <filename>recipe1.txt</filename> and
      <filename>recipe2.txt</filename> files. Type <quote>cat
      r</quote> and hit &lt;Tab&gt;, Bash will complete the filename
      as far as it can. It would leave you with <quote>cat
      recipe</quote>. Try hitting &lt;Tab&gt; again, and Bash will
      show you a list of filenames that start with
      <quote>recipe</quote>, in this case both recipe files. At this
      point you have to help Bash by typing the next character of the
      file you need.  Suppose you want to <command>cat</command>
      <filename>recipe2</filename>, you can push the &lt;2&gt;
      key. After that there are no problems completing the filename,
      and hitting &lt;Tab&gt; completes the command to <quote>cat
      recipe2.txt</quote>.
    </para>

    <para>
      It is worth noting that completion also works with
      commands. Most GNU/Linux commands are quite short, so it will
      not be of much use most of the time.
    </para>

    <para>
      It is a good idea to practice a bit with completion, it can save
      alot of keystrokes if you can handle completion well. You can
      make some empty files to practice with using the
      <command>touch</command> command.  For example, to make a file
      named <filename>recipe3.txt</filename>, execute <command>touch
      recipe3.txt</command>.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-wildcards">
    <title>Wildcards</title>

    <para>
      Most shells, including Bash and ksh, support
      wildcards. Wildcards are special characters that can be used to
      do pattern matching. The table listed below displays some
      commonly used wildcards. We are going to look at several
      examples to give a general idea how wildcards work.
    </para>

    <table xml:id="chap-shell-wildcards-thewildcards">
      <title>Bash wildcards</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
	<thead>
	  <row>
	    <entry>Wildcard</entry> <entry>Matches</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>*</entry>
	    <entry>A string of characters</entry>
	  </row>
	  <row>
	    <entry>?</entry>
	    <entry>A single character</entry>
	  </row>
	  <row>
	    <entry>[]</entry>
	    <entry>A character in an array of characters</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <sect2 xml:id="chap-shell-wildcards-string">
      <title>Matching a string of characters</title>

      <para>
	As you can see in the table above the <quote>*</quote>
	character matches a string of characters. For example,
	<emphasis>*.html</emphasis> matches everything ending with
	<emphasis>.html</emphasis>, <emphasis>d*.html</emphasis>
	matches everything starting with a <emphasis>d</emphasis> and
	ending with <emphasis>.html</emphasis>.
      </para>

      <para>
	Suppose that you would like to list all files in the current
	directory with the <emphasis>.html</emphasis> extension, the
	following command will do the job:
      </para>

      <screen>
$ <userinput>ls *.html</userinput>
book.html        installation.html     pkgmgmt.html  usermgmt.html
filesystem.html  internet.html         printer.html  xfree86.html
gfdl.html        introduction.html     proc.html
help.html        slackware-basics.html shell.html
      </screen>

      <para>
	Likewise we could remove all files starting with an
	<emphasis>in</emphasis>:
      </para>

      <screen>
$ <userinput>rm in*</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-shell-wildcards-single">
      <title>Matching single characters</title>

      <para>
	The <quote>?</quote> wildcard works as the <quote>*</quote>
	wildcard, but matches single characters. Suppose that we have
	three files, <filename>file1.txt</filename>,
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>. The string
	<emphasis>file?.txt</emphasis> matches all three of these
	files, but it does not match <filename>file10.txt</filename>
	(<quote>10</quote> are two characters).
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-wildcards-set">
      <title>Matching characters from a set</title>

      <para>
	The <quote>[]</quote> wildcard matches every character between
	the brackets.  Suppose we have the files from the previous
	example, <filename>file1.txt</filename>,
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>. The string
	<emphasis>file[23].txt</emphasis> matches
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>, but not
	<filename>file1.txt</filename>.
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-shell-inout">
    <title>Redirections and pipes</title>

    <para>
      One of the main features of UNIX-like shells are redirections
      and pipes.  Before we start to look at both techniques we have
      to look how most UNIX-like commands work. When a command is not
      getting data from a file, it will open a special pseudo-file
      named <emphasis>stdin</emphasis>, and wait for data to appear on
      it. The same principle can be applied for command output, when
      there is no explicit reason for saving output to a file, the
      pseudo-file <emphasis>stdout</emphasis> will be opened for
      output of data. This principle is shown schematically in <xref
      linkend="fig-shell-inout" />
    </para>

    <figure xml:id="fig-shell-inout">
      <title>Standard input and output</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../images/shell-inout.png" format="PNG"/>
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      You can see <emphasis>stdin</emphasis> and
      <emphasis>stdout</emphasis> in action with the
      <command>cat</command> command. If cat is started without any
      parameters it will just wait for input on
      <emphasis>stdin</emphasis> and output the same data on
      <emphasis>stdout</emphasis>. If no redirection is used keyboard
      input will be used for <emphasis>stdin</emphasis>, and
      <emphasis>stdout</emphasis> output will be printed to the
      terminal:
    </para>

    <screen>
$ <userinput>cat</userinput>
<command>Hello world!</command>
Hello world!
    </screen>

    <para>
      As you can see cat will print data to
      <emphasis>stdout</emphasis> after inputting data to
      <emphasis>stdin</emphasis> using the keyboard.
    </para>

    <sect2 xml:id="chap-shell-inout-redir">
      <title>Redirection</title>

      <para>
	The shell allows you to take use of <emphasis>stdin</emphasis>
	and <emphasis>stdout</emphasis> using the <quote>&lt;</quote>
	and <quote>&gt;</quote>. Data is redirected in which way the
	sharp bracket points. In the following example we will
	redirect the md5 summaries calculated for a set of files to a
	file named <filename>md5sums</filename>:
      </para>

      <screen>
$ <userinput>md5sum * &gt; md5sums</userinput>
$ <userinput>cat md5sums</userinput> 
6be249ef5cacb10014740f61793734a8  test1
220d2cc4d5d5fed2aa52f0f48da38ebe  test2
631172a1cfca3c7cf9e8d0a16e6e8cfe  test3
      </screen>

      <para>
	As we can see in the <command>cat</command> output the output
	of the <command>md5sum *</command> output was redirected to
	the <filename>md5sums</filename> file. We can also use
	redirection to provide input to a command:
      </para>

      <screen>
$ <userinput>md5sum &lt; test1</userinput>
6be249ef5cacb10014740f61793734a8  -
      </screen>

      <para>
	This feeds the contents of the <filename>test1</filename> to
	<command>md5sum</command>.
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-inout-pipes">
      <title>Pipes</title>

      <para>
	You can also connect the input and output of commands using
	so-called <emphasis>pipes</emphasis>. A pipe between commands
	can be made with the <quote>|</quote> character. Two or more
	combined commands are called a
	<emphasis>pipeline</emphasis>. <xref
	linkend="fig-shell-pipeline" /> shows a schematic overview of
	a pipeline consisting of two commands.
      </para>

      <figure xml:id="fig-shell-pipeline">
	<title>A pipeline</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="../images/shell-pipeline.png" format="PNG"/>
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The <quote>syntax</quote> of a pipeline is: <command>command1
	| command2 ... | commandn</command>. If you know how the most
	basic UNIX-like commands work you can now let these commands
	work together. Let's look at a quick example:
      </para>

      <screen>
$ <userinput>cat /usr/share/dict/american-english | grep "aba" | wc -l</userinput>
123
      </screen>

      <para>
	The first command, <command>cat</command>, reads the
	dictionary file
	<filename>/usr/share/dict/american-english</filename>. The
	output of the <command>cat</command> command is piped to
	<command>grep</command>, which prints out all files containing
	the phrase <quote>aba</quote>.  In turn, the output of
	<quote>grep</quote> is piped to <command>wc -l</command>,
	which counts the number of lines it receives from
	<emphasis>stdin</emphasis>. Finally, when the stream is
	finished <command>wc</command> prints the number of lines it
	counted. So, combined three commands to count the number of
	words containing the phrase <quote>aba</quote> in this
	particular dictionary.
      </para>

      <para>
	There are hundreds of small utilities that handle specific
	tasks. As you can imagine, together these commands provide a
	very powerful toolbox by making combinations using pipes.
      </para>
    </sect2>
  </sect1>
</chapter>
