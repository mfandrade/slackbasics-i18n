<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
     xml:lang="en" xml:id="kernel">
  <title>Construindo um kernel</title>

  <sect1 xml:id="chap-kernel-intro">
    <title>Introdução</title>

    <para>
      O kernel Linux é brevemente apresentado em <xref
      linkend="chap-intro-linux" />.  Uma das vantagens do Linux é que
      os fontes completos estão disponíveis (bem como todo o sistema
      Slackware Linux).  Isto quer dizer que você pode recompilar o
      kernel.  Há muitas situações em que é útil recompilar o kernel.
      Por exemplo:
    </para>

    <itemizedlist>
      <listitem>
    <para>
      <emphasis role="bold">Deixar o kernel mais enxuto</emphasis>:
      Você pode desabilitar algumas funcionalidades do kernel para
      reduzir seu tamanho.  Isso é especialmente útil em ambiente em
      que a memória seja escassa.
    </para>
      </listitem>
      <listitem>
    <para>
      <emphasis role="bold">Otimizar o kernel</emphasis>: é possível
      otimizar o kernel.  Por exemplo, compilando-o para seu tipo
      específico de processador.
    </para>
      </listitem>
      <listitem>
    <para>
      <emphasis role="bold">Suporte de hardware</emphasis>: o suporte
      para alguns hardwares não está disponível no kernel padrão
      provido pelo Slackware Linux.  Um exemplo comum é o suporte a
      sistemas SMP.
    </para>
      </listitem>
      <listitem>
    <para>
      <emphasis role="bold">Utilizar patches específicos</emphasis>: há
      muitos patches não-oficiais para o kernel Linux.  Falando de uma
      forma geral, é uma boa idéia evitar patches não-oficiais.  Mas
      alguns softwares de terceiros, como o <ulink
      url="http://www.netraverse.com">Win4Lin</ulink>, podem precisar
      que você instale patches adicionais no kernel.
    </para>
      </listitem>
      <listitem>
    <para>
      Pegue os cabeçalhos apropriados e construa a infraestrutura
      disponível para construir módulos de terceiros.
    </para>
      </listitem>
    </itemizedlist>

    <para>
      Este capítulo foca na série do kernel padrão usado no Slackware
      Linux 12.0, que é o Linux 2.6.  Compilar um kernel não é realmente
      difícil, apenas mantenha sempre um kernel de backup que você possa
      usar quando algo der errado.  A compilação do Linux envolve os
      seguintes passos:
    </para>

    <itemizedlist>
      <listitem>
    <para>
      Configurar o kernel.
    </para>
      </listitem>
      <listitem>
    <para>
      Construir o kernel.
    </para>
      </listitem>
      <listitem>
    <para>
      Construir os modules.
    </para>
      </listitem>
      <listitem>
    <para>
      Instalar o kernel e os módulos.
    </para>
      </listitem>
      <listitem>
    <para>
      Atualizar a configuração do LILO.
    </para>
      </listitem>
    </itemizedlist>

    <para>
      Neste capítulo, supomos que os fontes do kernel já estão
      disponíveis em <filename>/usr/src/linux</filename>.  Se você
      instalou os fontes do kernel a partir da série <quote>k</quote>,
      os fontes do kernel estão disponíveis em
      <filename>/usr/src/linux-kernelversion</filename>, e
      <filename>/usr/src/linux</filename> é um link simbólico para o
      diretório real dos fontes do kernel.  Então, se você usar os
      padrões do Slackware Linux, o pacote de kernel que você configurar
      estará pronto para usar.
    </para>

    <para>
      Diferente das versões mais antigas do kernel, não é mais necesário
      usar um link simbólico <filename>/usr/src/linux</filename>.  Se
      você extraiu os fontes do kernel em <filename>/usr/src</filename>,
      você pode construir o kernel em
      <filename>/usr/src/linux-&lt;version&gt;</filename>, e usar esse
      diretório para os exemplos neste capítulo.
    </para>
  </sect1>

  <sect1 xml:id="chap-kernel-build">
    <title>Configuration</title>

    <para>
      As laid out above, the first step is to configure the kernel
      source. To ease the configuration of the kernel, it is a good
      idea to copy the default Slackware Linux kernel configuration to
      the kernel sources. The Slackware Linux kernel configuration
      files are stored on the distribution medium as
      <filename>kernels/&lt;kernelname&gt;/config</filename>. Suppose
      that you want to use the <filename>hugesmp.s</filename> kernel
      configuration as a starting point (which is the default kernel),
      and that you have a Slackware Linux CD-ROM mounted at
      <filename>/mnt/cdrom</filename>, you can copy the Slackware
      Linux kernel configuration with:
    </para>

    <screen>
# <userinput>cp /mnt/cdrom/kernels/hugesmp.s/config /usr/src/linux/.config</userinput>
    </screen>

    <para>
      The kernel configuration of a running kernel can also be
      retrieved as <filename>/proc/config.gz</filename> if the kernel
      was compiled with the <emphasis>CONFIG_IKCONFIG</emphasis> and
      <emphasis>CONFIG_IKCONFIG_PROC</emphasis> options. The default
      Slackware Linux kernels have these options enabled. So, if you
      would like to use the configuration of the running kernel, you
      could run:
    </para>

    <screen>
# <userinput>zcat /proc/config.gz > /usr/src/linux/.config</userinput>
    </screen>

    <para>
      If you are using a configuration file that is for another kernel
      version than you are currently compiling, it is likely that both
      kernel versions do not have the same set of options. New options
      are often added (e.g., because newer drivers are added), and
      sometimes kernel components are removed. You can configure new
      options (and remove unused options) with the <command>make
      oldconfig</command> command:
    </para>

    <para>
# <userinput>cd /usr/src/linux ; make oldconfig</userinput>
    </para>

    <para>
      This will ask you for options whether you would like to compile
      in support (<emphasis>Y</emphasis>), compile support as a module
      (<emphasis>M</emphasis>), or not include support
      (<emphasis>N</emphasis>). For example:
    </para>

    <screen>
IBM ThinkPad Laptop Extras (ACPI_IBM) [N/m/y/?] (NEW)
    </screen>

    <para>
      As you can see, the possible options are shown, with the default
      choice as a capital. If you just press &lt;Enter&gt;, the
      capitalized option will be used. If you want more information
      about an option, you can enter the question mark
      (<emphasis>?</emphasis>):
    </para>

    <screen>
    IBM ThinkPad Laptop Extras (ACPI_IBM) [N/m/y/?] (NEW) <userinput>?</userinput>

This is a Linux ACPI driver for the IBM ThinkPad laptops. It adds
support for Fn-Fx key combinations, Bluetooth control, video
output switching, ThinkLight control, UltraBay eject and more.
For more information about this driver see &lt;file:Documentation/ibm-acpi.txt&gt;
and &lt;http://ibm-acpi.sf.net/&gt; .

If you have an IBM ThinkPad laptop, say Y or M here.

    IBM ThinkPad Laptop Extras (ACPI_IBM) [N/m/y/?] (NEW)
    </screen>

    <para>
      The output of this command can be a bit verbose, because the
      options that were used in the configuration file, and are
      available in the running kernel are also shown, but their
      configuration will be filled in automatically based on the
      configuration file.
    </para>

    <para>
      At this point you can start to actually configure the kernel in
      detail. There are three configuration front-ends to the kernel
      configuration. The first one is <parameter
      class="command">config</parameter>, which just asks you what you
      want to do for each kernel option. This takes a lot of time. So,
      normally this is not a good way to configure the kernel. A more
      user friendly approach is the <parameter
      class="command">menuconfig</parameter> front-end, which uses a
      menuing system that you can use to configure the kernel. There
      is an X front-end as well, named <parameter
      class="command">xconfig</parameter>. You can start a
      configuration front-end by changing to the kernel source
      directory, and executing <command>make
      &lt;front-end&gt;</command>. For example, to configure the
      kernel with the menu front-end you can use the following
      commands:
    </para>

    <screen>
# <userinput>cd /usr/src/linux</userinput>
# <userinput>make menuconfig</userinput>
    </screen>

    <para>
      Of course, if you prefer, you can also edit the
      <filename>.config</filename> file directly with your favorite
      text editor.
    </para>

    <para>
      As we have seen briefly before, in the kernel configuration
      there are basically three options for each choice:
      <quote>n</quote> disables functionality, <quote>y</quote>
      enables functionality, and <quote>m</quote> compiles the
      functionality as a module. The default Slackware Linux kernel
      configuration is a very good configuration, it includes the
      support for most common disk controllers and filesystems, the
      rest is compiled as a module. Whatever choices you make, you
      need to make sure that both the driver for the disk controller
      and support for the filesystem type holding your root filesystem
      is included. When they are not, the kernel will not able to
      mount the root filesystem, and the kernel will panic because it
      can not hand over initialization to the <command>init</command>
      program.
    </para>

    <note>
      <para>
    It is always a good idea to keep your old kernel in modules
    around, in the case that you have made a configuration error.
    If the to be compiled kernel has the same version number as
    the running kernel, you should seriously consider modifying
    the <emphasis>CONFIG_LOCALVERSION</emphasis> option. The
    string specified in this option is appended to the version
    name. For example, if the kernel has version 2.6.21.6, and
    <emphasis>CONFIG_LOCALVERSION</emphasis> is set to
    <emphasis>"-smp-ddk"</emphasis>, the kernel version will be
    <emphasis>2.6.21.6-smp-ddk</emphasis>.
      </para>

      <para>
    If you don't modify the version in this manner, the
    installation of modules from the new kernel will overwrite the
    modules from the running kernel. This is highly uncomfortable
    if you need to fall back to the old kernel.
      </para>
    </note>
  </sect1>

  <sect1 xml:id="chap-kernel-compile">
    <title>Compilation</title>

    <para>
      The kernel compilation used to consist of multiple steps, but
      2.6 Linux kernels can be compiled be executing <command>make</command>
      in the kernel source directory. This will calculate dependencies,
      build the kernel, and will build and link kernel modules.
    </para>

    <screen>
# <userinput>cd /usr/src/linux</userinput>
# <userinput>make</userinput>
    </screen>

    <para>
      After the compilation is finished, the tree contains the
      compiled modules, and a compressed kernel image named
      <filename>bzImage</filename> in
      <filename>/usr/src/linux/arch/i386/boot</filename>. You can now
      continue with the installation of the kernel and its modules.
    </para>
  </sect1>

  <sect1 xml:id="chap-kernel-install">
    <title>Installation</title>

    <sect2 xml:id="chap-kernel-install-kernel">
      <title>Installing the kernel</title>

      <para>
    The next step is to install the kernel and the kernel modules.
    We will start with installing the kernel modules, because this
    can be done with one command within the kernel source tree:
      </para>

      <screen>
# <userinput>make modules_install</userinput>
      </screen>

      <para>
    This will install the modules in
    <filename>/lib/modules/&lt;kernelversion&gt;</filename>. If
    you are replacing a kernel with the exactly the same version
    number, it is a good idea to remove the old modules before
    installing the new ones. E.g.:
      </para>

      <screen>
# <userinput>rm -rf /lib/modules/2.6.21.5-smp</userinput>
      </screen>

      <para>
    You can <quote>install</quote> the kernel by copying it to the
    <filename>/boot</filename> directory. You can give it any name
    you want, but it is a good idea to use some naming
    convention. E.g.  <filename>vmlinuz-version</filename>. For
    instance, if you name it
    <filename>vmlinuz-2.6.21.5-smp-ddk</filename>, you can copy it
    from within the kernel source tree with:
      </para>

      <screen>
# <userinput>cp arch/i386/boot/bzImage /boot/vmlinuz-2.6.21.5-smp-ddk</userinput>
      </screen>

      <para>
    At this point you are almost finished. The last step is to add
    the new kernel to the Linux boot loader (LILO) configuration.
      </para>
    </sect2>

    <sect2 xml:id="chap-kernel-install-lilo">
      <title>Configuring LILO</title>

      <para>
        <acronym>LILO</acronym> (Linux Loader) is the default boot
        loader that Slackware Linux uses. The configuration of LILO
        works in two steps; the first step is to alter the LILO
        configuration in <filename>/etc/lilo.conf</filename>. The
        second step is to run the <command>lilo</command>, which will
        write the LILO configuration to the boot loader. The LILO
        configuration already has an entry for the current kernel you
        are running. It is a good idea to keep this entry, as a
        fall-back option if your new kernel does not work. If you
        scroll down to the bottom of
        <filename>/etc/lilo.conf</filename> you will see this entry,
        it looks comparable to this:
      </para>

      <screen>
# Linux bootable partition config begins
image = /boot/vmlinuz
  root = /dev/hda5
  label = Slack
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
# Linux bootable partition config ends
      </screen>

      <para>
        The easiest way to add the new kernel is to duplicate the
        existing entry, and then editing the first entry, changing the
        <parameter>image</parameter>, and <parameter>label</parameter>
        options. After changing the example above it would look like
        this:
      </para>

      <screen>
# Linux bootable partition config begins
image = /boot/vmlinuz-2.6.21.5-smp-ddk
  root = /dev/hda5
  label = Slack
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking

image = /boot/vmlinuz
  root = /dev/hda5
  label = SlackOld
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
# Linux bootable partition config ends
      </screen>

      <para>
    As you can see the first <parameter>image</parameter> entry
    points to the new kernel, and the label of the second entry
    was changed to <quote>SlackOld</quote>. LILO will
    automatically boot the first image. You can now install this
    new LILO configuration with the <command>lilo</command>
    command:
      </para>

      <screen>
# <userinput>lilo</userinput>
Added Slack *
Added SlackOld
      </screen>

      <para>
    The next time you boot both entries will be available, and the
    <quote>Slack</quote> entry will be booted by default.
      </para>

      <note>
    <para>
      If you want LILO to show a menu with the entries configured
      via <filename>lilo.conf</filename> on each boot, make sure
      that you add a line that says
    </para>

    <screen>
prompt
    </screen>

    <para>
      to <filename>lilo.conf</filename>. Otherwise LILO will boot
          the default entry that is set with
          <emphasis>default=&lt;name&gt;</emphasis>,
          or the first entry when no default kernel is set. You can
          access the menu with entries at any time by holding the
          &lt;Shift&gt; key when LILO is started.
    </para>
      </note>
    </sect2>
  </sect1>
</chapter>
