<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="id"
  xml:id="chap-textproc">
  <title>Pemrosesan Teks</title>

  <para>
    Manipulasi teks adalah salah satu keunggulan UNIX, karena merupakan inti dari 
    filosofi UNIX, seperti yang dijelaskan pada 
    <xref linkend="chap-intro-unix" />. Sebagian besar perintah UNIX merupakan 
    perintah sederhana yang membaca data dari masukan standar, melakukan beberapa operasi
    pada data, dan mengirimkan hasil ke keluaran standar program. Program ini biasanya
    bertindak sebagai filter, yang bisa dihubungkan dengan bantuan pipe. Hal ini 
    mengijinkan pengguna untuk meletakkan aplikasi UNIX untuk kebutuhan yang lain. Pada 
    bagian selanjutnya Anda akan melihat bagaimana Anda bisa membuat filter Anda sendiri.
  </para>

  <para>
    Bagian ini menjelaskan beberapa perintah UNIX sederhana namun penting yang bisa digunakan 
    untuk memanipulasi teks. Setelah itu, kita akan menjelajah lebih lanjt ke ekspresi teratur 
    (regular expressions) sebuah sub bahasa yang dapat digunakan untuk mencocokkan 
    pola teks.
  </para>
 
  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulasi teks sederhana</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Mengulang apa yang dikatakan</title>

      <para>
	Filter teks yang paling sederhana adalah <command>cat</command>, Ia hanya mengirimkan 
	data dari stdin ke stdout:
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
	Fitur lain adalah Anda bisa mengirimkan isi sebuah berkas ke standard output:
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
	<command>cat</command> akan mengerjakan sesuai namanya jika beberapa berkas ditambahkan 
	sebagai argumen. Hal ini akan menggabungkan berkas, dimana program akan mengirimkan 
	isi dari semua berkas ke standard output, dalam urutan yang sama sesuai dengan urutan pada 
	argumen. Contoh berikut menggambarkan proses tersebut:
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Statistik teks</title>

      <para>
	Perintah <command>wc</command> menyediakan statistik tentang berkas teks atau aliran teks. 
	Tanpa parameter apapun, perintah ini akan menghitung jumlah baris, jumlah kata, dan jumlah byte.
	Sebuah kata dibatasi oleh satu karakter white space, atau sekumpulan karakter whitespace.
      </para>

      <para>
	Contoh berikut menampilkan jumlah baris, kata, dan byte dari contoh <quote>Hello world!</quote>:
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput> 
       1       2      13
      </screen>

      <para>
	Jika Anda hendak mencetak hanya satu dari ketiga komponen ini, Anda bisa menggunakan 
	salah satu dari parameter <parameter class="command">-l</parameter>
	(baris), <parameter class="command">-w</parameter> (kata), atau
	<parameter class="command">-c</parameter> (byte).
	Sebagai contoh, menambahkan parameter <parameter
	class="command">-l</parameter> akan menampilkan jumlah baris dalam sebuah berkas:
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command> 
  235882 /usr/share/dict/words
      </screen>

      <para>
	Atau, Anda bisa mencetak kolom tambahan dengan menambahkan parametrer:
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
	Harap diperhatikan bahwa urutan keluaran akan selalu sama (baris, kata, byte) tanpa tergantung 
	urutan dari opsi.
      </para>

      <para>
	Karena <parameter class="command">-c</parameter> mencetak jumlah byte, parameter ini 
	mungkin tidak merepresentasikan jumlah karakter yang ada pada teks, karena set karakter yang 
	digunakan mungkin bisa lebih besar dari satu byte. Untuk mengatasi ini, parameter <parameter
	class="command">-m</parameter> telah ditambahkan yang akan mencetak jumlah karakter pada teks, 
	dimana parameter ini bebas dari set karakter yang digunakan. <parameter class="command">-c</parameter> and
	<parameter class="command">-m</parameter> hanyalah pengganti, dan tidak bisa digunakan secara bersamaan
      </para>

      <para>
	Statistik yang diberikan <command>wc</command> lebih berguna dari apa yang seringkali tampak. Misalnya,
	parameter <parameter class="command">-l</parameter> digunakan sebagai counter untuk keluaran dari sebuah 
	perintah. Hal ini berguna, karena banyak perintah membedakan unit logis dengan baris baru. Misalkan Anda hendak 
	menghitung jumlah baris pada direktori home Anda yang memiliki nama berkas diakhiri dengan 
	<filename>.txt</filename>. Anda bisa melakukan hal ini dengan mengkombinasikan 
	<command>find</command> untuk mencari berkas yang relevan dan 
	<command>wc</command> untuk menghitung jumlahnya:
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Memanipulasi karakter</title>

      <para>
	Perintah <command>tr</command> dapat digunakan untuk melakukan berbagai operasi yang umum, seperti 
	mengganti karakter, menghapus karakter, dan meringkas urutan karakter. Satu 
	atau dua karakter harus ditentukan pada sebagian operasi. Selain karakter biasa, terdapat beberapa
	karakter khusus yang bisa digunakan:
      </para>

      <variablelist>
	<varlistentry>
	  <term>\karakter</term>
	  <listitem>
	    <para>
	      Notasi ini digunakan untuk menentukan karakter apa yang memerlukan proses escape, utamanya
	      <emphasis>\n</emphasis>
	      (baris baru), <emphasis>\t</emphasis> (tab horizontal), dan 
	      <emphasis>\\</emphasis> (backslash).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>karakter1-karakter2</term>
	  <listitem>
	    <para>
	      Secara implisit menyisipkan semua karakter dari 
	      <emphasis>karakter1</emphasis> hingga
	      <emphasis>karakterr2</emphasis>. Notasi ini harus digunakan dengan hati-hati, karena tidak selalu 
	      memberikan hasil yang diharapkan. Sebagai contoh, urutan 
	      <emphasis>a-d</emphasis> akan menghasilkan 
	      <emphasis>abcd</emphasis> untuk lokal POSIX (pengaturan bahasa), tetapi belum tentu benar untuk 
	      lokal yang lain.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:class:]</term>
	  <listitem>
	    <para>
	      Cocok dengan kelas karakter yang sudah didefinisikan terlebih dahulu. Semua kemungkinan ditampilkan 
	      pada <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[karakter*]</term>
	  <listitem>
	    <para>
	      Mengulang <emphasis>karakter</emphasis> sampai set kedua sama panjangnya dengan set karakter 
	      pertama. Hal notasi ini hanya bisa digunakan pada set kedua.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[karakter*n]</term>
	  <listitem>
	    <para>
	      Mengulang <emphasis>karakter </emphasis>
	      <emphasis>n</emphasis> kali.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>Kelas karakter tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Kelas</entry><entry>Arti</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Semua huruf dan angka.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Huruf.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Whitespace horizontal (cth. spasi dan tab).</entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Karakter kontrol.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Semua angka (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Semua karakter yang dapat dietak, kecuali whitespace.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Huruf kecil.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Semua karakter yang dapat dicetak, termasuk whitespace horizontal, tetapi 
	      tidak termasuk whitespace vertical.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Karakter tanda baca.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
	      <entry>Semua whitespace.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Huruf besar.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Digit heksadesimal (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Menukar karakter</title>

	<para>
	  Operasi default dari <command>tr</command> adalah untuk menukar 
	  (menterjemahkan) karakter. Hal ini berarti karakter ke<emphasis>n</emphasis> pada set pertama
	  akan diganti dengan karakter ke-<emphasis>n</emphasis> pada set kedua. Sebagai contoh, 
	  Anda bisa mengganti semua 
	  <emphasis>e</emphasis> dengan <emphasis>i</emphasis> dan 
	  <emphasis>o</emphasis> dengan <emphasis>a</emphasis> dengan satu operasi <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
	  Ketika set kedua tidak sebesar set pertama, karakter terakhir dari set kedua akan diulang. 
	  Hal ini tidak berlaku pada sistem UNIX lain. Jadi jika Anda hendak menggunakan 	  
	  <command>tr</command> pada mode yang bebas dari ketergantungan sistem, tentukan karakter yang 
	  harus diulang secara eksplisit. Sebagai contoh:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
	  Contoh lain adalah penggunaan sintaks repetisi ditengah. Misalkan set 1 adalah 
	  <emphasis>abcdef</emphasis>, dan set 2
	  <emphasis>@[-*]!</emphasis>. <command>tr</command> akan mengganti 
	  <emphasis>a</emphasis> dengan <emphasis>@</emphasis>,
	  <emphasis>b</emphasis>, <emphasis>c</emphasis>,
	  <emphasis>d</emphasis>, dan <emphasis>e</emphasis> dengan
	  <emphasis>-</emphasis>, dan <emphasis>f</emphasis> dengan
	  <emphasis>!</emphasis>.
	  Beberapa sistem UNIX lain akan mengganti 
	  <emphasis>a</emphasis> dengan
	  <emphasis>@</emphasis>, dan sisanya dengan <emphasis>-</emphasis>. Jadi, notasi yang lebih 
	  benar adalah dengan lebih eksplisit <emphasis>@[-*4]!</emphasis>,
	  yang akan memberikan hasil yang sama pada semua sistem UNIX:
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Meringkas urutan karakter</title>

	<para>
	  Ketika parameter <parameter class="command">-s</parameter> digunakan, <command>tr</command> 
	  akan meringkas semua karakter set yang berada pada set kedua. Hal ini berarti sebuah urutan 
	  yang sama akan direduksi menjadi satu karakter. Mari kita meringkas karakter &quot;<emphasis>e</emphasis>&quot;:
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
	  Kita bisa mengkombinasikan hal ini dengan translasi untuk menunjukkan contoh dari <command>tr</command>. 
	  Misalkan kita hendak menandai semua huruf hidup dengan tanda 
	  <emphasis>at</emphasis> (<emphasis>@</emphasis>), dengan huruf hidup berikutnya ditandai dengan satu tand a
	  <emphasis>at</emphasis> sign. Hal ini bisa dilakukan dengan mudah dengan menggabungkan dua perintah <command>tr</command> 
	  dengan pipe:
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Menghapus karakter</title>

	<para>
	  Akhirnya, <command>tr</command> bisa digunakan untuk menghapus karakter. Jika parameter 
	  <parameter class="command">-d</parameter> digunakan, semua karakter dari set pertama akan dihapus:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Cut dan paste kolom teks</title>

      <para>
	Perintah <command>cut</command> disediakan oleh sistem UNIX untuk <quote>memotong</quote> 
	satu atau lebih kolom dari sebuah berkas atau aliran data, dan mencetaknya ke standard output. 
	Seringkali perintah ini berguna untuk mengambil beberapa informasi dari teks. <command>cut</command> 
	menyediakan tiga pendekatan untuk mengambil informasi dari berkas:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Dengan byte.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Dengan karakter, yang tidak sama dengan mengambil dengan byte pada sistem yang menggunakan 
	    set karakter yang lebih besar dari delapan bit.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Dengan kolom, yang ditandai dengan sebuah karakter.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Pada semua pendekatan, Anda bisa menentukan elemen yang dipilih dengan angkanya dimulai dari <emphasis>1</emphasis>. 
	Anda bisa menentukan interval dengan menggunakan tanda dash (<emphasis>-</emphasis>). Jadi,
	<emphasis>M-N</emphasis> berarti elemen ke-M hingga ke N. Menghilangkan M (<emphasis>-N</emphasis>) 
	akan memilih semua elemen dari elemen pertama hingga elemen ke-N. Menghilangkan N (<emphasis>M-</emphasis>) 
	akan memilih elemen ke-M hingga elemen terakhir. Banyak elemen atau interval bisa dikombinasikan 
	dengan memisahkannya dengan koma (<emphasis>,</emphasis>). Jadi, sebagai contoh, <emphasis>1,3-</emphasis> 
	memilih elemen pertama dan elemen ketiga hingga elemen terakhir.
      </para>

      <para>
	Data bisa diambil per kolom dengan parameter <parameter
	class="command">-f kolom</parameter>. Secara default, tab horizontal digunakan sebagai pemisah. Mari 
	kita lihat bagaimana <command>cut</command> digunakan dengan kamus Belanda ke Inggris:
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
	Kita bisa mendapatkan semua kata-kata bahasa Inggris dengan memilih kolom pertama:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
	Itu cukup mudah. Mari kita lakukan hal yang sama dengan berkas yang memiliki tanda titik dua sebagai 
	pemisah kolom. Kita bisa melakukan hal ini dengan mudah dengan mengkonversi kamus dengan perintah 
	<command>tr</command> yang sudah kita lihat sebelumnya, dengan mengganti semua tab dengan titik dua:
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Jika kita menggunakan perintah yang sama pada contoh sebelumnya, kita tidak akan mendapatkan hasil
	yang benar:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Apa yang terjadi disini adalah karena pembatas tidak dapat ditemukan. Jika sebuah baris tidak 
	mengandung pembatas yang digunakan, maka <command>cut</command> akan mencetak baris tersebut. 
	Anda bisa mencetak hal ini dengan parameter <parameter
	class="command">-s</parameter>.
      </para>

      <para>
	Untuk menggunakan pembatas yang berbeda dengan tab horizontal, tambahkan parameter
	<parameter class="command">-d karakter_pembatas</parameter>
	untuk menentukan karakter pembata. Jadi, pada kasus 
	<filename>dictionary-new</filename>, kita akan meminta
	<command>cut</command> untuk menggunakan tanda titik dua sebagai pembatas:
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
	Jika sebuah kolom yang ditentukan tidak ada dalam baris, maka kolom tersebut tidak akan dicetak.
      </para>

      <para>
	Parameter <parameter class="command">-b byte</parameter> dan
	<parameter class="command">-c karakter</parameter>
	memilih byte dan karakter dari teks. Pada sistem lama, sebuah karakter besarnya sama dengan satu byte. 
	Tetapi sistem yang baru bisa menyediakan set karakter yang lebih besar dari satu byte. Jadi, jika 
	Anda hendak memastikan untuk mengambil seluruh karakter, gunakan parameter <parameter class="command">-c</parameter>.
	Contoh yang memperagakan parameter <parameter
	class="command">-c</parameter> adalah mencari sepuluh set yang paling umum dari tiga karakter pertama dari sebuah 
	kata. Sebagian besar sistem UNIX menyediakan daftar kata yang dipisahkan dengan baris baru. Kita bisa menggunakan 
	<command>cut</command> untuk mendapatkan tiga karakter pertama dari daftar kata, menambahkan <parameter class="command">uniq</parameter>
	untuk menghitung urutan tiga karakter yang identik, dan menggunakan <command>sort</command> untuk mengurutkan 
	secara terbalik (<command>sort</command> dijelaskan pada <xref
	linkend="chap-textproc-simple-sort" />). Akhirnya, kita akan menggunakan 
	<command>head</command> untuk mendapatkan sepuluh urutan yang paling sering muncul:
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
	Setelah selesai dengan perintah UNIX ini, kita akan melanjutkan dengan perintah <command>paste</command>
	yang mengkombinasikan berkas dalam kolom pada satu aliran teks.
      </para>

      <para>
	Penggunaan dari <command>paste</command> sangatlah sederhana. Perintah ini akan menggabungkan semua berkas 
	yang diberikan sebagai argumen, dipisahkan dengan tab. Dengan daftar kata-kata Inggris dan Belanda, kita bisa 
	menghasilkan sebuah kamus kecil:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
	Anda juga bisa mengkombinasikan lebih dari dua berkas:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput> 
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
	Jika salah satu berkas lebih besar, urutan kolom akan dipertahankan dan isi yang kosong akan 
	digunakan untuk mengisi isi dari berkas yang lebih kecil.
      </para>

      <para>
	Anda bisa menggunakan pembatas lain dengan menambahkan parameter <parameter
	class="command">-d pembatas</parameter>. Sebagai contoh, kita bisa membuat kamus yang dipisahkan 
	dengan titik dua:
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
	Normalnya, <command>paste</command> mengkombinasikan berkas sebagai kolom yang berbeda. Anda bisa 
	membuat <command>paste</command> menggunakan setiap baris dari setiap berkas sebagai kolom, dan meletakkan 
	kolom dari setiap berkas pada baris yang berbeda. Hal ini dilakukan dengan parameter <parameter
	class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Mengurutkan teks</title>

      <para>
	UNIX menawarkan perintah <command>sort</command> untuk mengurutkan teks. 
	<command>sort</command> dapat juga menguji apakah sebuah berkas sudah diurutkan atau belum, dan menggabungkan dua 
	berkas yang sudah diurutkan. <command>sort</command> bisa mengurutkan dalam urutan kamus atau numerik. 
	Metode pengurutan default adalah berbasis kamus. Hal ini berarti baris teks akan dibandungkan per karakter, 
	dan diurutkan sesuai dengan apa yang sudah ditentukan dalam urutan collation  (yang ditentukan 
	melalui variabel lingkungan LC_COLLATE). Hal ini memiliki masalah ketika Anda mengurutkan angka, misalnya jika 
	Anda memiliki angka 1 hingga 10 pada baris yang berbeda, urutannya akan menjadi 1, 10, 2, 3, dst.  Hal ini 
	dikarenakan interpretasi per karakter dari pengurutan berdasarkan kamus. Jika Anda hendak mengurutkan baris berdasarkan 
	angka, gunakan metode pengurutan berdasarkan numerik.
      </para>

      <para>
	Jika tidak ada parameter tambahan yang ditentukan, <command>sort</command> mengurutkan baris masukkan dalam urutan seperti 
	pada kamus. Sebagai contoh:
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Seperti yang Anda lihat, masukkan diurutkan dengan benar. Seringkali terdapat dua baris yang sama. Anda 
	bisa menggabungkan baris yang sama dengan menambahkan parameter <parameter class="command">-u</parameter>. 
	Dua contoh berikut akan mengilustrasikan hal ini.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Terdapat beberapa parameter tambahan yang bisa berguna untuk memodifikasi hasil:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Parameter <parameter class="command">-f</parameter> membuat pengurutan menjadi case-insensitive.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Jika <parameter class="command">-d</parameter> ditambahkan, hanya karakter kosong dan 
	    alphanumerik yang digunakan untuk menentukan urutan.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Parameter <parameter class="command">-i</parameter> membuat <command>sort</command> mengabaikan 
	    karakter yang tidak bisa dicetak.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
	Anda bisa mengurutkan berkas secara numerik dengan menambahkan parameter <parameter
	class="command">-n</parameter>. Parameter ini berhenti membaca baris masukan ketika karakter bukan 
	angka ditemukan. Tanda minus, nilai desimal, pembatas ribuan, karakter radix (yang membatasi eksponen
	dari angka biasa), dan karakter kosong bisa digunakan sebagai bagian dari angka. Karakter-karakter ini 
	akan diinterpretasikan jika dimungkinkan.
      </para>

      <para>
	Contoh berikut menggambarkan pengurutan berbasiskan numerik, dengan melakukan pipe terhadap hasil keluaran 
	dari <command>du</command> ke <command>sort</command>. Hal ini bisa bekerja karena 
	<command>du</command> menentukan ukuran dari setiap berkas sebagai kolom pertama.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
	Pada kasus ini, hasil keluaran mungkin tidak berguna jika Anda hendak membaca keluaran 
	dalam paginator, karena berkas terkecil akan ditampilkan terlebih dahulu. Kondisi ini dimana 
	parameter <parameter class="command">-r</parameter> akan berguna. Parameter ini akan memutar urutan 
	pengurutan.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
	Parameter <parameter class="command">-r</parameter> juga bisa bekerja untuk pengurutan berdasarkan kamus.
      </para>

      <para>
	Seringkali, berkas menggunakan layout dengan banyak kolom, dan Anda mungkin hendak mengurutkan berkas
	dengan kolom yang bukan kolom pertama. Sebagai contoh, misalkan ada berkas nilai bernama  <filename>score.txt</filename>:
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>
     
    <para>
      Misalkan kita hendak mengurutkan berkas ini berdasarkan dua huruf nama negara. <command>sort</command> 
      mengijinkan kita untuk mengurutkan berkas dengan sebuah kolom dengan parameter <parameter
      class="command">-k col1[,col2]</parameter>.  Dimana 
      <emphasis>col1</emphasis> hingga <emphasis>col2</emphasis> digunakan sebagai kolom untuk mengurutkan masukan.
      Jika <emphasis>col2</emphasis> tidak ditentukan, semua kolom hingga akhir baris akan digunakan. Jadi
      jika Anda hendak menggunakan hanya satu kolom, gunakan <parameter class="command">-k col1,col1</parameter>.
      Anda juga bisa menentkan karakter awal dengan kolom dengan menambahkan sebuah tanda titik (<emphasis>.</emphasis>) 
      dan indeks karakter. Sebagai contoh, <parameter class="command">-k
      2.3,4.2</parameter> berarti kolom kedua dimulai dari karakter ketiga, kolom ketiga, dan kolom keempat hingga karakter kedua.
    </para>

    <para>
      Terdapat hal lain yang berguna jika berhubungan dengan pengurutan kolom: secara default, 
      <command>sort</command> menggunakan karakter kosong sebagai pembatas kolom. Jika Anda menggunakan karakter 
      pemisah yang lain, Anda harus menggunakan parameter <parameter>-t char</parameter>, yang digunakan untuk 
      menentukan pemisah kolom.
    </para>

    <para>
      Dengan kombinasi parameter <parameter class="command">-t</parameter> dan
      <parameter class="command">-k</parameter>, kita bisa mengurutkan berkas nilai berdasarkan kode negara:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Jadi, bagaimana kita bisa mengurutkan berkas berdasarkan skor? Jelas, kita harus meminta sort untuk 
      menggunakan kolom ketiga. Tetapi sort menggunakan metode pengurutan berdasarkan kamus secara default
      <footnote><para>Tentu saja, hal ini bukan masalah, karena kita tidak menggunakan angka yang lebih besar dari 9, 
      dan semua set karakter memiliki angka dalam urutan angka).</para></footnote>. Anda bisa menggunakan 
      <parameter class="command">-n</parameter>, tetapi <command>sort</command> juga mengijinkan pendekatan 
      yang lebih canggih. Anda bisa menambahkan satu atau lebih <emphasis>n</emphasis>, <emphasis>r</emphasis>,
      <emphasis>f</emphasis>, <emphasis>d</emphasis>,
      <emphasis>i</emphasis>, atau <emphasis>b</emphasis> pada penanda kolom. Huruf-huruf ini merepresentasikan parameter 
      <command>sort</command> dengan nama yang sama. Jika Anda menambahkan hanya kolom awal, menambahkan pada kolom 
      tersebut, selain itu, tambahkan pada akhir kolom.
    </para>

    <para>
      Perintah berikut mengurutkan berkas berdasarkan skor:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      Disarankan untuk mengikuti pendekatan ini, daripada menggunakan varian parameter, karena 
      <command>sort</command> mengijinkan Anda menggunakan lebih dari satu parameter <parameter class="command">-k</parameter>. 
      Dan menambahkan parameter ini pada spesifikasi kolom akan memungkinkan Anda untuk mengurutkan kolom 
      yang berbeda dalam berbagai cara yang berbeda. Sebagai contoh, menggunakan <command>sort</command> dengan 
      parameter <parameter class="command">-k 3,3n -k 2,2</parameter> akan mengurutkan semua barus secara numerik 
      oleh kolom ketiga. Jika beberapa baris memiliki angka yang sama pada kolom ketiga, baris ini bisa diurutkan dengan 
      metode pengurutan berbasiskan kamus pada kolom kedua.
    </para>

    <para>
      Jika Anda hendak menguji apakah sebuah berkas sudah diurutkan atau belum, Anda bisa menggunakan parameter
      <parameter class="command">-c</parameter>. Jika berkas diurutkan sesuai urutan, sort akan mengembalikan nilai 
      <emphasis>0</emphasis>, jika tidak maka <emphasis>1</emphasis>. Kita bisa menguji ini dengan menuliskan isi dari 
      variabel <emphasis>?</emphasis> yang berisi nilai kembalian dari perintah terakhir yang dieksekusi.
      command.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      Perintah kedua menunjukkan bahwa hal ini bekerja, dengan melakukan pipe hasil keluaran dari soft terhadap 
      <filename>scores.txt</filename> ke 
      <command>sort</command>.
    </para>

    <para>
      Akhirnya, Anda bisa menggabungkan dua berkas yang sudah diurutkan dengan parameter <parameter
      class="command">-m</parameter>, dengan tetap menjaga urutan pengurutan. Hal ini lebih cepat daripada 
      menggabungkan kedua berkas, dan mengurutkannya kembali.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Perbedaan antar berkas</title>

      <para>
	Karena aliran teks, dan berkas teks sangatlah penting pada UNIX, seringkali sangat penting untuk menampikan 
	perbedaan antara dua berkas. Utilitas utama untuk bekerja dengan perbedaan antar berkas adalah <command>diff</command> 
	dan <command>patch</command>. <command>diff</command> menunjukkan perbedaan antar berkas. Hasil keluaran dari 
	<command>diff</command> bisa diproses oleh 
	<command>patch</command> untuk menerapkan perbedaan diantara kedua berkas pada sebuah berkas. <quote>diffs</quote> 
	juga merupakan dasar dari version/source management systems. Bagian berikut juga menjelaskan <command>diff</command> 
	dan <command>patch</command>. Untuk mendapatkan contoh yang dapat digunakan, dua berkas C berikut akan digunakan untuk 
	mendemonstrasikan perintah ini. Berkas ini bernama <filename>hello.c</filename> dan 
	<filename>hello2.c</filename>.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Menampilkan perbedaan antar berkas</title>

	<para>
	  Misalkan Anda menerima program 
	  <filename>hello.c</filename> dari seorang teman, dan Anda memodifikasi berkas tersebut untuk memberikan
	  waktu dan jam aktual dari pengguna. Anda bisa saja mengirimkan program yang sudah diupdate ke teman Anda.
	  Tetapi jika sebuah berkas sudah bertambah besar, hal ini menjadi tidak menyenangkan, karena perubahan
	  menjadi lebih susah untuk dilacak. Selain itu, teman Anda juga mungkin menerima perubahan dari orang lain.
	  Ini merupakan situasi yang sering terjadi dimana <command>diff</command> menjadi berguna.<command>diff</command> 
	  menampilkan perbedaan diantara kedua berkas. Sintaks dasarnya adalah <command>diff berkas berkas2</command>, 
	  yang akan menampilkan perbedaan antara <filename>berkas</filename> dan <filename>berkas2</filename>. Mari kita 
	  coba dengan berkas kita:
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  Tambahan pada <filename>hello2.c</filename> tampak pada hasil keluaran, tetapi formatnya sedikit aneh. 
	  sebenarnya, ini adalah perintah yang bisa diinterpretasikan oleh <command>ed</command>. Kita akan melihat
	  hasil keluaran yang lebih nyaman setelah melihat format keluaran default.
	</para>

	<para>
	  Dua elemen yang berbeda bisa kita lihat dari keluaran ini:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      Ini adalah perintah <application>ed</application> yang menentukan teks yang harus ditambahkan 
	      (<literal>a</literal>) setelah baris <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      Ini adalah teks aktual yang akan ditambahkan setelah baris kedua. Tanda <quote><emphasis>&gt;</emphasis></quote> 
	      digunakan untuk menandai baris yang akan ditambahkan
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Elemen yang sama digunakan untuk menambahkan blok kedua dari teks. Bagaimana dengan baris yang dihapus? Kita bisa 
	  dengan mudah melihat bagaimana mereka direpresentasikan dengan menukar dua parameter pada 
	  <command>diff</command>, menampilkan perbedaan antara 
	  <filename>hello2.c</filename> dan
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Elemen berikut dapat dibedakan:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      Ini adalah perintah penghapusan pada <application>ed</application>
	      (<literal>d</literal>), menyatakan bahwa baris 2 harus dihapus. Perintah penghapusan kedua menggunakan 
	      interval (baris 14 hingga 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      Teks yang akan dihapus diawali dengan tanda <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>
	<para>
	  Tampaknya cukup untuk gaya keluaran-<application>ed</application>. Program GNU diff yang 
	  disertakan pada Slackware Linux mendukung apa yang disebut unified diff. Unified diff sangat mudah 
	  dibaca, dan menyediakan konteks secara default. <command>diff</command> bisa menyediakan hasil keluaran yang 
	  bersifat seragam dengan parameter <parameter class="command">-u</parameter>:
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Elemen-elemen berikut dapat ditemukan pada hasil keluaran
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      Nama dari berkas asli, dan timestamp dari waktu modifikasi terakhir.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      Nama berkas yang berubah, dan timestamp dari waktu modifikasi terakhir.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Dua angka ini menunjukkan lokasi dari ukuran dari teks yang mempengaruhi berkas asli dan 
	      berkas setelah modifikasi. Jadi, pada kasus ini, angka-angka ini berarti pada bagian yang
	      berhubungan pada berkas asli dimulai pada baris 1, dan panjangnya empat baris. Pada berkas yang 
	      dimodifikasi, bagian yang berhubungan dimulai pada baris 1, dan panjangnya lima barus. Bagian 
	      yang berbeda pada hasil keluaran diff dimulai oleh header ini.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Baris yang tidak diawali oleh tanda minus 
	      (<emphasis>-</emphasis>) atau plus
	      (<emphasis>+</emphasis>) berarti tidak berubah. Baris yang tidak berubah disertakan karena 
	      mereka memberikan informasi kontekstual, dan untuk mencegah terlalu banyak bagian yang dibuat. 
	      Jika terdapat hanya beberapa baris yang tidak dimodifikasi pada setiap perubahan, 
	      <command>diff</command> akan memilih untuk membuat satu bagian saja.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Baris yang diawali dengan tanda plus 
	      (<emphasis>+</emphasis>) adalah tambahan pada berkas yang dimodifiksi, dibandingkan dengan 
	      berkas asli.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Seperti dengan format <command>diff</command> gaya berbasis-ed, kita bisa melihat penghapusan dengan menukar 
	  nama berkas:
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Seperti yang Anda lihat dari hasil keluaran ini, baris yang dihapus dari berkas yang 
	  dimodifikasi akan diawali dengan tanda minus (<emphasis>-</emphasis>).
	</para>

	<para>
	  Ketika Anda bekerja dengan sekumpulan berkas yang besar, akan sangat berguna untuk membandingkan
	  seluruh direktori. Sebagai contoh, jika Anda memiliki versi asli dari kode program dalam sebuah 
	  direktori bernama <filename>hello.orig</filename>, dan versi modifikasi pada direktori bernama 
	  <filename>hello</filename>, Anda bisa menggunakan parameter <parameter class="command">-r</parameter> 
	  untuk membandingkan kedua direktori secara rekursif. Sebagai contoh:
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  Harus diperhatikan bahwa hal ini hanya akan membandingkan berkas yang tersedia pada kedua direktori. 
	  Versi GNU dari diff yang digunakan oleh Slackware Linux menyediakan parameter 
	  <parameter class="command">-N</parameter>. Parameter ini mengangap berkas yang ada pada salah satu dari 
	  kedua direktori seperti berkas kosong. Jadi sebagai contoh, kita telah menambahkan berkas bernama 
	  <filename>Makefile</filename> pada direktori <filename>hello</filename>, menggunakan parameter 
	  <parameter class="command">-N</parameter> akan menghasilkan keluaran sebagai berikut:
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Seperti yang Anda lihat, indikator menunjukkan bahwa bagian pada berkas asli dimulai pada 
	  baris 0 dan sepanjang 0 baris.
	</para>

	<para>
	  Pengguna UNIX seringkali bertukar hasil keluaran dari 
	  <command>diff</command>, yang sering disebut <quote>diffs</quote> atau <quote>patches</quote>. 
	  Bagian selanjutkan akan menunjukkan kepada Anda bagaimana Anda bisa menangani diffs. Tetapi 
	  sekarang Anda sudah mampu membuatnya sendiri, dengan mengarahkan hasil keluaran dari diff pada 
	  sebuah berkas. Sebagai contoh:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Jika Anda memiliki beberapa diffs, Anda bisa dengan mudah mengkombinasikannya menjadi satu diff:
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Tetapi pastikan bahwa mereka dibuat dari direktori yang sama jika Anda hendak menggunakan utilitas 
	  <command>patch</command> yang dibahas pada bagian selanjutnya.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Memodifikasi berkas dengan hasil keluaran diff</title>

	<para>
	  Misalkan seseorang mengirimkan hasil keluaran dari 
	  <command>diff</command> untuk berkas yang telah Anda buat. Akan sangat memakan waktu untuk menggabungkan semua 
	  perubahan yang dibuat. Untungnya, <command>patch</command> bisa melakukannya untuk Anda. <command>patch</command> 
	  menerima diff pada standard input, dan mencoba mengubah berkas asli, sesuai dengan perubahan yang 
	  didaftarkan pada diff. Jadi, misalnya kita memiliki berkas <filename>hello.c</filename>, dan patch yang 
	  dibuat sebelumnya berdasarkan perubahan antara 
	  <filename>hello.c</filename> dan
	  <filename>hello2.c</filename>, kita bisa melakukan patch 
	  <filename>hello.c</filename> agar sama dengan berkas yang lain:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  Jika Anda memiliki <filename>hello2.c</filename>, Anda bisa menguji apakah berkas sudah sama:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  Tidak ada hasil keluaran, jadi ini hasilnya. Salah satu fitur menarik dari <command>patch</command> adalah ia dapat 
	  mengembalikan perubahan yang dilakukan oleh diff, dengan menggunakan parameter <parameter
	  class="command">-R</parameter>:
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  Pada contoh ini, berkas asli sudah di-patch. Seringkali, Anda hendak menerapkan patch pada berkas dengan nama 
	  yang berbeda. Anda bisa melakukan hal ini dengan menyediakan nama dari berkas sebagai argumen terakhir:
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  Anda juga bisa menggunakan <command>patch</command> dengan diffs yang dibuat dengan parameter 
	  <parameter class="command">-r</parameter>, tetapi Anda harus hati-hati. Misalkan header dari berkas
	  diff seperti berikut:
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Jika Anda memproses diff ini dengan <command>patch</command>, maka program akan mencoba mengubah 
	  <filename>hello.c</filename>. Jadi, direktori yang berisi berkas ini harus berada dalam direktori
	   aktif. Anda bisa menggunakan nama path lengkap dengan <parameter
	  class="command">-p n</parameter>, dimana 
	  <emphasis>n</emphasis> adalah angka path dimana komponen harus dihilangkan. Nilai 
	  <emphasis>0</emphasis> akan menggunakan path seperti yang ditentukan pada patch, 
	  <emphasis>1</emphasis> akan menghapus nama path pertama dari komponen, dan seterusnya. Pada contoh 
	  ini, menghapus komponen pertama akan melakukan patch terhadap 
	  <filename>hello.c</filename>. Sesuai dengan standar Single UNIX
	  Specification versi 3, path yang diawali dengan <emphasis>---</emphasis> harus digunakan 
	  untuk membangun berkas yang harus di-patch. Patch versi GNU tidak mengikuti standar disini. Jadi, sangat 
	  disarankan untuk menghapus pada titik dimana baik nama direktori sudah sama (hal ini biasanya 
	  direktori utama dari pohon yang sedang diganti). Pada sebagian besar kasus dimana path relatif digunakan, hal ini 
	  bisa diselesaikan menggunakan <emphasis>-p 1</emphasis>. Sebagai contoh:
	</para>

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  Atau, Anda bisa menggunakan parameter <parameter
	  class="command">-d</parameter> untuk menentukan direktori dimana perubahan harus diterapkan:
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Jika Anda hendak mempertahankan backup ketika Anda mengubah berkas, Anda bisa menggunakan paramater
	  <parameter class="command">-b</parameter> dari <command>patch</command>. Parameter ini akan membuat 
	  salinan dari setiap berkas yang diganti dengan nama  <filename>filename.orig</filename>, sebelum 
	  mengubah berkas:
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Seringkali sebuah berkas tidak bisa di-patch. Misalnya, jika sudah pernah di-patch, terlalu 
	  banyak perubahan sehingga tidak bisa dipatch dengan sempurna, atau jika berkas tidak ada. Pada 
	  kasus ini, bagian yang tidak bisa disimpan akan disimpan pada berkas dengan nama 
	  <filename>namaberkas.rej</filename>, dimana 
	  <emphasis>namaberkas</emphasis> adalah berkas yang coba dimodifikasi oleh 
	  <command>patch</command>.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Regular expressions</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Perkenalan</title>

      <para>Pada kehidupan sehari-hari, Anda seringkali ingin agar beberapa teks cocok pada beberapa pola. 
      Banyak utilitas UNIX yang mengimplementasikan sebuah bahasa untuk pencocokan pola teks
      <emphasis>regular expressions</emphasis> (regexps). Seiring dengan waktu, bahasa regular expression 
      telah berkembang, sehingga saat ini sudah terdapat tiga sintaks untuk regular expression: </para>

      <itemizedlist>
        <listitem>
          <para> Traditional UNIX regular expressions. </para>
        </listitem>
        <listitem>
          <para> POSIX extended regular expressions. </para>
        </listitem>
        <listitem>
          <para> Perl-compatible regular expressions (PCRE). </para>
        </listitem>
      </itemizedlist>

      <para>
	POSIX regexps adalah superset dari traditional UNIX
	regexps, dan PCRE adalah superset dari POSIX regexps. Sintaks yang didukung oleh setiap aplikasi 
	bisa berbeda-beda, tetapi hampir semua aplikasi mendukung paling tidak POSIX regexps.
      </para>

      <para>
	Setiap unit sintatis pada regexp merepresentasikan salah satu dari hal berikut:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">Sebuah karakter</emphasis>: ini adalah dasar dari setiap regular 
	    expression, sebuah karakter atau sekumpulan karakter yang harus dicocokkan. Sebagai contoh,
	    kata <emphasis>p</emphasis> atau tanda <emphasis>,</emphasis>. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Kuantifikasi</emphasis>: Sebuah quantifier menentukan berapa banyak 
	    karakter atau set karakter yang harus dicocokkan. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternatif</emphasis>: Alternatif digunakan untuk mencocokkan 
	    <quote>a atau b</quote> dimana 
            <emphasis>a</emphasis> dan <emphasis>b</emphasis> bisa berupa karakter atau regexp. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Pengelompokkan</emphasis>: hal ini digunakan untuk mengelompokkan sub ekspresi, 
	    sehingga kuantifikasi atau alternatif bisa diterapkan pada grup. </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Traditional UNIX regexps</title>

      <para>
	Bagian ini membahas traditional UNIX regexps. Karena kurangnya standarisasi, sintaks yang sebenarnya 
	bisa berbeda untuk setiap utilitas. Biasanya, halaman manual dari sebuah perintah menyediakan 
	lebih banyak informasi tentang regular expressions yang didukung. Merupakan ide bagus untuk 
	mempelajari traditional regexps, tetapi untuk menggunakan POSIX regexps untuk script Anda sendiri.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Pencocokkan karakter</title>

        <para>
	  Karakter akan dicocokkan dengan sendirinya. Jika karakter tertentu digunakan sebagai sintaks karakter untuk 
	  regexps, Anda bisa mencocokkan karakter tersebut dengan menambahkan sebuah backslash. Sebagai contoh, 
	  <emphasis>\+</emphasis> cocok dengan karakter plus. </para>

        <para>
	  Tanda titik (<emphasis>.</emphasis>) cocok dengan sembarang karakter, sebagai contoh, regexp 
	  <emphasis>b.g</emphasis> cocok dengan 
	  <emphasis>bag</emphasis>, <emphasis>big</emphasis>, dan 
	  <emphasis>blg</emphasis>, tetapi tidak dengan 
	  <emphasis>bit</emphasis>. </para>

        <para>
	  Karakter titik seringkali memberikan kebebasan yang berlebihan. Anda bisa memberikan tanda kurung 
	  siku (<emphasis>[]</emphasis>) untuk menentukan karakter yang harus dicocokkan. Sebagai contoh, regexp
	  <emphasis>b[aei]g</emphasis> cocok dengan 
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, dan 
	  <emphasis>big</emphasis>, tetapi tidak yang lain. Anda juga bisa mencocokkan sembarang karakter kecuali karakter
	  pada sebuah set menggunakan kurung siku, dan menggunakan tanda caret (<emphasis>^</emphasis>) sebagai karakter pertama. 
	  Sebagai contoh, <emphasis>b[^aei]g</emphasis> cocok dengan sembarang tiga karakter string yang 
	  dimulai dengan <emphasis>b</emphasis> dan diakhiri dengan <emphasis>g</emphasis>, dengan pengecualian 
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, dan 
	  <emphasis>big</emphasis>. Juga dimungkinkan untuk mencocokkan sebuah interval karakter dengan tanda minus
	  (<emphasis>-</emphasis>). Sebagai contoh,
	  <emphasis>a[0-9]</emphasis> cocok dengan a diikuti dengan sebuah angka. </para>

        <para>
	  Dua karakter khusus, caret (<emphasis>^</emphasis>) dan dollar (<emphasis>$</emphasis>), cocok dengan 
	  awal dan akhir baris. Karakter ini sangat berguna untuk mem-parsing berkas. Sebagai contoh, Anda bisa 
	  mencocokan semua berkas yang dimulai dengan tanda hash (<emphasis>#</emphasis>) dengan regexp
	  <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Kuantifikasi</title>

        <para>
	  Tanda kuantifikasi paling sederhana yang didukung oleh traditional regular
	  expressions adalah tanda bintang (<emphasis>*</emphasis>). Tanda ini cocok dengan nol atau lebih dari karakter 
	  yang mendahuluinya. Sebagai contoh, <emphasis>ba*</emphasis> cocok dengan <emphasis>b</emphasis>,
	  <emphasis>ba</emphasis><emphasis>baa</emphasis>, dst. Anda harus hati-hati bahwa sebuah karakter diikuti dengan 
	  tanda bintang tanpa konteks apapun cocok dengan semua string, karena 
	  <emphasis>c*</emphasis> juga cocok dengan string yang memiliki nol karakter <emphasis>c</emphasis>. </para>

        <para>
	  Repetisi lebih spesifik bisa ditentukan dengan tanda kurung kurawal yang di-escape 
	  <emphasis>\{x,y\}</emphasis> cocok dengan karakter yang mengawli minimal <emphasis>x</emphasis> kali, 
	  tetapi tidak lebih dari <emphasis>y</emphasis> kali. Jadi,
	  <emphasis>ba\{1,3\}</emphasis> cocok dengan 
	  <emphasis>ba</emphasis>, <emphasis>baa</emphasis>, dan 
	  <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Pengelompokkan</title>

        <para>
	  Tanda kurung yang di-escape akan mengelompokkan sekumpulan karakter bersama-sama, sehingga Anda bisa menerapkan 
	  kuantifikasi atau alternatif pada sekumpulan karakter. Sebagai contoh, 
	  <emphasis>\(ab\)\{1,3\}</emphasis> cocok dengan 
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, dan 
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternatif</title>

        <para>
	  Sebuah pipe yang di-escape  (<emphasis>\|</emphasis>) mengijinkan Anda untuk mencocokkan salah satu ekspresi.
	  Hal ini tidak berguna untuk satu karakter, karena <emphasis>a\|b</emphasis> ekuivalen dengan 
	  <emphasis>[ab]</emphasis>, tetapi sangat berguna pada saat pengelompokkan. Misalkan Anda hendak sebuah 
	  ekspresi yang cocok dengan <emphasis>apple</emphasis> dan 
	  <emphasis>pear</emphasis>, tetapi bukan yang lain. Hal ini bisa dilakukan dengan mudah dengan :
	  <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>POSIX extended regular expressions</title>

	<para>
	  POSIX regular expressions dibangun diatas traditional regular
	  expressions, dengan menambahkan beberapa primitif yang berguna. 
	  Perbedaan lain adalah tanda kurung pengelompokkan, tanda kuantifikasi, dan tanda alternatif 
	  (<emphasis>|</emphasis>) tidak perlu di escape dengan backslash.  Jika mereka di-escape, maka 
	  akan cocok dengan karakter literal biasa, sehingga menghasilkan tingkah laku yang kebalikan dari 
	  traditional regular expressions. Sebagian besar orang menganggap POSIX extended regular
	  expressions lebih nyaman, sehingga lebih banyak digunakan.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	  <title>Pencocokkan karakter</title>

	  <para>
	    Pencocokkan karakter biasa tidak berubah dibandingkan dengan 
	    traditional regular expressions yang dibahas pada <xref
	    linkend="chap-textproc-regexps-traditional-characters" />
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Kuantifikasi</title>

	  <para>
	    Selain tanda star (<emphasis>*</emphasis>), yang cocok dengan nol atau lebih karakter yang mendahuluinya, 
	    POSIX extended regular expressions menambahkan dua primitif kuantifikasi. Tanda plus
	    (<emphasis>+</emphasis>) cocok dengan satu atau lebih karakter atau grup sebelumnya. 
	    Sebagai contoh, <emphasis>a+</emphasis>, cocok dengan <emphasis>a</emphasis>
	    (atau sembarang string dengan lebih dari satu 
	    <emphasis>a</emphasis>), tetapi tidak cocok dengan nol karakter 
	    <emphasis>a</emphasis>. Karakter tanda tanya 
	    (<emphasis>?</emphasis>) cocok dengan nol atau satu karakter yang mendahuluinya. Jadi,
	    <emphasis>ba?d</emphasis> cocok dengan 
	    <emphasis>bd</emphasis> dan <emphasis>bad</emphasis>, tetapi tidak untuk <emphasis>baad</emphasis> atau 
	    <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Kurung kurawal juga digunakan untuk repetisi, seperti pada traditional
	    regular expressions, meskipun backslask bisa diabaikan. Untuk mencocokkan 
	    <emphasis>ba</emphasis> dan 
	    <emphasis>baa</emphasis>, Anda harus menggunakan 
	    <emphasis>ba{1,2}</emphasis> dan bukan 
	    <emphasis>ba\{1,2\}</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Pengelompokkan</title>

	  <para>
	    Pengelompokkan dilakukan dengan cara yang sama dengan traditional regular
	    expressions, kecuali Anda tidak perlu melakukan escape sebelum tanda kurung. Sebagai 
	    contoh, <emphasis>(ab){1,3}</emphasis>
	    cocok dengan <emphasis>ab</emphasis>,
	    <emphasis>abab</emphasis>, dan 
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	  <title>Alternatif</title>

	  <para>
	    Alternatif dilakukan dengan cara yang sama dengan traditional
	    regular expressions, kecuali Anda tidak perlu melakukan escape sebelum tanda pipe. Jadi,
	    <emphasis>(apple)|(pear)</emphasis> cocok dengan 
	    <emphasis>apple</emphasis> and <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>
    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Penggunaan grep dasar</title>

      <para>
	Kita telah tiba pada salah satu utilitas paling penting pada Sistem UNIX, dan salah satu yang mencoba 
	untuk menggunakan regular expressions. Perintah <command>grep</command> digunakan untuk mencari aliran teks atau 
	berkas untuk sebuah pola. Pola disini adalah regular expression, dan bisa berupa regular expression dasar 
	atau POSIX extended regular expression (ketika parameter 
	<parameter class="command">-E</parameter> digunakan). Secara default, <command>grep</command> akan mencoba 
	menulis baris yang cocok pada standard output. Pada sintaks dasarnya, Anda bisa menentukan regular expression 
	sebagai sebuah argumen, dan <command>grep</command> akan mencari kecocokkan pada teks dari standard input. 
	Hal ini merupakan cara yang baik untuk berlatih dengan regular expressions.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Contoh diatas menunjukkan basic regular expression, yang cocok dengan sebuah baris tunggal yang berisi dua atau tiga 
	string <emphasis>ab</emphasis>. Anda juga bisa melakukan hal yang sama dengan POSIX extended regular expressions, dengan 
	menambahkan parameter <parameter class="command">-E</parameter> (untuk extended):
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Karena tingkah laku default dari <command>grep</command> adalah membaca dari standard input, Anda bisa 
	menambahkan ke pipe untuk mendapatkan bagian yang menarik dari hasil keluaran dari perintah sebelumnya. 
	Sebagai contoh, jika Anda hendak mencari string <emphasis>2006</emphasis> pada kolom ketiga dari berkas, 
	Anda bisa mengkombinasikan perintah <command>cut</command> dan <command>grep</command>:
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>Melakukan grep pada berkas</title>

      <para>
	Secara umum, <command>grep</command> juga bisa membaca dari berkas, dan bukan dari 
	standard input. Seperti biasa, hal ini bisa dilakukan dengan menambahkan berkas yang hendak dibaca sebagai 
	argumen terakhir. Contoh berikut akan mencetak semua baris dari berkas 
	<filename>/etc/passwd</filename> dari awal hingga string <emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <para>
        Dengan opsi <parameter class="command">-r</parameter>,
	<command>grep</command> akan menjelajahi sebuah struktur direktori secara rekursif, mencoba 
	mencari pencocokkan pada setiap berkas yang ditemukan selama pencarian. Meski demikian, akan lebih baik 
	untuk mengkombinasikan <command>grep</command> dengan 
	<command>find</command> dan operan <emphasis>-exec</emphasis> pada script agar lebih portabel.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	adalah fungsi yang ekuivalen namun tidak portabel dari 
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Perilaku pola</title>

      <para>
	<command>grep</command> juga bisa mencetak semua barus yang tidak cocok dengan pola yang digunakan. 
	Hal ini bisa dilakukan dengan menambahkan parameter <parameter class="command">-v</parameter>:
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	Jika Anda hendak menggunakan pola dalam pola case-insensitive, Anda bisa menambahkan parameter
	<parameter class="command">-i</parameter>. Sebagai contoh:
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	Anda juga mencocokkan string secara literal dengan parameter <parameter
	class="command">-F</parameter>:
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Menggunakan banyak pola</title>

      <para>
	Seperti yang telah kita lihat, Anda bisa menggunakan karakter alternatif (<emphasis>|</emphasis>) 
	untuk mencocokkan dua atau lebih sub pola. Jika dua pola yang hendak Anda cocokkan berbeda jauh, 
	akan lebih enak untuk dua pola yang berbeda. <command>grep</command> mengijinkan Anda untuk 
	menggunakan lebih dari satu pola dengan memisahkannya dengan baris baru. Sehingga, misalnya Anda hendak 
	mencetak baris yang cocok dengan pola <emphasis>a</emphasis> atau 
	<emphasis>b</emphasis>, hal ini bisa dilakukan dengan mudah dengan menambahkan baris baru:
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	Hal ini bisa bekerja, karena tanda kutip akan digunakan, dan shell mengirimkan parameter yang dikuti
	secara literal. Meskipun, harus diakui bahwa hal ini tidaklah bagus. <command>grep</command> menerima 
	satu atau lebih parameter <parameter class="command">-e pattern</parameter>, memberikan kesempatan 
	lebih besar untuk menentukan satu atau lebih parameter pada satu barus. Pemanggilan 
	<command>grep</command> pada contoh sebelumnya bisa ditulis sebagai:
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
