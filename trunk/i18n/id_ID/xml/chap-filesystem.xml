<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 xml:lang="id"
	 xml:id="chap-filesystem">
  <title>Berkas dan direktori</title>

  <sect1 xml:id="chap-filesystem-introduction">
    <title>Beberapa teori</title>

    <para>
      Sebelum kita melihat operasi sistem berkas secara praktis, kita 
      akan melihat secara teoritis bagaimana gambaran sistem berkas pada
      sistem UNIX-like bekerja. Slackware Linux mendukung banyak 
      sistem berkas yang berbeda, tetapi semua sistem berkas ini 
      menggunakan semantik yang sama secara virtual. Semantik ini
      disediakan melalui lapisan (layer) <emphasis>Virtual Filesystem</emphasis> (VFS), 
      menyediakan layer geneik untuk sistem berkas disk dan jaringan.
    </para>

    <sect2 xml:id="chap-filesystem-introduction-atoms">
      <title>inode, direktori dan data</title>

      <para>
	Sistem berkas terdiri dari dua jenis elemen: data dan metadata. 
	Metadata menjelaskan blok data yang sesungguhnya ada pada disk. 
	Sebagian besar sistem berkas menggunakan node informasi (inode) untuk 
	menyediakan metadata penyimpanan. Sebagian besar sistem berkas 
	menyimpan data berikut pada inodenya:
      </para>

      <table xml:id="chap-filesystem-introduction-atoms-inodes">
        <title>Kolom inode umum</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Kolom</entry>
              <entry>Deskripsi</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>Hak akses berkas.</entry>
            </row>
            <row>
              <entry>uid</entry>
              <entry>ID pengguna dari pemilik berkas.</entry>
            </row>
            <row>
              <entry>gid</entry>
              <entry>ID grup dari grup pemilik berkas.</entry>
            </row>
            <row>
              <entry>size</entry>
              <entry>Ukuran berkas dalam byte.</entry>
            </row>
            <row>
              <entry>ctime</entry>
              <entry>Waktu pembuatan berkas.</entry>
            </row>
            <row>
              <entry>mtime</entry>
              <entry>Waktu modifikasi terakhir berkas.</entry>
            </row>
            <row>
              <entry>links_count</entry>
              <entry>Jumlah link yang mengarah ke inode ini.</entry>
            </row>
            <row>
              <entry>i_block</entry>
              <entry>Penunjuk ke blok data</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Jika Anda bukan pengguna UNIX atau Linux, nama-nama ini mungkin 
	tampak asing bagi Anda, tetapi akan membuatnya jelas pada bagian berikutnya.
	Pada titik ini, Anda bisa menebak relasi antara inode dan data dari 
	tabel ini, dan terutama kolom <emphasis>i_block</emphasis>: setiap 
	inode memiliki penunjuk (pointer) ke blok data yang diberikan oleh inode. 
	Bersama-sama, inode dan blok data adalah berkas aktual pada sistem berkas.
      </para>

      <para>
	Anda mungkin terheran-heran dinama nama berkas (dan direktori) berada, 
	karena tidak ada kolom nama berkas pada inode. Sebenarnya, nama berkas 
	terpisah dari inode dan blok data, yang mengijinkan Anda melakukan hal-hal aneh
	seperti memberikan nama lebih dari satu pada berkas yang sama. Nama berkas 
	disimpan dalam apa yang disebut isian direktori. Isian (entry) ini menentukan
	nama berkas dan inode dari berkas. Karena direktori juga direpresentasikan oleh 
	inode, sebuah struktur direktori juga bisa dibuat dengan cara ini.
      </para>

      <para>
	Kita bisa melihat bagaimana semua ini bekerja dengan mengilustrasikan apa yang
	dilakukan kernel ketika kita menjalankan perintah <command>cat
	/home/daniel/note.txt</command>
      </para>

      <orderedlist>
        <listitem>
	  <para>
	    Sistem membaca inode dari direktori <filename>/</filename>, memeriksa apakah 
	    pengguna diijinkan untuk mengakses inode ini, dan membaca blok data untuk 
	    menemukan nomor inode dari direktori <filename>home</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    Sistem membaca inode dari direktori <filename>home</filename>, memeriksa apakah 
	    pengguna diijinkan untuk mengakses inode ini, dan membaca blok data untuk 
	    menemukan nomor inode dari direktori <filename>daniel</filename>. </para>
        </listitem>
        <listitem>
          <para>
	    Sistem membaca inode dari direktori <filename>daniel</filename>, memeriksa apakah 
	    pengguna diijinkan untuk mengakses inode ini, dan membaca blok data untuk 
	    menemukan nomor inode dari berkas <filename>note.txt</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    Sistem membaca inode dari berkas <filename>note.txt</filename>, memeriksa apakah 
	    pengguna diijinkan untuk mengakses inode ini, dan mengembalikan blok data pada 
	    <command>cat</command> melalui pemanggilan sistem (system call)<emphasis>read()</emphasis>. </para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="chap-filesystem-introduction-permissions">
      <title>Hak akses berkas</title>

      <para>
	Seperti yang dijelaskan sebelumnya, Linux adalah sistem multi-user. Hal ini berarti 
	bahwa setiap pengguna memiliki berkasnya sendiri (yang biasanya terdapat pada direktori home). 
	Selain itu, pengguna juga bisa merupakan anggota dari sebuah grup, yang mungkin memberikan 
	hak akses tambahan pada pengguna.
      </para>

      <para>
	Seperti yang Anda lihat pada tabel kolom inode, setiap berkas memiliki pemilik dan grup. Kontrol hak akses 
	UNIX tradisional memberikan hak akses read (baca), write (tulis), atau executable (eksekusi) pada pemilik berkas, group berkas, 
	dan pengguna lain. Hak akses ini disimpan pada kolom <emphasis>mode</emphasis> dari inode. Kolom mode 
	merepresentasikan hak akses berkas sebagai nomor oktal empat digit. Digit pertama merepresentasikan 
	opsi khusus, digit kedua menyimpan hak akses pemilik, digit ketiga menyimpan hak akses grup, dan digit keempat
	untuk pengguna lain. Hak akses dibuat dengan nomor dengan menggunakan atau menambahkan salah satu angka pada <xref
	linkend="chap-filesystem-permissions-numbers"/>
      </para>

      <table xml:id="chap-filesystem-permissions-numbers">
        <title>Arti angka pada oktet model</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Angka</entry>
              <entry>Arti</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>Execute (x)</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>Write (w)</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>Read (r)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Sekarang, misalkan sebuah berkas memiliki mode <emphasis>0644</emphasis>,
	hal ini berarti berkas dapat dibaca dan ditulis oleh pemilik
	(<emphasis>6</emphasis>), dan dapat dibaca oleh group berkas
	(<emphasis>4</emphasis>) dan yang lain
	(<emphasis>4</emphasis>). </para>

      <para>
	Sebagian besar pengguna tidak mau berhubungan dengan nomor oktal, sehingga 
	banyak utilitas dapat bekerja dengan representasi alfabetik dari hak akses
	berkas. Huruf-huruf tersebut dapat dilihat pada <xref
	linkend="chap-filesystem-permissions-numbers"/> didalam kurung digunakan 
	pada notasi ini. Pada contoh berikut, informasi tentang berkas dengan hak 
	akses <emphasis>0644</emphasis> akan dicetak. Nomor digantikan dengan kombinasi 
	tiga rwx (karakter pertama bisa mendata opsi mode khusus).
      </para>

      <screen>
$ <userinput>ls -l note.txt</userinput>
-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt
      </screen>

      <para>
	Selama bertahun-tahun, hak akses UNIX tradisional sudah terbukti tidaklah 
	cukup untuk beberapa kasus. Spesifikasi POSIX 1003.1e bertujuan untuk 
	meningkatkan model kontrol akses UNIX dengan <emphasis>Access Control Lists</emphasis> (ACL).
	Sayangnya usaha ini terhenti, meskipun beberapa sistem  (seperti GNU/Linux) 
	sudah mengimplementasikan ACL<footnote>
	<para>Pada saat penulisan ini, ACL sudah didukung pada sistem berkas ext2,
        ext3, dan XFS</para> </footnote>. Access control
        lists menggunakan semantik yang sama dengan hak akses berkas biasa, tetapi 
	memberikan Anda kesempatan untuk menambahkan tambahan kombinasi <emphasis>rwx</emphasis>
        untuk pengguna dan grup tambahan. </para>

      <para>
	Contoh berikut menggambarkan access control list dari sebuah berkas. Seperti 
	yang Anda lihat, hak akses seperti hak akses UNIX normal (hak akses untuk pengguna, 
	grup, dan lainnya sudah ditentukan). Tetapi terdapat sebuah tambahan untuk pengguna 
	<emphasis>joe</emphasis>.
      </para>

      <programlisting>
user::rwx
user:joe:r--
group::---
mask::r--
other::---
      </programlisting>

      <para>
	Untuk membuatnya menjadi lebih kompleks (dan canggih), beberapa sistem GNU/Linux 
	menambahkan kontrol akses yang lebih ketat dengan Mandatory Access Control Frameworks 
	(MAC) seperti SELinux dan AppArmor. Tetapi kerangka kontrol akses ini diluar batasan dari buku ini.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystems-introduction-links">
      <title>Hubungan</title>

      <para>
	Sebuah isian direktori yang menunjuk pada sebuah inode disebut <emphasis>hard link</emphasis>.  
	Sebagian besar berkas hanya dihubungkan satu kali, tetapi tidak ada yang membatasi Anda untuk 
	membuat hubungan lebih dari satu kali. Hal ini akan meningkatkan kolom <emphasis>links_count</emphasis> 
	dari inode. Ini merupakan cara yang baik bagi sistem untuk melihat inode dan blok data mana yang 
	bebas untuk digunakan. Jika links_count diberi nilai kosong, maka inode tidak dirujuk oleh siapapun, 
	dan bisa dipakai.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-hardlink">
        <title>Struktur dari hard link</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/hardlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/hardlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
	Hard link memiliki dua keterbatasan. Pertama, hard link tidak bisa dihubungkan
	antar sistem berkas, karena mereka menunjuk pada inode. Setiap sistem berkas 
	memiliki inode dan berhubungan dengan nomor inodenya masing-masing. 
	Selain itu, sebagian besar sistem berkas tidak mengijinkan Anda untuk membuat 
	hard link pada direktori. Mengijinkan pembuatan hard link pada direktori bisa 
	menciptakan perulangan direktori, yang berpeluang menimbulkan deadlock dan masalah 
	konsistensi pada sistem berkas. Selain itu, sebagian besar implementasi dari 
	<command>rm</command> dan <command>rmdir</command> tidak tahu bagaimana menyelesaikan 
	direktori tambahan hard link tersebut.
      </para>

      <para>
        <emphasis>Symbolic link</emphasis> tidak memiliki keterbatasan ini, karena mereka 
	menunjuk ke nama berkas, bukan ke inode. Ketika symbolic link digunakan, sistem operasi 
	akan mengikuti path ke link tersebut. Symbolic links juga bisa menunjuk ke berkas yang 
	tidak lagi ada, karena hanya berisi nama. Link semacam itu disebut dengan dangling link 
	(link teruntai).
      </para>

      <figure xml:id="chap-filesystems-introduction-links-symlink">
        <title>Struktur dari symbolic link</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/symlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/symlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>
	  Jika Anda sampai ke administrasi sistem, sangatlah baik untuk sadar terhadap 
	  implikasi keamanan dari hard link. Jika direktori <filename>/home</filename> 
	  berada dalam sistem berkas yang sama dengan sembarang berkas biner sistem, seorang 
	  pengguna bisa membuat hard links ke berkas-berkas biner. Dalam kasus sebuah program 
	  yang cacat diupgrade, link pada direktori home pengguna akan tetap menunjuk pada program
	  biner yang lama, yang memberikan pengguna akses ke program yang cacat.
	</para>

        <para>
	  Untuk alasan ini, maka sangat bagus untuk meletakkan sembarang direktori yang bisa ditulis 
	  oleh pengguna pada sistem berkas yang berbeda. Dalam implementasinya, hal ini berarti paling 
	  tidak meletakkan <filename>/home</filename> dan <filename>/tmp</filename> pada sistem berkas
	  yang berbeda.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystems-analyzing">
    <title>Menganalisa Berkas</title>

    <para>
      Sebelum melanjutkan ke topik yang lebih menarik, kita akan mulai dengan beberapa penggunaan berkas dan 
      direktori dasar.
    </para>

    <sect2 xml:id="chap-filesystems-analyzing-listing">
      <title>Menampilkan berkas</title>

      <para>
	Salah satu hal yang biasa Anda lakukan adalah menampilkan semua atau beberapa berkas. Perintah 
	<command>ls</command> memungkinkan hal ini. Dengan menggunakan <command>ls</command>
	tanpa argumen apapun akan menampilkan isi dari direktori aktual:
      </para>

      <screen>
$ <userinput>ls</userinput>
dns.txt  network-hosts.txt  papers
      </screen>

      <para>
	Jika Anda menggunakan distribusi GNU/Linux, Anda mungkin akan melihat pewarnaan yang menarik
	berdasarkan jenis berkas. Hasil keluaran standar sudah cukup untuk melihat secara sekilas 
	tentang isi sebuah direktori, tetapi jika Anda menginginkan informasi lebih detail, Anda bisa 
	menggunakan parameter <parameter class="command">-l</parameter>. Parameter ini memberikan
	daftar informasi yang lebih lengkap untuk setiap berkas:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Perintah ini memberikan informasi lebih banyak tentang tiga direktori yang ditemukan dengan 
	<command>ls</command>.  Kolom pertama menunjukan hak akses baris. Baris yang menunjukan 
	<filename>papers</filename> dimulai dengan <quote>d</quote>, yang berarti sebuah direktori. 
	Kolom kedua menampilkan jumlah hard link yang mengacu ke inode yang dituju oleh isi direktori
	tersebut. Jika lebih dari satu, maka ada nama berkas yang berbeda untuk satu berkas yang sama.
	Isi direktori biasanya memiliki paling tidak dua hard link, link pada direktori induk dan link
	pada direktori itu sendiri (setiap direktori memiliki <filename>.</filename>, yang mereferensikan 
	ke direktori itu sendiri). Kolom ketiga dan keempat menampilkan pemilik dan grup berkas. Kolom 
	kelima berisi ukuran berkas dalam byte. Kolom keenam menampilkan waktu dan jam modifikasi terakhir 
	dari berkas. Dan akhirnya, kolom terakhir menampilkan nama.
      </para>

      <para>
	Berkas yang diawali dengan tanda titik (.) tidak akan ditampilkan oleh sebagian besar aplikasi, 
	termasuk <command>ls</command>. Anda bisa menampilkan berkas-berkas ini, dengan menambahkan opsi 
	<parameter class="command">-a</parameter> kepada <command>ls</command>:
      </para>

      <screen>
$ <userinput>ls -la</userinput>
total 60
drwxrwxr-x   3 daniel daniel  4096 Sep 11 10:01 .
drwx------  88 daniel daniel  4096 Sep 11 10:01 ..
-rw-rw-r--   1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--   1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x   2 daniel daniel  4096 Sep  4 15:55 papers
-rw-rw-r--   1 daniel daniel     5 Sep 11 10:01 .settings
      </screen>

      <para>
	Seperti yang Anda lihat, terdapat tambahan tiga data baru. Pertama-tama, berkas 
	<filename>.settings</filename> sekarang ditampilkan. Selain itu, Anda bisa meilhat dua data direktori tambahan, 
	<filename>.</filename> dan <filename>..</filename>. Ini merepresentasikan direktori aktual dan direktori 
	induk.
      </para>

      <para>
	Pada awal bab ini (<xref
	linkend="chap-filesystem-introduction-atoms"/>) kita membicarakan tentang inode. Nomor inode yang ditunjuk 
	bisa ditampilkan dengan parameter <parameter class="command">-i</parameter>. Misalkan saya telah membuat 
	sebuah hard link ke inode yang menunjuk ke inode yang sama dengan <filename>dns.txt</filename>, maka mereka 
	seharusnya memiliki nomor inode yang sama. Hasil keluaran dari perintah <command>ls</command> berikut 
	membuktikan bahwa hal ini benar:
      </para>

      <screen>
$ <userinput>ls -i dns*</userinput>
3162388 dns-newhardlink.txt
3162388 dns.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-file">
      <title>Menentukan jenis berkas</title>

      <para>
	Seringkali Anda membutuhkan bantuan untuk menentukan jenis sebuah berkas. Ini adalah kondisi dimana utilitas
	<command>file</command> menjadi penting. Misalkan saya menemukan sebuah berkas bernama <filename>HelloWorld.class</filename> 
	pada disk saya. Saya berpendapat bahwa berkas ini berisi Java bytecode, tetapi kita bisa menggunakan 
	<command>file</command> untuk memeriksanya:
      </para>

      <screen>
$ <userinput>file HelloWorld.class</userinput>
HelloWorld.class: compiled Java class data, version 49.0
      </screen>

      <para>
	Berkas ini jelas Java bytecode. <command>file</command> cukup cerdas, dan menangani sebagian besar apapun
	yang Anda kirimkan. Sebagai contoh, Anda bisa memintanya memberikan informasi tentang sebuah node device:
      </para>

      <screen>
$ <userinput>file /dev/zero</userinput>
/dev/zero: character special (1/5)
      </screen>

      <para>
	Atau symbolic link:
      </para>

      <screen>
$ <userinput>file /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: symbolic link to `Xorg'
      </screen>

      <para>
	Jika Anda tertarik dengan berkas <filename>/usr/X11R6/bin/X</filename>, Anda bisa menggunakan opsi 
	<parameter class="command">-L</parameter> dari <command>file</command>:
      </para>

      <screen>
$ <userinput>file -L /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: setuid writable, executable, regular file, no read permission
      </screen>

      <para>
	Anda mungkin heran kenapa <command>file</command> bisa menentukan jenis berkas dengan mudah. Sebagian 
	besar berkas dimulai dengan apa yang disebut dengan <emphasis>magic number</emphasis>, yaitu angka unik 
	yang memberitahukan kepada program yang bisa membaca berkas apa jenis berkas tersebut. Program 
	<command>file</command> menggunakan sebuah berkas yang menjelaskan banyak jenis berkas dan magic numbernya.
	Sebagai contoh, magic file pada sistem saya berisi baris-baris berikut untuk berkas class Java yang sudah 
	dicompile:
      </para>

      <programlisting>
# Java ByteCode
# From Larry Schwimmer (schwim@cs.stanford.edu)
0       belong          0xcafebabe      compiled Java class data,
>6      beshort x       version %d.
>4      beshort x       \b%d
      </programlisting>

      <para>
	Data ini menunjukan bahwa jika berkas diawali dengan magic number heksadesimal dengan tipe data long (32-bit)
	<emphasis>0xcafebabe</emphasis><footnote>
          <para>Ya, Anda bisa kreatif dengan magic number tersebut!</para> </footnote>, adalah berkas yang berisi 
          <quote>data class Java yang terkompilasi</quote>. Teks sederhana yang mengikutinya menentukan versi format berkas class.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-integrity">
      <title>Integritas berkas</title>

      <para>
	Sebelum kita melihat pada pengujian integritas berkas yang lebih canggih, <!-- XXX xref --> kita akan melihat pada 
	utilitas <command>cksum</command>. <command>cksum</command> bisa mengkalkulasi cyclic redundancy check (CRC) dari sebuah berkas
	input. Ini merupakan metode matematis untuk mengkalkulasi nomor unik untuk sebuah berkas. Anda bisa menggunakan nomor ini 
	untuk menguji apakah sebuah berkas sudah berubah atau belum (misalnya setelah mendownload berkas dari server). Anda bisa 
	menentukan berkas yang akan dihitung sebagai parameter kepada <command>cksum</command>, dan <command>cksum</command> 
	akan menghitung CRC, ukuran berkas dalam byte, dan nama berkas:
      </para>

      <screen>
$ <userinput>cksum myfile</userinput>
1817811752 22638 myfile
      </screen>

      <para>
	Slackware Linux juga menyediakan utilitas untuk mengkalkulasi checksum berdasarkan hash satu arah (misalnya MD5 atau SHA-1).
	<!-- XXX - elaborate -->
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-viewing">
      <title>Melihat berkas</title>

      <para>
	Karena sebagian besar berkas pada sistem UNIX adalah berkas teks, mereka sangatlah mudah untuk dilihat dari terminal berbasis 
	karakter atau emulasi terminal. Cara primitif untuk melihat isi sebuah berkas dengan menggunakan <command>cat</command>. 
	<command>cat</command> memberkas berkas yang ditentukan sebagai parameter per baris, dan menampilkan baris pada standard output. 
	Sehingga, Anda bisa menulis isi dari berkas <filename>note.txt</filename> ke terminal dengan <command>cat note.txt</command>. 
	Meskipun beberapa sistem dan sebagian besar emulasi terminal menyediakan dukungan untuk penggeseran (scrolling), ini bukanlah cara 
	terbaik untuk melihat berkas yang besar. Anda bisa mengirimkan keluaran perintah <command>cat</command> ke <command>less</command> 
	menggunakan pipe:
      </para>

      <screen>
$ <userinput>cat note.txt | less</userinput>
      </screen>

      <para>
	atau biarkan <command>less</command> membaca berkas secara langsung:
      </para>

      <screen>
$ <userinput>less note.txt</userinput>
      </screen>

      <para>
	Perintah <command>less</command> membuat Anda mampu menggeser maju dan mundur dari sebuah berkas. <xref
	linkend="chap-filesystem-analyzing-viewing-less-keys"/> menyediakan gambaran tentang kunci penting yang 
	biasa digunakan untuk mengendalikan <command>less</command>
      </para>

      <table xml:id="chap-filesystem-analyzing-viewing-less-keys">
        <title>kunci perintah less</title>

        <tgroup cols="2" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Kunci</entry>
              <entry>Deskripsi</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>j</entry>
              <entry>Geser maju satu baris.</entry>
            </row>
            <row>
              <entry>k</entry>
              <entry>Geser mundur satu baris.</entry>
            </row>
            <row>
              <entry>f</entry>
              <entry>Geser maju satu layar.</entry>
            </row>
            <row>
              <entry>b</entry>
              <entry>Geser mundur satu layar.</entry>
            </row>
            <row>
              <entry>q</entry>
              <entry>Keluar dari less.</entry>
            </row>
            <row>
              <entry>g</entry>
              <entry>Lompat ke awal berkas.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>Lompat ke akhir berkas.</entry>
            </row>
            <row>
              <entry>/<emphasis>pola</emphasis></entry>
              <entry> Mencari <emphasis>pola</emphasis> <link xl:href="#chap-textproc-regexps">regular expression</link>. </entry>
            </row>
            <row>
              <entry>n</entry>
              <entry> Mencari kecocokan berikutnya dari regular expression sebelumnya.
              </entry>
            </row>
            <row>
              <entry>m<emphasis>huruf</emphasis></entry>
              <entry> Menandai posisi aktual pada berkas dengan <emphasis>huruf</emphasis>.
              </entry>
            </row>
            <row>
              <entry>'<emphasis>huruf</emphasis></entry>
              <entry>Lompat ke tanda <emphasis>huruf</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Kunci perintah yang bisa diakuantifikasi bisa diawali dengan angka. Sebagai contoh <emphasis>11j</emphasis> akan 
	menggeser sebanyak sebelas baris, dan <emphasis>3n</emphasis> mencari kecocokan ketiga dari regular expression 
	yang sudah ditentukan sebelumnya.
      </para>

      <para>
	Slackware Linux juga menyediakan alternatif bagi <command>less</command>, perintah <quote>more</quote>.
	Kita tidak akan membahas <emphasis>more</emphasis> disini, <command>less</command> lebih nyaman, dan juga lebih populer.
      </para>

    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-filesize">
      <title>Ukuran berkas dan direktori</title>

      <para>
	Hasil keluaran <command>ls -l</command> yang kita lihat sebelumnya menghasilkan informasi tentang ukuran berkas. 
	Meskipun menyediakan informasi yang cukup tentang ukuran sebuah berkas, Anda mungkin hendak mengumpulkan informasi tentang 
	sekumpulkan berkas atau direktori. Ini adalah kondisi dimana perintah <command>du</command> dipakai. Secara default, 
	<command>du</command> mencetak ukuran berkas per direktori. Misalnya:
      </para>

      <screen>
$ <userinput>du ~/qconcord</userinput>
72      /home/daniel/qconcord/src
24      /home/daniel/qconcord/ui
132     /home/daniel/qconcord
      </screen>

      <para>
        Secara default, <command>du</command> merepresentasikan ukuran dalam unit 1024 byte. Anda bisa secara eksplisit 
	menentukan bahwa <command>du</command> harus menggunakan unit 1024 byte dengan menambahkan <parameter class="command" >-k</parameter>. 
	Hal ini berguna saat menuliskan script, karena sistem lain memiliki nilai default untuk menggunakan blok 512-byte. Sebagai 
	contoh:
      </para>

      <screen>
$ <userinput>du -k ~/qconcord</userinput>
72	/home/daniel/qconcord/src
24	/home/daniel/qconcord/ui
132	/home/daniel/qconcord
      </screen>

      <para>
	Jika Anda hendak melihat penggunaan disk per berkas, Anda bisa menambahkan <parameter class="command">-a</parameter>:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord</userinput>
8       /home/daniel/qconcord/ChangeLog
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
12      /home/daniel/qconcord/Makefile
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
8       /home/daniel/qconcord/qconcord.pro
132     /home/daniel/qconcord
      </screen>

      <para>
	Anda juga bisa menggunakan nama berkas atau wildcard sebagai parameter. Tetapi hal ini tidak akan mencetak 
	ukuran berkas dalam sub direktori, kecuali <parameter class="command">-a</parameter> dipakai:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord/*</userinput>
8       /home/daniel/qconcord/ChangeLog
12      /home/daniel/qconcord/Makefile
8       /home/daniel/qconcord/qconcord.pro
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
      </screen>

      <para>
	Jika Anda hendak melihat total ukuran penggunaan disk untuk berkas dan sub direktori yang ada didalam sebuah 
	direktori, gunakan <parameter class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>du -k -s ~/qconcord</userinput>
132     /home/daniel/qconcord
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-directories">
    <title>Bekerja dengan direktori</title>

    <para>
      Setelah melihat gambaran tentang direktori pada <xref
      linkend="chap-filesystem-introduction-atoms"/>, kita akan melihat pada beberapa perintah yang berhubungan 
      dengan direktori.
    </para>

    <sect2 xml:id="chap-filesystem-directories-listing">
      <title>Menampilkan direktori</title>

      <para>
	Perintah <command>ls</command> yang kita lihat pada <xref linkend="chap-filesystems-analyzing-listing"/> 
	juga bisa digunakan untuk menampilkan direktori dalam berbagai cara. Seperti yang sudah kita lihat, hasil 
	keluaran dari <command>ls</command> meliputi direktori, dan direktori bisa diidentifikasi dengan kolom 
	pertama pada daftar yang lengkap:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Jika nama direktori, atau jika wildcard ditentukan <command>ls</command> akan menampilkan isi dari direktori
	atau direktori yang sesuai dengan wildcard. Sebagai contoh, jika terdapat direktori <filename>papers</filename>, 
	<command>ls paper*</command> akan menampilkan isi dari direktori <filename>paper</filename>. Hal ini cukup 
	menganggu jika Anda hanya ingin lihat yang sesuai, dan bukan isi dari direktori. Parameter <parameter
	class="command">-d</parameter> menghindari rekursi ini:
      </para>

      <screen>
$ <userinput>ls -ld paper*</userinput>
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Anda juga bisa melihat isi dari sebuah direktori dan sub direktori secara rekursif dengan parameter <parameter
	class="command">-R</parameter>:
      </para>

      <screen>
$ <userinput>ls -R</userinput>
.:
dns.txt  network-hosts.txt  papers

./papers:
cs  phil

./papers/cs:
entr.pdf

./papers/phil:
logics.pdf
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-directories-management">
      <title>Membuat dan menghapus direktori</title>

      <para>
	UNIX menyediakan perintah <command>mkdir</command> untuk membuat direktori. Jika path relatif diberikan, direktori 
	akan dibuat pada direktori aktif. Sintaks dasarnya sangatlah sederhana: <emphasis>mkdir &lt;nama&gt;</emphasis>, 
	sebagai contoh:
      </para>

      <screen>
$ <userinput>mkdir mydir</userinput>
      </screen>

      <para>
	Secara default, <command>mkdir</command> hanya membuat satu level direktori. Jadi, jika Anda menggunakan <command>mkdir</command> 
	untuk membuat <filename>mydir/mysubdir</filename>, <command>mkdir</command> akan gagal jika <filename>mydir</filename> 
	belum ada sebelumnya. Jika Anda ingin membuat kedua direktori sekaligus, gunakan parameter <parameter class="command">-p</parameter> :
      </para>

      <screen>
$ <userinput>mkdir -p mydir/mysubdir</userinput>
      </screen>

      <para>
	<command>rmdir</command> menghapu sebuah direktori. Perilakunya sama dengan <command>mkdir</command>. <command>rmdir
	mydir/mysubdir</command> menghapus <filename>mydir/subdir</filename>,
	sementara <command>rmdir -p mydir/mysubdir</command> menghapus 
	<filename>mydir/mysubdir</filename> lalu 
	<filename>mydir</filename>.
      </para>

      <para>
	Jika sebuah sub direktori yang akan kita hapus berisi isi direktori lain, <command>rmdir</command> akan gagal. Jika Anda ingin 
	menghapus sebuah direktori, termasuk semua isinya, gunakan perintah <command>rm</command>. <!-- XXX - xref -->
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-managing">
    <title>Mengelola berkas dan direktori</title>

    <sect2 xml:id="chap-filesystem-managing-copying">
      <title>Menyalin</title>

      <para>
	Berkas dan direktori bisa disalin dengan perintah <command>cp</command>. Pada sintaks dasarnya, berkas sumber dan target 
	akan ditentukan. Contoh berikut akan membuat salinan dari berkas <filename>file1</filename> dengan nama <filename>file2</filename>:
      </para>

      <screen>
$ <userinput>cp file1 file2</userinput>
      </screen>

      <para>
	Tidaklah mengherankan jika path relatif dan absolut juga bekerja:
      </para>

      <screen>
$ <userinput>cp file1 somedir/file2</userinput>
$ <userinput>cp file1 /home/joe/design_documents/file2</userinput>
      </screen>

      <para>
	Anda juga bisa menentukan direktori sebagai parameter kedua. Jika terdapat kasus ini, <command>cp</command> akan membuat salinan 
	berkas tersebut pada direktori tersebut, memberikan nama berkas yang sama dengan berkas asli. Jika terdapat lebih dari satu 
	parameter, parameter akan digunakan sebagai direktori target. Sebagai contoh:
      </para>

      <screen>
$ <userinput>cp file1 file2 somedir</userinput>
      </screen>

      <para>
	akan menyalin <filename>file1</filename> dan <filename>file2</filename> ke direktori <filename>somedir</filename>. Anda tidak bisa
	 menyalin banyak berkas ke satu berkas. Anda harus menggunakan <command>cat</command>: <!-- XXX href -->
      </para>

      <screen>
$ <userinput>cat file1 file2 > combined_file</userinput>
      </screen>

      <para>
	Anda juga bisa menggunakan <command>cp</command> untuk menyalin direktori, dengan menambahkan <parameter class="command">-R</parameter>. 
	Hal ini akan menyalin sebuah direktori dan semua sub direktorinya secara rekursif. Jika direktori target sudah ada, sumber direktori 
	atau direktori akan diletakkan dibawah direktori target. Jika direktori target belum ada, maka akan diciptakan jika hanya terdapat 
	satu direktori sumber.
      </para>

      <screen>
$ <userinput>cp -r mytree tree_copy</userinput>
$ <userinput>mkdir trees</userinput>
$ <userinput>cp -r mytree trees</userinput>
      </screen>

      <para>
	Setelah mengeksekusi perintah diatas, akan terdapat dua salinan dari direktori <filename>mytree</filename>, <filename>tree_copy</filename> dan 
        <filename>trees/mytree</filename>. Percobaan untuk menyalin dua direktori pada target yang tidak ada akan gagal:
      </para>

      <screen>
$ <userinput>cp -R mytree mytree2 newdir</userinput>
usage: cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target
       cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory
      </screen>

      <note>
	<para>
	  Parameter <parameter class="command">-r</parameter> sudah ada pada banyak sistem UNIX untuk menyalin direktori secara rekursif. 
	  Namun, perilaku dari parameter ini bisa jadi tergantung dari implementasinya, dan Spesifikasi UNIX versi 3 menyatakan bahwa parameter 
	  ini bisa dihapus dari versi yang akan datang.
	</para>
      </note>

      <para>
	Ketika Anda menyalin berkas secara rekursif, merupakan ide bagus untuk menentukan perilaku dari <command>cp</command> ketika 
	symbolic link ditemukan, jika Anda ingin menggunakan <command>cp</command> pada script yang bersifat portable. Spesifikasi UNIX versi 
	3 tidak menentukan bagaimana seharusnya.Jika <parameter class="command">-P</parameter> digunakan, symbolic links akan tidak diikuti, 
	sehingga hanya menyalin link itu sendiri. Jika <parameter class="command">-H</parameter> digunakan, symbolic links yang ditentukan 
	sebagai parameter bagi <command>cp</command> bisa diikuti, tergantung dari jenis dan isi dari berkas. Jika <parameter class="command">-L</parameter> 
	digunakan, symbolic links yang ditentukan sebagai parameter pada <command>cp</command> dan symbolic links yang ditemukan akan 
	selama penyalinan akan diikuti, tergantung dari isi berkas.
      </para>

      <para>
	Jika Anda ingin mempertahankan kepemilikan, bit SGID/SUID, dan waktu modifikasi dan akses sebuah berkas, Anda bisa menggunakan 
	parameter <parameter>-p</parameter>. Parameter ini akan mencoba mempertahankan properti pada saat penyalinan berkas atau direktori. 
	Implementasi yang bagus dari <command>cp</command> menyediakan beberapa proteksi tambahan - jika berkas target sudah ada, maka tidak akan 
	ditimpa jika metadata yang berhubungan tidak bisa dipertahankan.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-moving">
      <title>Memindahkan berkas dan direktori</title>

      <para>
	Perintah UNIX untuk memindahkan berkas, <command>mv</command>, bisa memindahkan atau mengganti nama berkas atau direktori. Apa yang 
	sebenarnya terjadi tergantung dari lokasi berkas atau direktori. Jika berkas sumber dan tujuan berada dalam sistem berkas yang sama, 
	<command>mv</command> hanya membuat hard link baru, yang akan mengganti nama berkas atau direktori. Jika keduanya berada dalam 
	sistem berkas yang berbeda, berkas akan disalin, dan berkas atau direktori sumber akan diputuskan linknya.
      </para>

      <para>
	Sintaks dari <command>mv</command> hampir serupa dengan <command>cp</command>. Sintaks dasar untuk mengganti nama 
	<filename>file1</filename> menjadi <filename>file2</filename>:
      </para>

      <screen>
$ <userinput>mv file1 file2</userinput>
      </screen>

      <para>
	Sintaks yang sama bisa digunakan untuk dua direktori., yang akan mengganti nama direktori yang diberikan pada parameter pertama menjadi 
	nama yang diberikan pada parameter kedua.
      </para>

      <para>
	Ketika parameter terakhir adalah direktori yang sudah ada, berkas atau direktori yang ditentukan pada parameter pertama, akan disalin 
	pada direktori tersebut. Pada kasus ini, Anda bisa menentukan banyak berkas atau direktori. Sebagai contoh:
      </para>

      <screen>
$ <userinput>targetdir</userinput>
$ <userinput>mv file1 directory1 targetdir</userinput>
      </screen>

      <para> Hal ini menciptakan direktori <filename>targetdir</filename>, dan memindahkan
        <filename>file1</filename> dan <filename>directory1</filename> ke direktori ini. </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-removing">
      <title>Menghapus berkas dan direktori</title>

      <para>
	Berkas dan direktori bisa dihapus dengan perintah <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Perintah ini akan menghapus link berkas dan direktori. Jika tidak ada lagi link pada sebuah berkas, 
	inode dan blok disk bisa dipakai untuk berkas yang lain. Berkas bisa dihapus dengan menyediakan berkas yang akan dihapus 
	sebagai parameter pada <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Jika berkas tidak dapat ditulisi, <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> akan bertanya sebagai konfirmasi. Sebagai contoh, untuk menghapus
        <filename>file1</filename> dan <filename>file2</filename>, Anda bisa menjalankan: </para>

      <screen>
$ <userinput>rm file1 file2</userinput>
      </screen>

      <para>
	Jika Anda harus menghapus banyak berkas yang membutuhkan konfirmasi sebelum bisa dihapus, atau jika Anda ingin menggunakan 
	<citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> untuk menghapus berkas dari script yang tidak akan dijalankan pada terminal, tambahkan parameter 
          <parameter class="command">-f</parameter> untuk menimpa penggunaan prompt. Berkas yang tidak bisa ditulis, akan dihapus dengan 
	  <filename>-f</filename> jika kepemilikan berkas mengijinkan hal ini. Parameter ini juga akan mengurangi hasil keluaran pesan kesalahan 
	  pada <emphasis>stderr</emphasis> jika misalnya berkas yang akan dihapus tidak ditemukan. </para>

      <para> Direktori juga bisa dihapus secara rekursif dengan parameter <parameter class="command"
        >-r</parameter>. <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> akan menghapus struktur direktori, menghapus link dan direktori yang ditemukan. Semantik yang sama juga digunakan ketika 
	berkas biasa dihapus, selama <parameter class="command">-f</parameter> dipakai. Untuk memberikan contoh sederhana, Anda bisa menghapus 
	semua berkas dan direktori pada direktori <filename>notes</filename> secara rekursif dengan : </para>

      <screen>
$ <userinput>rm -r notes</userinput>
      </screen>

      <!-- XXX - describe -i flag? -->

      <para> Karena perintah <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> menggunakan fungsi <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>, blok data tidak ditulis ulang pada status yang tidak terinisialisasi. Informasi pada data blok hanya ditulis ulang
	jika dialokasikan dan digunakan pada waktu lain. Untuk menghapus berkas termasuk blok data secara aman, beberapa sistem menyediakan 
	perintah <citerefentry>
          <refentrytitle>shred</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> yang menimpa blok data dengan data acak. Tetapi hal ini tidak efektif pada kebanyakan sistem berkas modern (journaling), 
	karena tidak menulis data pada tempatnya. </para>

      <para> Perintah <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> menyediakan implementasi dari fungsi <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>. Sangat jarang digunakan, karena tidak bisa menghapus direktori. </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-permissions">
    <title>Hak akses</title>

    <para> Kita melihat hak akses berkas dan direktori pada <xref
        linkend="chap-filesystem-introduction-permissions"/>. Pada bagian ini, kita akan melihat pada perintah <citerefentry>
        <refentrytitle>chown</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry> dan <citerefentry>
        <refentrytitle>chmod</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry>, yang digunakan untuk menentukan kepemilikan dan hak akses berkas. Setelah itu, kita akan melihat 
      perluasan dari hak akses yang disebut Access Control Lists (ACL). </para>

    <sect2 xml:id="chap-filesystem-permissions-ownership">
      <title>Mengganti kepemilikan berkas</title>

      <para> Seperti yang sudah kita lihat sebelumnya, setiap berkas memiliki ID pemilik (user) dan ID grup yang disimpan pada inode. 
      Perintah <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> bisa digunakan untuk menentukan kolom ini. Hal ini bisa dilakukan dengan ID numerik, atau namanya. Sebagai contoh, 
	untuk mengganti kepemilikan dari berkas <filename>note.txt</filename> menjadi <emphasis>john</emphasis>, dan grupnya menjadi 
        <emphasis>staff</emphasis>, digunakan perintah berikut: </para>

      <screen>
$ <userinput>chown john:staff note.txt</userinput>
      </screen>

      <para> Anda bisa menghilangkan salah satu komponen, jika Anda ingin menentukan salah satunya. Jika Anda hanya ingin menentukan 
        nama pengguna, Anda bisa mengabaikan titik dua. Jadi perintah diatas bisa dibagi menjadi dua langkah: </para>

      <screen>
$ <userinput>chown john note.txt</userinput>
$ <userinput>chown :staff note.txt</userinput>
      </screen>

      <para> Jika Anda ingin mengganti kepemilikan dari direktori, dan semua berkas atau direktori dibawahnya, Anda bisa menambahkan 
      <parameter class="command">-R</parameter> pada <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>: </para>

      <screen>
$ <userinput>chown -R john:staff notes</userinput>
      </screen>

      <para> Jika nama pengguna dan grup ditentukan dan bukan ID, nama akan dikonversi oleh <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Konvensi ini biasanya bergantung dari basis data kata sandi sistem. Jika Anda beroperasi pada sistem 
	berkas yang menggunakan basis data kata sandi yang berbeda (contohnya Anda me-mount sistem berkas root dari sistem lain 
	untuk proses perbaikan), akan sangat berguna untuk mengganti kepemilikan berkas dengan ID pengguna atau grup. Dengan 
	cara ini, Anda bisa mempertahankan pemetaan nama pengguna/grup. Jadi, mengganti kepemilikan dari <filename>note</filename> 
	menjadi UID 1000 dan GUID 1000 dilakukan dengan cara berikut: </para>

      <screen>
$ <userinput>chown 1000:1000 note.txt</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-permbits">
      <title>Mengganti bit hak akses berkas</title>

      <para> Setelah membaca perkenalan terhadap hak akses sistem berkas pada <xref
          linkend="chap-filesystem-introduction-permissions"/>, mengganti bit hak akses yang disimpan pada inode menjadi mudah 
	  dengan perintah <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> menerima representasi numerik dan simbolik dari hak akses.
        Merepresentasikan hak akses dari berkas secara numerik sangatlah mudah, karena mengijinkan untuk menentukan  semua hak 
	akses yang relevan. Sebagai contoh: </para>

      <screen>
$ <userinput>chmod 0644 note.txt</userinput>
      </screen>

      <para> Akan membuat <filename>note.txt</filename> dapat dibaca dan ditulis oleh pemilik berkas, dan 
        dapat dibaca oleh grup dan lainnya. </para>

      <para> Hak akses simbolik bekerja dengan penambahan atau mengurangan hak akses, dan mengijinkan perubahan relatif
        dari hak akses berkas. Sintaks untuk hak akses simbolik adalah : </para>

      <screen>
[ugo][-+][rwxst]
      </screen>

      <para> Komponen pertama menentukan kelas pengguna dimana perubahan hak akses akan diterapkan 
        (pemilik, grup atau lainnya). Banyak karakter pada komponen ini bisa dikombinasikan. Komponen kedua menghilangkan  
	(<emphasis>-</emphasis>), atau menambahkan hak akses (<emphasis>+</emphasis>). Komponen ketiga adalah hak akses
	(read, write, execute, set UID/GID on execution, sticky). Banyak komponen bisa ditentukan pada untuk komponen ini. 
	Mari kita lihat pada beberapa contoh untuk memperjelas: </para>

      <screen>
ug+rw        # Memberikan hak akses baca/tulis pada pemilik dan grup berkas
chmod go-x   # Mengambil hak akses dari grup dan lainnya
chmod ugo-wx # Tidak mengijinkan semua kelas pengguna untuk menulis ke berkas dan mengeksekusi berkas.
      </screen>

      <para> Perintah ini bisa digunakan seperti berikut: </para>

      <screen>
$ <userinput>chmod ug+rw note.txt</userinput>
$ <userinput>chmod go-x script1.sh</userinput>
$ <userinput>chmod ugo-x script2.sh</userinput>
      </screen>

      <para> Hak akses dari berkas dan direktori bisa diganti secara rekursif dengan <parameter
          class="command">-R</parameter>. Perintah berikut akan membuat direktori 
        <filename>notes</filename> world-readable (bisa dibaca oleh semuanya), termasuk isinya: </para>

      <screen>
$ <userinput>chmod -R ugo+r notes</userinput>
      </screen>

      <para> Perhatian tambahan harus dilakukan ketika bermain dengan direktori, karena <emphasis>x</emphasis> 
        memiliki arti khusus dalam konteks direktori. Pengguna yang memiliki hak akses eksekusi pada direktori bisa 
        mengakses sebuah direktori. Pengguna yang tidak memiliki hak akses eksekusi pada direktori tidak bisa mengakses direktori. 
	Karena perilaku ini, seringkali lebih mudah untuk mengganti hak akses dari struktur direktori dan berkas-berkasnya
	dengan bantuan perintah <citerefentry>
          <refentrytitle>find</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> <!-- XXX xref -->. </para>

      <para> Terdapat bit hak akses tambahan yang bisa ditentukan yang memiliki arti khusus. SUID dan SGID adalah yang paling menarik 
       dari bit tambahan tersebut. Bit ini mengganti ID pengguna dan grup yang digunakan ketika berkas dieksekusi. Perintah 
       <command>su(1)</command> adalah contoh berkas yang memiliki bit SUID yang aktif: </para>

      <screen>
$ <userinput>ls -l /bin/su</userinput>
-rwsr-xr-x  1 root root 60772 Aug 13 12:26 /bin/su
      </screen>

      <para> Hal ini berarti bahwa perintah <command>su</command> berjalan sebagai pengguna <emphasis>root</emphasis> ketika dieksekusi. 
      Bit SUID bisa ditentukan dengan modifier <emphasis>s</emphasis>. Sebagai contoh, jika bit SUID belum ditentukan pada 
          <filename>/bin/su</filename> hal ini bisa dilakukan dengan : </para>

      <screen>
$ <userinput>chmod u+s /bin/su</userinput>
      </screen>

      <note>
        <para> Harap waspada bahwa bit SUID dan SGID memiliki dampak terhadap keamanan. Jika sebuah program dengan bit ini memiliki sebuah 
	kesalahan, maka bisa dieksploitasi untuk mendapatkan hak akses dari pemilik atau grup berkas. Karena alasan inilah, disarankan 
	untuk meminimalkan penggunaan bit SUID dan SGID pada berkas.</para>
      </note>

      <para> Bit sticky juga menarik jika berhubungan dengan direktori. Bit ini tidak mengijinkan pengguna untuk mengganti berkas yang dihapus linknya 
      yang tidak dimilikinya, pada direktori dimana mereka memiliki hak akses tulis. Hal ini biasanya digunakan pada direktori yang bersifat 
      world-writeable (bisa ditulis oleh semua), seperti direktori temporal (<filename>/tmp</filename>) pada banyak sistem UNIX. 
      Tag sticky bisa ditentukan dengan <emphasis>t</emphasis>: </para>

      <screen>
$ <userinput>chmod g+t /tmp</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-umask">
      <title>Mask pembuatan berkas</title>

      <para>
	Pertanyaan yang tersisa adalah apa hak akses awal yang digunakan ketika sebuah file dibuat. Hal ini 
	tergantung dari dua faktor: mode yang dikirimkan ke system call <emphasis>open(2)</emphasis>, yang 
	digunakan untuk membuat sebuah berkas, dan mask pembuatan berkas yang aktif. Mask pembuatan berkas
	bisa direpresentasikan sebagai bilangan oktal. Hak akses yang efektif untuk membuat berkas ditentukan sebagai 
	<emphasis>mode &amp; ~mask</emphasis>. Atau, jika direpresentasikan dalam model oktal, Anda bisa mengurangkan
	digit dari mask dari mode. Sebagai contoh, jika sebuah berkas dibuat dengan hak akses <emphasis>0666</emphasis> 
	(dapat dibaca dan ditulis oleh pengguna, grup, dan lainnya), dan mask pembuatan berkas efektif adalah 
	<emphasis>0022</emphasis>, maka hak akses berkas yang efektif adalah <emphasis>0644</emphasis>. Mari kita 
	lihat contoh lain. Misalkan berkas masih dibuat dengan hak akses <emphasis>0666</emphasis>, dan Anda lebih 
	waspada, dan ingin menghapus semua hak akses baca dan tulis pada grup dan lainnya... Ini berarti Anda harus 
	menentukan mask pembuatan berkas menjadi <emphasis>0066</emphasis>, karena mengurangi <emphasis>0066</emphasis> 
	dari <emphasis>0666</emphasis> menghasilkan <emphasis>0600</emphasis>
      </para>
      
      <para>
        Mask pembuatan berkas efektif dapat dilihat dan ditentukan dengan perintah <command>umask</command>, yang biasanya 
	merupakan perintah bawaan shell. Mask bisa dicetak dengan menjalankan <command>umask</command> tanpa parameter:
      </para>
      
      <screen>
$ <userinput>umask</userinput>
0002
      </screen>
      
      <para>
        Mask bisa ditentukan dengan memberikan nomor oktal sebagai parameter. Misalnya:
      </para>
      
      <screen>
$ <userinput>umask 0066</userinput>
      </screen>
      
      <para>
        Kita bisa memverifikasi hasilnya dengan membuat sebuah berkas baru:
      </para>
      
      <screen>
$ <userinput>touch test</userinput>
$ <userinput>ls -l test</userinput>
-rw-------  1 daniel daniel 0 Oct 24 00:10 test2
      </screen>
      
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-acl">
      <title>Access Control Lists</title>

      <para>
	Access Control lists (<acronym>ACL</acronym>s) adalah pengembangan dari hak akses berkas UNIX tradisional, 
	yang mengijinkan kontrol akses yang lebih ketat. Sebagian besar sistem yang mendukung sistem berkas ACL 
	mengimplementasikannya seperti yang ditentukan dalam draft spesifikasi POSIX.1e dan POSIX.2c. Sistem UNIX 
	dan UNIX-like yang sudah mengimplementasikan ACL sesuai draft ini adalah FreeBSD, Solaris, and Linux.
      </para>

      <para>
	Seperti yang kita lihat pada <xref
	linkend="chap-filesystem-introduction-permissions" /> access 
	control lists mengijinkan Anda untuk menggunakan triplet read, write dan execute untuk pengguna atau grup 
	tambahan. Kebalikan dari hak akses berkas tradisional, access control lists tambahan tidak disimpan 
	secara langsung pada node, tetapi pada attribut tambahan yang berhubungan dengan berkas. Dua hal yang perlu 
	diperhatikan ketika Anda menggunakan access control lists adalah tidak semua sistem mendukungnya, dan tidak semua 
	program mendukungnya.
      </para>

      <sect3 xml:id="chap-filesystem-permissions-acl-reading">
	<title>Membaca access control lists</title>

	<para>
	  Pada sebagian besar sistem yang mendukung ACL, <command>ls</command>
	  menggunakan indikator visual untuk menunjukan bahwa terdapat ACL yang berhubungan dengan berkas. Misalnya:
	</para>

	<screen>
$ <userinput>ls -l index.html</userinput>
-rw-r-----+ 1 daniel daniel 3254 2006-10-31 17:11 index.html
	</screen>

	<para>
	  Seperti yang Anda lihat, kolom hak akses menunjukan adanya karakter plus tambahan 
	  (<emphasis>+</emphasis>). Bit hak akses tidak memiliki perilaku seperti yang Anda harapkan. Kita akan lihat 
	  hal itu sebentar lagi.
	</para>

	<para>
	  ACL untuk sebuah berkas dapat dilihat dengan perintah <command>getfacl</command>:
	</para>

	<screen>
$ <userinput>getfacl index.html</userinput>
# file: index.html
# owner: daniel
# group: daniel
user::rw-
group::---
group:www-data:r--
mask::r--
other::---
	</screen>

	<para>
	  Sebagian besar berkas dapat diinterpretasikan dengan mudah: pengguna berkas memiliki hak akses baca/tulis, 
	  grop berkas tidak memiliki hak akses, pengguna dari grup <emphasis>www-data</emphasis> memiliki hak akses baca, 
	  dan lainnya tidak memiliki hak akses apapun. Tetapi kenapa menampilkan tidak ada hak akses untuk grup berkas, 
	  tetapi <command>ls</command> menampilkan? Rahasianya adalah jika ada <emphasis>mask</emphasis>, 
	  <command>ls</command> menampilkan nilai dari mask, dan bukan hak akses grup.
	</para>

	<para>
	  <emphasis>mask</emphasis> digunakan untuk membatasi semua catatan dengan pengecualian untuk pengguna berkas dan untuk 
	  pengguna lainnya. Hapalkan aturan berikut untuk menginterpretasikan ACL:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Hak akses <emphasis>user::</emphasis> berhubungan dengan hak akses pemilik berkas.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Hak akses <emphasis>group::</emphasis> berhubungan dengan grup berkas, kecuali jika terdapat 
	      <emphasis>mask::</emphasis>. Jika terdapat <emphasis>mask::</emphasis>, hak akses dari grup
	      berhubungan dengan isi dari grup dengan nilai mask sebagai hak akses maksimal (berarti hak akses grup 
	      bisa lebih ketat).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Hak akses untuk pengguna dan grup lain berhubungan dengan <emphasis>user:</emphasis> dan 
	      <emphasis>group:</emphasis>, dengan nilai <emphasis>mask::</emphasis> sebagai hak akses maksimalnya.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Aturan kedua dan ketiga bisa dengan jelas diamati jika terdapat sebuah pengguna atau grup yang memiliki hak 
	  akses yang lebih dari mask untuk berkas tersebut:
	</para>

	<screen>
$ <userinput>getfacl links.html</userinput>
# file: links.html
# owner: daniel
# group: daniel
user::rw-
group::rw-                      #effective:r--
group:www-data:rw-              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Meskipun hak akses baca dan tulis ditentukan untuk berkas dan berkas dan grup <emphasis>www-data</emphasis>, 
	  kedua grup akan secara efektif hanya memiliki hak akses baca, karena ini merupakan hak akses maksimal yang 
	  diijinkan oleh mask.
	</para>

	<para>
	  Aspek lain yang harus diperhatikan adalah penanganan ACL untuk direktori. Access control list bisa ditambahkan 
	  ke direktori untuk mengendalikan akses, tetapi direktori juga memiliki <emphasis>default ACL</emphasis> 
	  yang menentukan ACL awal untuk berkas dan direktori yang dibuat pada direktori tersebut.
	</para>

	<para>
	  Misalkan direktori <filename>reports</filename> memiliki ACL berikut:
	</para>

	<screen>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
group:www-data:r-x
mask::r-x
other::---
default:user::rwx
default:group::r-x
default:group:www-data:r-x
default:mask::r-x
default:other::---
	</screen>

	<para>
	  Berkas baru yang dibuat pada direktori <filename>reports</filename> memiliki ACL berdasarkan catatan yang memiliki 
	  awalan <emphasis>default:</emphasis>. Sebagai contoh:
	</para>

	<screen>
$ touch reports/test
$ getfacl reports/test
# file: reports/test
# owner: daniel
# group: daniel
user::rw-
group::r-x                      #effective:r--
group:www-data:r-x              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Seperti yang Anda lihat, ACL default disalin. Bit eksekusi dihapus dari mask, karena berkas baru tidak dibuat 
	  dengan hak akses eksekusi.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-permissions-acl-setting">
	<title>Membuat access control list</title>

	<para>
	  ACL untuk sebuah berkas atau direktori bisa diganti dengan program <command>setfacl</command>. Sayangnya, 
	  penggunaan program ini sangat bergantung dari sistem yang digunakan. Untuk menambah kebingungan, paling tidak 
	  satu parameter (<parameter class="command">-d</parameter>) memiliki arti yang berbeda pada sistem yang berbeda. 
	  Anda bisa berharap bahwa perintah ini akan mendapatkan standarisasi.
	</para>

	<table xml:id="chap-filesystem-permissions-acl-setting-flags">
	  <title>Parameter <command>setfacl</command> spesifik</title>
	  
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operasi</entry>
		<entry>Linux</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Menentukan isi, menghapus semua isi lama</entry>
		<entry><parameter class="command">--set</parameter></entry>
	      </row>
	      <row>
		<entry>Memodifikasi isi</entry>
		<entry><parameter class="command">-m</parameter></entry>
	      </row>
	      <row>
		<entry>Memodifikasi isi ACL default</entry>
		<entry><parameter class="command">-d</parameter></entry>
	      </row>
	      <row>
		<entry>Menghapus isi</entry>
		<entry><parameter class="command">-x</parameter></entry>
	      </row>
	      <row>
		<entry>
		  Menghapus semua isi ACL (kecuali tiga isi yang diperlukan).
		</entry>
		<entry><parameter class="command">-b</parameter></entry>
	      </row>
	      <row>
		<entry>Menghitung ulang mask</entry>
		<entry>
		  Selalu dikalkulasi ulang, kecuali <parameter
		  class="command">-n</parameter> digunakan, atau isi mask ditentukan secara eksplisit.
		</entry>
	      </row>
	      <row>
		<entry>Menggunakan spesifikasi ACL dari sebuah berkas</entry>
		<entry>
		  <parameter class="command">-M</parameter> (memodifikasi),
		  <parameter class="command">-X</parameter> (menghapus),
		  atau <parameter class="command">--restore</parameter>
		</entry>
	      </row>
	      <row>
		<entry>Modifikasi rekursif ACL</entry>
		<entry><parameter class="command">-R</parameter></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Seperti yang sudah kita lihat pada bagian sebelumnya, isi bisa ditentukan untuk pengguna dan grup, 
	  dengan mengikuti sintaks:
	  <emphasis>user/group:name:permissions</emphasis>. Hak akses bisa ditentukan sebagai triplet dengan menggunakan 
	  huruf <emphasis>r</emphasis> (read), <emphasis>w</emphasis> (write), atau <emphasis>x</emphasis> (execute). 
	  Karakter minus (<emphasis>-</emphasis>) digunakan untuk hak akses yang tidak ingin diberikan kepada pengguna 
	  atau grup, karena Solaris membutuhkan hal ini. Jika Anda menginginkan agar tidak ada hak akses sepenuhnya, Anda 
	  bisa menggunakan <emphasis>---</emphasis>.
	</para>

	<para>
	  Spesifikasi untuk pengguna lain, dan mask mengikuti format berikut: <emphasis>other:r-x</emphasis>. Format yang 
	  lebih mudah ditebak juga bisa digunakan: <emphasis>other::r-x</emphasis>.
	</para>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-modify">
	  <title>Memodifikasi isi ACL</title>

	  <para>
	    Operasi paing sederhana adalah untuk memodifikasi sebuah isi ACL. Hal ini akan membuat
	    sebuah isi baru jika isi belum ada sebelumnya. Isi bisa dimodifikasi dengan <parameter
	    class="command">-m</parameter>. Sebagai contoh, misalkan kita hendak memberikan grup 
	    <emphasis>friend</emphasis> akses baca dan tulis pada berkas 
	    <filename>report.txt</filename>. Hal ini bisa dilakukan dengan:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw- report.txt</userinput>
	  </screen>

	  <para>
	    Mask dari isian akan dikalkulasi ulang, melakukan setting menjadi gabungan dari semua isi grup, 
	    dan isi pengguna tambahan:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt</userinput>
# file: report.txt
# owner: daniel
# group: daniel
user::rw-
group::r--
group:friends:rw-
mask::rw-
other::r--
	  </screen>

	  <para>
	    Anda bisa mengkombinasikan banyak isi ACL dengan memisahkannya dengan karakter koma. Sebagai contoh:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw-,group:foes:--- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-removing">
	  <title>Menghapus Isi ACL</title>

	  <para>
	    Sebuah isi dapat dihapus dengan opsi <parameter
	    class="command">-x</parameter>:
	  </para>

	  <screen>
$ <userinput>setfacl -x group:friends: report.txt</userinput>
	  </screen>

	  <para>
	    Karakter titik dua di akhir bisa diabaikan.
	  </para>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-new">
	  <title>Membuat ACL Baru</title>

	  <para>
	    Opsi <parameter class="command">--set</parameter> digunakan untuk membuat 
	    sebuah ACL baru untuk sebuah berkas, menghapus isi ACL yang ada, kecuali isi 
	    yang benar-benar diperlukan. Isi untuk file pengguna, grup, dan lainnya juga
	    ditentukan. Sebagai contoh:
	  </para>

	  <screen>
$ <userinput>setfacl --set user::rw-,group::r--,other:---,group:friends:rwx report.txt</userinput>
	  </screen>

	  <para>
	    Jika Anda tidak ingin membersihkan hak akses pengguna, grup, dan lainnya, tetapi Anda 
	    hendak menghapus isi ACL lain, Anda bisa menggunakan opsi <parameter class="command">-b</parameter>. 
	    Contoh berikut menggunakanna dengan kombinasi dari opsi parameter class="command">-m</parameter> 
	    untuk menghapus semua isi ACL (kecuali untuk pengguna, grup, dan lainnya),
	    dan menambahkan sebuah isi baru untuk grup <emphasis>friends</emphasis>:
	  </para>

	  <screen>
$ <userinput>setfacl -b -m group:friends:rw- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-default">
	  <title>Mensetting ACL default</title>

	  <para>
	    Seperti yang kita lihat pada <xref
	    linkend="chap-filesystem-permissions-acl" />, direktori bisa memiliki isi ACL default yang 
	    menentukan hak akses apa yang harus digunakan untuk berkas dan direktori yang dibuat pada direktori tersebut.
	    Opsi <parameter class="command">-d</parameter> digunakan untuk beroperasi pada isi default:
	  </para>

	  <screen>
$ <userinput>setfacl -d -m group:friends:rwx reports</userinput>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:friends:rwx
default:mask::rwx
default:other::r-x
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-filesource">
	  <title>Menggunakan ACL dari berkas referensi</title>

	  <para>
	    Anda juga bisa menggunakan spesifikasi ACL dari berkas, dan bukan menentukannya dari perintah
	    baris. Sebuah berkas masukan mengikuti sintaks yang sama dengan parameter pada 
	    <command>setfacl</command>, tetapi dipisahkan dengan baris baru dan bukan dengan koma. Hal ini 
	    berguna karena Anda bisa menggunakan ACL untuk berkas yang ada sebagai referensi:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt > ref</userinput>
	  </screen>

	  <para>
	    Opsi <parameter class="command">-M</parameter> disediakan untuk memodifikasi ACL untuk sebuah berkas dengan 
	    membaca isi dari berkas lain. Jadi, jika kita memiliki berkas bernama <filename>report2.txt</filename>, kita 
	    bisa memodifikasi ACL untuk berkas ini dengan isi dari <filename>ref</filename> dengan:
	  </para>

	  <screen>
$ <userinput>setfacl -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Jika Anda hendak memulai dengan ACL yang bersih, dan menambahkan isi dari <filename>ref</filename>, Anda bisa menambahkan 
	    tanda <parameter class="command">-b</parameter> yang kita bahas sebelumnya:
	  </para>

	  <screen>
$ <userinput>setfacl -b -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Tentu saja, tidak diharuskan untuk menggunakan berkas ini. Kita bisa melakukan pipe dari 
	    <command>getfacl</command> ke <command>setfacl</command>, dengan menggunakan nama simbol dari masukan standar
	    (<emphasis>-</emphasis>), dan bukan menggunakan nama berkas:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt | setfacl -b -M - report2.txt</userinput>
	  </screen>

	  <para>
	    Opsi <parameter class="command">-X</parameter> menghapus isi ACL yang didefinisikan pada berkas. Hal ini menggunakan 
	    sintaks yang sama dengan <parameter class="command">-x</parameter>, dengan koma digantikan dengan baris baru.
	  </para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-finding">
    <title>Menemukan berkas</title>

    <sect2 xml:id="chap-filesystem-finding-find">
      <title>find</title>

      <para>
	Perintah <command>find</command> merupakan utilitas yang paling mudah untuk menemukan berkas pada sistem UNIX. Hal ini karena 
	ia bekerja pada cara yang sederhana dan mudah diprediksi: <command>find</command> akan menjelajahi pohon direktori yang ditentukan 
	sebagai parameter pada <command>find</command>. Selain itu, sebuah pengguna bisa menentukan ekspresi yang akan dievaluasi 
	untuk setiap berkas dan direktori. Nama dari berkas atau direktori akan dicetak jika ekspresi bernilai <emphasis>true</emphasis>. 
	Argumen pertama dimulai dengan tanda minus (<emphasis>-</emphasis>), tanda seru (<emphasis>!</emphasis>,atau kurung buka (<emphasis>(</emphasis>, 
	menandakan awal dari ekspresi. Ekspresi bisa berisi berbagai operan. Untuk jelasnya, sintaks dari <command>find</command> adalah: <emphasis>find paths
	expression</emphasis>.
      </para>

      <para>
	Penggunaan sederhana dari <command>find</command> adalah dengan tanpa ekspresi. Karena hal ini akan cocok dengan setiap direktori dan sub direktori, 
	semua berkas dan direktori akan dicetak. Sebagai contoh:
      </para>

      <screen>
$ <userinput>find .</userinput>
.
./economic
./economic/report.txt
./economic/report2.txt
./technical
./technical/report2.txt
./technical/report.txt
      </screen>

      <para>
	Anda juga bisa menentukan banyak direktori:
      </para>

      <screen>
$ <userinput>find economic technical</userinput>
economic
economic/report.txt
economic/report2.txt
technical
technical/report2.txt
technical/report.txt
      </screen>

      <sect3 xml:id="chap-filesystem-finding-find-nametype">
	<title>Operan yang membatasi berdasakan nama atau jenis obyek</title>

	<para>
	  Satu skenario umum untuk mencari berkas atau direktori adalah dengan mencari berdasarkan nama. 
	  Operan <emphasis>-name</emphasis> bisa digunakan untuk mencocokan obyek yang memiliki nama 
	  tertentu, atau cocok dengan wildcard tertentu. Sebagai contoh, dengan menggunakan operan 
	  <emphasis>-name 'report.txt'</emphasis> hanya akan bernilai benar untuk berkas atau direktori dengan 
	  nama <filename>report.txt</filename>. Sebagai contoh:
	</para>

	<screen>
$ <userinput>find economic technical -name 'report.txt'</userinput>
economic/report.txt
technical/report.txt
	</screen>

	<para>
	  Hal yang sama berlaku juga untuk wildcards:
	</para>

	<screen>
$ <userinput>find economic technical -name '*2.txt'</userinput>
economic/report2.txt
technical/report2.txt
	</screen>

	<note>
	  <para>
	    Ketika menggunakan <command>find</command> Anda sebaiknya mengirimkan wildcard ke[ada <command>find</command>, 
	    dan jangan mengharapkan shell untuk memperluasnya. Jadi, pastikan pola sudah diberi tanda kutip, atau wildcard 
	    sudah di-escape.
	  </para>
	</note>

	<para>
	  Juga dimungkinkan untuk mengevaluasi jenis obyek dengan operan <emphasis>-type c</emphasis>, dimana 
	  <emphasis>c</emphasis> menentukan jenis yang akan dicocokkan.
	  <xref
	  linkend="chap-filesystem-finding-find-nametype-type-params"
	  /> mendaftar berbagai jenis obyek yang bisa digunakan.
	</para>

	<table xml:id="chap-filesystem-finding-find-nametype-type-params">
	  <title>Parameter untuk operan '-type'</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Parameter</entry><entry>Arti</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>b</entry><entry>Berkas blok device</entry>
	      </row>
	      <row>
		<entry>c</entry><entry>Berkas karakter device</entry>
	      </row>
	      <row>
		<entry>d</entry><entry>Direktori</entry>
	      </row>
	      <row>
		<entry>f</entry><entry>Berkas biasa</entry>
	      </row>
	      <row>
		<entry>l</entry><entry>Symbolic link</entry>
	      </row>
	      <row>
		<entry>p</entry><entry>FIFO</entry>
	      </row>
	      <row>
		<entry>s</entry><entry>Socket</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Jadi, misalnya Anda hendak mencocokkan direktori, Anda bisa menggunakan parameter <emphasis>d</emphasis> 
	  pada operan <emphasis>-type</emphasis>:
	</para>

	<screen>
$ <userinput>find . -type d</userinput>
.
./economic
./technical
	</screen>

	<para>
	  Kita akan lihat ekspresi yang kompleks pada akhir bagian dari <command>find</command>, tetapi pada saat ini, 
	  cukup penting untuk diketahui bahwa Anda bisa membuat sebuah ekspresi boolean 'and' dengan menentukan berbagai operan. 
	  Sebagai contoh, <emphasis>operan1 operan2</emphasis> bernilai benar (true) jika kedua 
	  <emphasis>operan1</emphasis> dan
	  <emphasis>operan2</emphasis> bernilai benar untuk obyek yang sedang dievaluasi. Jadi, Anda bisa mengkombinasikan
	  operan <emphasis>-name</emphasis> dan <emphasis>-type</emphasis>
	  untuk menemukan semua direktori yang diawali dengan 
	  <emphasis>eco</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name 'eco*' -type d</userinput>
./economic
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-perms">
	<title>Operan yang membatasi berdasarkan kepemilikan atau hak akses obyek</title>

	<para>
	  Selain mencocokan obyek berdasarkan nama atau jenis, Anda juga bisa mencocokkan berdasarkan
	  hak akses aktif atau kepemilikan obyek. Hal ini berguna untuk mencari berkas yang memiliki hak akses atau 
	  kepemilikan yang tidak tepat.
	</para>

	<para>
	  Pemilik atau grup dari obyek dapat dicocokkan dengan <emphasis>-user username</emphasis> dan 
	  <emphasis>-group groupname</emphasis>. Nama dari pengguna atau grup akan diinterpretasikan sebagai ID 
	  pengguna atau ID grup jika nama adalah desimal dan tidak bisa ditemukan pada sistem dengan 
	  <citerefentry><refentrytitle>getpwnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>
	  atau
	  <citerefentry><refentrytitle>getgrnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>. Jadi,
	  jika Anda hendak mencocokkan semua obyek yang dimiliki 
	  <emphasis>joe</emphasis>, Anda bisa menggunakan 
	  <emphasis>-user joe</emphasis> sebagai operan:
	</para>

	<screen>
$ <userinput>find . -user joe</userinput>
./secret/report.txt
	</screen>

	<para>
	  Atau untuk menemukan semua obyek dengan grup 
	  <emphasis>friend</emphasis> sebagai grup berkas:
	</para>

	<screen>
$ <userinput>find . -group friends</userinput>
./secret/report.txt
	</screen>

	<para>
	  Operan untuk menguji hak akses berkas
	  <emphasis>-perm</emphasis> lebih bersifat trivial. Seperti perintah 
	  <command>chmod</command> operator ini bisa bekerja dengan notasi oktal maupun simbol. 
	  Kita akan mulai dengan melihat notasi oktal. Jika sebuah nomor oktal ditentukan sebagai 
	  parameter pada operan <emphasis>-perm</emphasis>, maka akan cocok dengan semua obyek 
	  yang memiliki hak akses yang sama persis. Sebagai contoh, <emphasis>-perm 0600</emphasis>
	  akan cocok dengan semua obyek yang hanya dapat dibaca dan ditulis oleh pengguna, dan tidak 
	  memiliki tambahan lain-lain:
	</para>

	<screen>
$ <userinput>find . -perm 0600</userinput>
./secret/report.txt
	</screen>

	<para>
	  Jika sebuah tanda minus ditambahkan sebagai awalan dari sebuah angka, maka akan cocok dengan 
	  semua obyek yang minimal memiliki bit yang ditentukan sebagai nomor oktal. Sebuah contoh yang 
	  berguna adalah mencari semua berkas yang paling tidak memiliki bit penulisan aktif untuk pengguna 
	  <emphasis>other</emphasis> dengan <emphasis>-perm
	  -0002</emphasis>. Hal ini bisa membantu Anda node device atau obyek lain dengan hak akses yang tidak aman.
	</para>

	<screen>
$ <userinput>find /dev -perm -0002</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>

	<note>
	  <para>
	    Beberapa node device harus bersifat dapat ditulis oleh semua pada beberapa 
	    sistem UNIX agar dapat berfungsi dengan benar. Sebagai contoh, device 
	    <filename>/dev/null</filename> selalu bersifat dapat ditulis.
	  </para>
	</note>

	<para>
	  Notasi simbol dari parameter <emphasis>-perm</emphasis>
	  menggunakan notasi yang sama dengan perintah 
	  <command>chmod</command>.  Hak akses simbolis dibangun dengan mode berkas dimana semua 
	  bit akan dihapus, sehingga tidak diperlukan untuk menggunakan tanda minus untuk menghapusnya.
	  Hal ini juga mencegah ambiguitas yang dapat muncul dengan awalan tanda minus. Seperti sintaks 
	  oktal, mengawali hak akses dengan tanda minus akan mencocokkan obyek yang paling tidak memiliki 
	  hak akses yang ditentukan. Penggunaan nama simbol cukup mudah ditebak - dua perintah berikut 
	  mengulang contoh sebelumnya dengan hak akses simbolis:
	</para>

	<screen>
$ <userinput>find . -perm u+rw</userinput>
./secret/report.txt
	</screen>

	<screen>
$ <userinput>find /dev -perm -o+w</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-time">
	<title>Operands that limit by object creation time</title>

	<para>
	  There are three operands that operate on time intervals.
	  The syntax of the operand is <emphasis>operand n</emphasis>,
	  where <emphasis>n</emphasis> is the time in days. All three
	  operators calculate a time delta in seconds that is divided
	  by the the number of seconds in a day (86400), discarding
	  the remainder. So, if the delta is one day,
	  <emphasis>operand 1</emphasis> will match for the
	  object. The three operands are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>-atime n</emphasis> - this operand evaluates
	      to true if the initialization time of <command>find</command>
	      minus the last access time of the object equals
	      to <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-ctime n</emphasis> - this operand evaluates
	      to true if the initialization time of
	      <command>find</command> minus the time of the latest
	      change in the file status information equals to
	      <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-mtime n</emphasis> - this operand evaluates
	      to true if the initialization time of
	      <command>find</command> minus the latest file change
	      time equals to <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  So, these operands match if the latest access, change,
	  modification respectively was <emphasis>n</emphasis> days
	  ago. To give an example, the following command shows all
	  objects in <filename>/etc</filename> that have been modified
	  one day ago:
	</para>

	<screen>
$ <userinput>find /etc -mtime 1</userinput>
/etc
/etc/group
/etc/master.passwd
/etc/spwd.db
/etc/passwd
/etc/pwd.db
	</screen>

	<para>
	  The plus or minus sign can be used as modifiers for the meaning
	  of <emphasis>n</emphasis>. <emphasis>+n</emphasis> means more
	  than <emphasis>n</emphasis> days, <emphasis>-n</emphasis>
	  means less than <emphasis>n</emphasis> days. So, to find all
	  files in <filename>/etc</filename> that were modified less
	  than two days ago, you could execute:
	</para>

	<screen>
$ <userinput>find /etc -mtime -2</userinput>
/etc
/etc/network/run
/etc/network/run/ifstate
/etc/resolv.conf
/etc/default
/etc/default/locale
[...]
	</screen>

	<para>
	  Another useful time-based operand is the <emphasis>-newer
	  reffile</emphasis> operand. This matches all files that were
	  modified later that the file with filename
	  <filename>reffile</filename>. The followin example shows how
	  you could use this to list all files that have later modification
	  times than <filename>economic/report2.txt</filename>:
	</para>

	<screen>
$ <userinput>find . -newer economic/report2.txt</userinput>
.
./technical
./technical/report2.txt
./technical/report.txt
./secret
./secret/report.txt
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-depth">
	<title>Operands that affect tree traversal</title>

	<para>
	  Some operands affect the manner in which the
	  <command>find</command> command traverses the tree. The
	  first of these operands is the <emphasis>-xdev</emphasis>
	  operand. <emphasis>-xdev</emphasis> prevents that
	  <command>find</command> decends into directories that have a
	  different device ID, effectively avoiding traversal of other
	  filesystems. The directory to which the filesystem is
	  mounted, is printed, because this operand always returns
	  <emphasis>true</emphasis>. A nice example is a system where
	  <filename>/usr</filename> is mounted on a different filesystem
	  than <filename>/</filename>. For instance, if we search for
	  directories with the name <emphasis>bin</emphasis>, this may
	  yield the following result:
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d</userinput>
/usr/bin
/bin
	</screen>

	<para>
	  But if we add <emphasis>-xdev</emphasis>
	  <filename>/usr/bin</filename> is not found, because it is on
	  a different filesystem (and device):
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d -xdev</userinput>
/bin
	</screen>

	<para>
	  The <emphasis>-depth</emphasis> operand modifies the order
	  in which directories are evaluated. With
	  <emphasis>-depth</emphasis> the contents of a directory are
	  evaluated first, and then the directory itself. This can be
	  witnessed in the following example:
	</para>

	<screen>
$ <userinput>find . -depth</userinput>
./economic/report.txt
./economic/report2.txt
./economic
./technical/report2.txt
./technical/report.txt
./technical
.
	</screen>

	<para>
	  As you can see in the output, files in the
	  <emphasis>./economic</emphasis> directory is evaluated
	  before <filename>.</filename>, and
	  <filename>./economic/report.txt</filename> before
	  <filename>./economic</filename>. <emphasis>-depth</emphasis>
	  always evaluates to <emphasis>true</emphasis>.
	</para>

	<para>
	  Finally, the <emphasis>-prune</emphasis> operand causes find
	  not to decend into a directory that is being evaluated.
	  <emphasis>-prune</emphasis> is discarded if the
	  <emphasis>-depth</emphasis> operand is also
	  used. <emphasis>-depth</emphasis> always evaluates to
	  <emphasis>true</emphasis>.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-exec">
	<title>Operands that execute external utilities</title>

	<para>
	  <command>find</command> becomes a very powerful tool when it
	  is combined with external utilities. This can be done with
	  the <emphasis>-exec</emphasis> operand. There are two
	  syntaxes for the <emphasis>-exec</emphasis> operand. The
	  first syntax is <emphasis>-exec utility arguments
	  ;</emphasis>. The command <emphasis>utility</emphasis> will
	  be executed with the arguments that were specified for each
	  object that is being evaluated. If any of the arguments is
	  <emphasis>{}</emphasis>, these braces will be replaced by
	  the file being evaluated. This is very handy, especially when
	  we consider that, if we use no additional expression syntax,
	  operands will be evaluated from left to right. Let's look at
	  an example:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} \;</userinput>
	</screen>

	<para>
	 The first operand returns true for files that have their
	 permissions set to <emphasis>0666</emphasis>. The second
	 operand executes <emphasis>chmod 0644 filename</emphasis> for
	 each file that is being evaluated. If you were wondering why
	 this command is not executed for every file, that is a good
	 question. Like many other interpreters of expressions,
	 <command>find</command> uses <quote>short-circuiting</quote>.
	 Because no other operator was specified, the logical
	 <emphasis>and</emphasis> operator is automatically is assumed
	 between both operands. If the first operand evaluates to
	 <emphasis>false</emphasis>, it makes no sense to evaluate any
	 further operands, because the complete expression will always
	 evaluate to false. So, the <emphasis>-exec</emphasis> operand
	 will only be evaluated if the first operand is true. Another
	 particularity is that the semi-colon that closes the
	 <emphasis>-exec</emphasis> is escaped, to prevent that the
	 shell parses it.
	</para>

	<para>
	  A nice thing about the <emphasis>-exec</emphasis> operator
	  is that it evaluates to <emphasis>true</emphasis> if the
	  command terminated sucessfully. So, you could also use
	  the <emphasis>-exec</emphasis> command to add additional
	  conditions that are not represented by <command>find</command>
	  operands. For instance, the following command prints
	  all objects ending with <emphasis>.txt</emphasis> that contain
	  the string <emphasis>gross income</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name '*.txt' -exec grep -q 'gross income' {} \; -print</userinput>
./economic/report2.txt
	</screen>

	<para>
	  The <command>grep</command> command will be covered lateron.
	  <!-- XXX - xref --> But for the moment, it is enough to know
	  that it can be used to match text patterns. The
	  <emphasis>-print</emphasis> operand prints the current
	  object path. It is always used implicitly, except when the
	  <emphasis>-exec</emphasis> or <emphasis>-ok</emphasis>
	  operands are used. <!-- XXX - move to introduction? -->
	</para>

	<para>
	  The second syntax of the <emphasis>-exec</emphasis> operand
	  is <emphasis>-exec utility arguments {} +</emphasis>. This
	  gathers a set of all matched object for which the expression
	  is true, and provides this set of files as an argument to
	  the utility that was specified. The first example of the
	  <emphasis>-exec</emphasis> operand can also be written as:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} +</userinput>
	</screen>

	<para>
	  This will execute the <command>chmod</command> command only
	  once, with all files for which the expression is true as its
	  arguments. This operand always returns <emphasis>true</emphasis>.
	</para>

	<para>
	  If a command executed by find returns a non-zero value
	  (meaning that the execution of the command was not
	  succesful), <command>find</command> should also return a
	  non-zero value.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-operators">
	<title>Operators for building complex expressions</title>

	<para>
	  <command>find</command> provides some operators that can be
	  combined to make more complex expressions:
	</para>

	<variablelist>
	  <title>Operators</title>

	  <varlistentry>
	    <term>( expr )</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if
		<emphasis>expr</emphasis> evaluates to
		<emphasis>true</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 [-a] expr2</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if both
		<emphasis>expr1</emphasis> and <emphasis>expr2</emphasis>
		are true. If <emphasis>-a</emphasis> is omitted,
		this operator is implicitly assumed.
	      </para>

	      <para>
		<command>find</command> will use short-circuiting when
		this operator is evaluated: <emphasis>expr2</emphasis>
		will not be evaluated when <emphasis>expr1</emphasis>
		evaluates to <emphasis>false</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 -o expr2</term>
	    <listitem>
	      <para>
		Evaluates to <emphasis>true</emphasis> if either or
		both <emphasis>expr1</emphasis> and
		<emphasis>expr2</emphasis> are true.
	      </para>

	      <para>
		<command>find</command> will use short-circuiting when
		this operator is evaluated: <emphasis>expr2</emphasis>
		will not be evaluated when <emphasis>expr1</emphasis>
		evaluates to <emphasis>true</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>! expr</term>
	    <listitem>
	      <para>
		Negates <emphasis>expr</emphasis>. So, if
		<emphasis>expr</emphasis> evaluates to true, this
		expression will evaluate to <emphasis>false</emphasis>
		and vise versa.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>
	  Since both the parentheses and exclamation mark characters
	  are interpreted by most shells, they should usually be
	  escaped.
	</para>

	<para>
	  The following example shows some operators in action. This
	  command executes <command>chmod</command> for all files that
	  either have their permissions set to
	  <emphasis>0666</emphasis> or <emphasis>0664</emphasis>.
	</para>

	<screen>
$ <userinput>find . \( -perm 0666 -o -perm 0664 \) -exec chmod 0644 {} \;</userinput>
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-which">
      <title>which</title>

      <para>
	The <command>which</command> command is not part of the Single
	UNIX Specification version 3, but it is provided by most
	sysmtems. <command>which</command> locates a command that is
	in the user's path (as set by the PATH environment variable),
	printing its full path. Providing the name of a command as its
	parameter will show the full path:
      </para>

      <screen>
$ <userinput>which ls</userinput>
/bin/ls
      </screen>

      <para>
	You can also query the paths of multiple commands:
      </para>

      <screen>
$ <userinput>which ls cat</userinput>
/bin/ls
/bin/cat
      </screen>

      <para>
        <command>which</command> returns a non-zero return value
	if the command could not be found.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-whereis">
      <title>whereis</title>

      <para>
	This <command>whereis</command> command searches binaries, manual pages and sources of a
	command in some predefined places. For instance, the following
	command shows the path of the <command>ls</command> and the
	<citerefentry><refentrytitle>ls</refentrytitle><manvolnum>1</manvolnum></citerefentry>
	manual page:
      </para>

      <screen>
$ <userinput>whereis ls</userinput>
ls: /bin/ls /usr/share/man/man1/ls.1.gz
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-locate">
      <title>locate</title>

      <para>
        Slackware Linux also provides the
	<command>locate</command> command that searches through a file
	database that can be generated periodically with the
	<command>updatedb</command> command. Since it uses a prebuilt
	database of the filesystem, it is a lot faster than
	<command>command</command>, especially when directory entry
	information has not been cached yet. Though, the
	<command>locate</command>/<command>updatedb</command> combo
	has some downsides:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    New files are not part of the database until the next
	    <command>updatedb</command> invocation.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <command>locate</command> has no conception of
	    permissions, so users may locate files that are normally
	    hidden to them.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    A newer implementation, named <emphasis>slocate</emphasis>
	    deals with permissions, but requires elevated privileges.
	    This is the <command>locate</command> variation that is
	    included with Slackware Linux.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	With filesystems becoming faster, and by applying common sense
	when formulating <command>find</command> queries,
	<command>locate</command> does not really seem worth the
	hassle. Of course, your mileage may vary. That said, the basic
	usage of <command>locate</command> is <emphasis>locate
	filename</emphasis>. For example:
      </para>

      <screen>
$ <userinput>locate locate</userinput>
/usr/bin/locate
/usr/lib/locate
/usr/lib/locate/bigram
/usr/lib/locate/code
/usr/lib/locate/frcode
[...]
      </screen>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-archives">
    <title>Arsip</title>

    <sect2 xml:id="basics-filesystem-archives-introduction">
      <title>Perkenalan</title>

      <para>
	Cepat atau lambat, pengguna GNU/Linux akan menjumpai arsip <acronym>tar</acronym>, tar adalah format 
	standar untuk membuat arsip berkas pada GNU/Linux.  Tar sering digunakan bersamaan dengan 
	<command>gzip</command> atau 
	<command>bzip2</command>. Kedua perintah tersebut mampu mengkompresi berkas dan arsip. 
	<xref linkend="archive-extentions" /> menampilkan ekstensi arsip yang paling sering digunakan, dan artinya.
      </para>

      <table xml:id="archive-extentions">
	<title>Ekstensi berkas arsip</title>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Ekstensi</entry>
	      <entry>Arti</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>.tar</entry>
	      <entry>Arsip tar tidak terkompresi</entry>
	    </row>
	    <row>
	      <entry>.tar.gz</entry>
	      <entry>Arsip tar dikompresi dengan gzip</entry>
	    </row>
	    <row>
	      <entry>.tgz</entry>
	      <entry>Arsip tar dikompresi dengan gzip</entry>
	    </row>
	    <row>
	      <entry>.tar.bz2</entry>
	      <entry>Arsip tar dikompresi dengan bzip2</entry>
	    </row>
	    <row>
	      <entry>.tbz</entry>
	      <entry>Arsip tar dikompresi dengan bzip2</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	Perbedaan antara <command>bzip2</command> dan 
	<command>gzip</command> adalah <command>bzip2</command> bisa mencari informasi yang diulang-ulang pada
	blok yang lebih besar, sehingga menghasilkan kompresi yang lebih baik. Tetapi <command>bzip2</command> juga lebih 
	lambat, karena melakukan lebih banyak analisa data.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-extracting">
      <title>Mengurai arsip</title>

      <para>
	Karena beberapa perangkat lunak dan data pada dunia GNU/Linux diarsip dengan <command>tar</command>, menjadi 
	sangat penting untuk membiasakan diri dengan menguraikan arsip tar. Langkah pertama yang harus Anda lakukan ketika 
	menerima arsip tar adalah menampilkan isinya. Hal ini bisa dilakukan dengan parameter <parameter
	class="command">t</parameter>. Namun, jika kita hanya menjalankan <command>tar</command> dengan parameter ini, 
	dan nama arsip, maka tar hanya akan menunggu sampai Anda memasukkan sesuatu ke standard input:
      </para>

      <screen>
$ <userinput>tar t test.tar</userinput>
      </screen>

      <para>
	Hal ini terjadi karena <command>tar</command> membaca data dari standar input. Jika Anda lupa bagaimana pengalihan 
	bekerja, merupakan ide bagus untuk membaca ulang <xref linkend="chap-shell-inout" />. Mari kita lihat apa yang 
	terjadi jika kita mengalihkan arsip tar kita ke tar:
      </para>

      <screen>
$ <userinput>tar t &lt; test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Ini lebih sesuai dengan apa yang Anda harapkan. Arsip ini berisi sebuah direktori <filename>test</filename>, yang 
	berisi berkas <filename>test2</filename> dan <filename>test2</filename>.  Juga dimungkinkan untuk menentukan nama 
	arsip sebagai parameter pada <command>tar</command>, dengan menggunakan parameter <parameter
	class="command">f</parameter>:
      </para>

      <screen>
$ <userinput>tar tf test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Ini merupakan arsip yang berisi berkas yang berguna ;). Kita bisa melanjutkan dan menguraikan arsip dengan menggunakan 
	parameter <parameter class="command">x</parameter>:
      </para>

      <screen>
$ <userinput>tar xf test.tar</userinput>
      </screen>

      <para>
	Sekarang kita bisa melakukan verifikasi bahwa tar menguraikan arsip dengan melihat isi direktori dengan 
	<command>ls</command>:
      </para>

      <screen>
$ <userinput>ls test/</userinput>
test1  test2
      </screen>

      <para>
	Menguraikan atau menampilkan berkas dari arsip yang digabung dengan gzip atau bzip 
	tidaklah lebih susah. Hal ini bisa dilakukan dengan menambahkan parameter 
	<parameter class="command">z</parameter> atau <parameter
	class="command">b</parameter> untuk arsip yang dikompresi dengan <command>gzip</command> atau
	<command>bzip2</command>.  Sebagai contoh, kita bisa menampilkan isi dari arsip yang dikompresi dengan 
	gzip dengan :
      </para>

      <screen>
$ <userinput>tar ztf archive2.tar.gz</userinput>
      </screen>

      <para>
	Dan arsip dengan kompresi bzip bisa diuraikan dengan :
      </para>

      <screen>
$ <userinput>tar bxf archive3.tar.bz2</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-creating">
      <title>Membuat arsip</title>

      <para>
	Anda bisa membuat arsip dengan parameter <parameter
	class="command">c</parameter>. Misalkan kita memiliki direktori <filename>test</filename> yang ditampilkan 
	pada contoh sebelumnya. Kita bisa membuat arsip dengan direktori <filename>test</filename> dan berkas pada direktori 
	ini dengan:
      </para>

      <screen>
$ <userinput>tar cf important-files.tar test</userinput>
      </screen>

      <para>
	Perintah ini akan membuat arsip <filename>important-files.tar</filename>
	(yang ditentukan dengan parameter <parameter class="command">f</parameter>). Sekarang kita bisa memverifikasi arsip:
      </para>

      <screen>
$ <userinput>tar tf important-files.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Membuat arsip dengan kompresi gzip atau bzip bisa dilakukan pada baris yang sama dengan penguraian arsip terkompresi:
	tambahkan parameter <parameter class="command">z</parameter> untuk mengkompresi arsip dengan gzip, atau 
	<parameter class="command">b</parameter> untuk mengkompresi arsip dengan bzip. Misalkan kita hendak membuat 
	arsip terkompresi versi <command>gzip</command> dari contoh diatas. Kita melakukannya dengan:
      </para>

      <screen>
<userinput>tar zcf important-files.tar.gz test</userinput>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-mounting">
    <title>Melakukan mount sistem berkas</title>

    <sect2 xml:id="basics-filesystem-mounting-introduction">
      <title>Perkenalan</title>

      <para>
	Seperti yang lain, Linux menggunakan satu teknik yang disebut <quote>mounting</quote> untuk mengakses sistem 
	berkas. Mounting berarti sebuah sistem berkas dihubungkan pada sebuah direktori pada sistem berkas root. Seseorang 
	bisa melakukan mount sebuah drive CD-ROM pada direktori <filename>/mnt/cdrom</filename>. Linux mendukung 
	banyak jenis sistem berkas, seperti Ext2, Ext3, ReiserFS, JFS, XFS,
	ISO9660 (digunakan untuk CD-ROM), UDF (digunakan pada beberapa DVD) dan sistem berkas DOS/Windows, seperti 
	FAT, FAT32 dan NTFS. Sistem berkas ini bisa berada pada banyak media, misalnya hard disk, CD-RM, dan disk Flash. 
	Bagian ini menjelaskan bagaimana sistem berkas bisa di-mount dan di-unmount.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-mount">
      <title>mount</title>

      <para>
	Perintah <command>mount</command> digunakan untuk melakukan mount terhadap sistem berkas. Sintaks dasarnya adalah :
	<quote>mount /dev/devname /mountpoint</quote>. Nama device bisa berupa blok device, seperti hard disk atau drive 
	CD-ROM. Mount point bisa berupa titik pada sistem berkas root. Mari kita lihat contoh:
      </para>

      <screen>
# <userinput>mount /dev/cdrom /mnt/cdrom</userinput>
      </screen>

      <para>
	Hal ini akan me-mount <filename>/dev/cdrom</filename> pada mount point <filename>/mnt/cdrom</filename>. Nama device
	<filename>/dev/cdrom</filename> biasanya merupakan link ke nama device CD-ROM yang sebenarnya 
	(misalnya <filename>/dev/hdc</filename>). Seperti yang Anda lihat, konsepnya sangat sederhana, hanya membutuhkan 
	sedikit waktu untuk mempelajari nama device ;). Seringkali Anda juga perlu menentukan jenis sistem berkas yang 
	akan di-mount. Jenis sistem berkas bisa ditentukan dengan menambahkan parameter <parameter
	class="command">-t</parameter>:
      </para>

      <screen>
# <userinput>mount -t vfat /dev/sda1 /mnt/flash</userinput>
      </screen>

      <para>
	Hal ini akan me-mount sistem berkas vfat pada 
	<filename>/dev/sda1</filename> ke
	<filename>/mnt/flash</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-umount">
      <title>umount</title>

      <para>
	Perintah <command>umount</command> digunakan untuk melepas mount terhadap sistem berkas. 
	<command>umount</command> menerima dua jenis parameter, mount point atau device. Sebagai contoh:
      </para>

      <screen>
# <userinput>umount /mnt/cdrom</userinput>
# <userinput>umount /dev/sda1</userinput>
      </screen>

      <para>
	Perintah pertama akan melepas mount sistem berkas yang di-mount pada 
	<filename>/mnt/cdrom</filename>, perintah kedua melepas mount sistem berkas pada <filename>/dev/sda1</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-fstab">
      <title>Berkas fstab</title>

      <para>
	Sistem GNU/Linux memiliki berkas khusus, <filename>/etc/fstab</filename>, 
	yang menentukan sistem berkas apa yang harus di-mount selama sistem boot. Mari 
	kita lihat contoh:
      </para>

      <screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
      </screen>

      <para>
	Seperti yang Anda lihat, setiap catatan pada berkas <filename>fstab</filename>
	memiliki lima bagian: fs_spec, fs_file, fs_vfstype,
	fs_mntops, fs_freq, dan fs_passno.  Kita akan melihat pad setiap bagian.
      </para>

      <sect3>
	<title>fs_spec</title>

	<para>
	  Opsi fs_spec menentukan blok device, atau sistem berkas remote yang harus di-mount. 
	  Seperti yang Anda lihat pada contoh, beberapa partisi /dev/hda ditentukan, begitu juga 
	  dengan drive CD-ROM dan disket. Ketika volume NFS di-mount, alamat IP dan direktori 
	  bisa ditentukan, seperti contoh: <filename>192.168.1.10:/exports/data</filename>.
	</para>
      </sect3>

      <sect3>
	<title>fs_file</title>

	<para>
	  fs_file menentukan titik mount (mount point). Ini bisa berupa direktori pada sistem berkas.
	</para>
      </sect3>

      <sect3>
	<title>fs_vfstype</title>

	<para>
	  Opsi ini menentukan sistem berkas apa yang digunakan. Sebagai contoh, hal ini bisa berupa : ext2, ext3, reiserfs,
	  xfs, nfs, vfat, or ntfs.
	</para>
      </sect3>

      <sect3>
	<title>fs_mntops</title>

	<para>
	  Opsi fs_mntops menentukan parameter yang harus digunakan untuk melakukan mount terhadap sistem berkas. Halaman 
	  manual <command>mount</command> memiliki deskripsi yang lengkap tentang opsi yang tersedia. Ini merupakan opsi 
	  yang paling menarik:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>noauto</emphasis>: sistem berkas yang ditampilkan pada <filename>/etc/fstab</filename> 
	      pada umumnya akan di-mount secara otomatis. Ketika <quote>noauto</quote> digunakan, sistem berkas tidak 
	      akan di-mount selama sistem boot, tetapi hanya jika diberikan perintah <command>mount</command>. 
	      Ketika melakukan mount terhadap sistem berkas tersebut, hanya mount point atau nama device yang harus 
	      ditentukan, misalnya: <command>mount
	      /mnt/cdrom</command>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>user</emphasis>: menambahkan opsi 
	      <quote>user</quote> akan mengijinkan pengguna biasa untuk melakukan mount terhadap sistem berkas (biasanya 
	      hanya pengguna root yang diijinkan untuk melakukan mount terhadap sistem berkas).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>owner</emphasis>: Opsi <quote>owner</quote>
	      mengijinkan pemilik dari device yang ditentukan untuk melakukan mount terhadap device yang ditentukan. 
	      Anda bisa melihat pemilik dari device menggunakan <command>ls</command>, Cth.  <command>ls -l
	      /dev/cdrom</command>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>noexec</emphasis>: dengan opsi ini aktif, pengguna tidak bisa menjalankan berkas dari sistem berkas 
	      yang di-mount. Hal ini bisa digunakan untuk menyediakan keamanan yang lebih baik.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>nosuid</emphasis>: opsi ini hampir serupa dengan opsi <quote>noexec</quote>. Dengan 
	      <quote>nosuid</quote> aktif, bit SUID pada berkas pada sistem berkas tidak akan diijinkan. SUID
	      digunakan untuk beberapa biner untuk mengijinkan pengguna melakukan sesuatu yang hanya bisa dilakukan oleh 
	      pengguna khuusus (root). Hal ini jelas merupakan ancaman keamanan, sehingga opsi ini hanya seharusnya 
	      digunakan pada media removable. Pengguna biasa akan memaksa opsi nosuid, tetapi tidak bagi pengguna root!
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>unhide</emphasis>: opsi ini hanya relevan untuk CD-ROM dengan sistem berkas ISO9660. Jika 
	      <quote>unhide</quote> ditentukan, maka berkas tersembunyi akan ditampilkan.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>fs_freq</title>

	<para>
	  Jika <quote>fs_freq</quote> ditentukan menjadi 1 atau lebih tinggi, ia menentukan berapa haris sebuah sistem 
	  berkas akan dibuat cadangannya (backup). Opsi ini hanya digunakan ketika <ulink
	  url="http://dump.sourceforge.net/">dump</ulink> terinstall, dan ditentukan untuk menangani hal ini.
	</para>
      </sect3>

      <sect3>
	<title>fs_passno</title>

	<para>
	  Kolom ini digunakan oleh <command>fsck</command> untuk menentukan urutan pengujian sistem berkas selama sistem boot.
	</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="basics-filesystem-gnupg">
    <title>Mengenkripsi dan menandatangani berkas</title>

    <sect2>
      <title>Perkenalan</title>

      <para>
	Terdapat dua mekanisme keamanan untuk mengamankan berkas: menandatangani berkas dan mengenkripsi berkas. 
	Menandatangani berkas berarti sebuah tanda tangan digital khusus dibuat untuk sebuah berkas. Anda, atau 
	orang lain bisa menggunakan tanda tangan (signature) untuk memastikan integritas dari sebuah berkas. 
	Enkripsi berkas mengubah sebuah berkas sehingga hanya hanya orang yang berhak untuk membaca mampu melihat 
	isi dari berkas tersebut.
      </para>

      <para>
	Sistem ini bergantung dari dua kunci: kunci pribadi (private) dan kunci publik. Kunci publik digunakan untuk 
	mengenkripsi berkas, dan berkas hanya bisa didekripsi dengan kunci private. Hal ini berarti bahwa orang bisa 
	mengirimkan kunci publiknya ke orang lain. Orang lain bisa menggunakan kunci ini untuk mengirimkan berkas 
	terenkripsi, bahwa hanya orang dengan kunci private yang bisa mendekripsinya. Tentu saja, hal ini berarti keamanan 
	dari sistem ini tergantung dari seberapa bagus kunci private dijaga.
      </para>

      <para>
	Slackware Linux menyediakan aplikasi untuk menandatangani dan mengenkripsi berkas, bernama GnuPG. GnuPG bisa diinstall 
	dari set disk <quote>n</quote>.
      </para>
    </sect2>

    <sect2>
      <title>Menghasilkan kunci private dan publik Anda</title>

      <para>
	Menghasilkan kunci publik dan private cukup rumit, karena GnuPG menggunakan kunci DSA sebagai default. DSA adalah 
	algoritma enkripsi, masalahnya adalah pada panjang kunci maksimal dari DSA yaitu 1024 bit, yang dianggap terlalu 
	pendek untuk jangka panjang. Hal ini mengapa ide bagus untuk menggunakan kunci RSA 2048 bit. Bagian ini menjelaskan 
	bagaimana hal ini bisa dilakukan.
      </para>

      <note>
	<para>
	  Kunci 1024-bit diyakini aman untuk waktu yang lama. Tetapi paper dari Bernstein <emphasis>Circuits for Integer
	  Factorization: a Proposal</emphasis> berkata lain, intinya adalah cukup mungkin untuk national
	  security agency untuk menghasilkan perangkat keras yang mampu membobol kunci dalam waktu yang relatif singkat.
	  Selain itu, juga dibuktikan bahwa kunci RSA 512-bit bisa dipecahkan dalam waktu yang relatif singkat dengan 
	  perangkat keras yang umum. Informasi tentang masalah ini bisa ditemukan pada email berikut:
	<ulink url="http://lists.saigon.com/vault/security/encryption/rsa1024.html" />
	</para>
      </note>

      <para>
	Kita bisa menghasilkan kunci dengan menjalankan :
      </para>

      <screen>
$ <userinput>gpg --gen-key</userinput>
      </screen>

      <para>
	Pertanyaan pertama adalah jenis kunci yang akan dibuat. Kita akan memilih <emphasis>(4) RSA (sign only)</emphasis>:
      </para>

      <screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <userinput>4</userinput>
      </screen>

      <para>
	Anda akan ditanyakan ukuran kunci yang ingin Anda buat. Ketikkan <emphasis>2048</emphasis> untuk menghasilkan kunci 
	2048 bit, dan tekan enter untuk melanjutkan.
      </para>

      <screen>
What keysize do you want? (1024) <userinput>2048</userinput>
      </screen>

      <para>
	Pertanyaan berikutnya mudah untuk dijawab, cukup pilih sesuai keinginan Anda. Pada umumnya, bukanlah ide yang jelek 
	untuk memilih kunci yang valid selamanya. Anda bisa menonaktifkan kunci dengan sertifikat pembatalan khusus.
      </para>

      <screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	GnuPG akan mencoba mengkonfirmasi. Setelah mengkonfirmasi, GnuPG akan menanyakan nama dan alamat email Anda. GnuPG
	juga akan menanyakan tentang komentar, Anda bisa membiarkannya kosong, atau Anda bisa mengisi seperti <quote>Work</quote> 
	atau <quote>Private</quote>, untuk mengindikasikan fungsi dari kunci ini. Sebagai contoh:
      </para>

      <screen>
Real name: <userinput>John Doe</userinput>
Email address: <userinput>john@doe.com</userinput>
Comment: <userinput>Work</userinput>              
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	GnuPG akan meminta Anda untuk mengkonfirmasi ID pengguna Anda. Setelah itu, GnuPG akan meminta Anda untuk mengisi kata sandi. 
	Pastikan Anda menggunakan kata sandi yang bagus:
      </para>

      <screen>
You need a Passphrase to protect your secret key.    

Enter passphrase:
      </screen>

      <para>
	Setelah memasukkan kata sandi sebanyak dua kali, GnuPG akan menghasilkan kunci. Tetapi kita belum selesai. GnuPG hanya 
	menghasilkan kunci untuk menandatangani informasi, bukan untuk mengenkripsi informasi. Untuk melanjutkan, lihat hasil 
	keluaran dan cari ID kunci. Pada informasi kunci, Anda bisa melihat 
	<emphasis>pub 2048R/</emphasis>. ID kunci dicetak setelah bagian ini. Pada contoh ini:
      </para>

      <screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
      </screen>

      <para>
	ID kunci adalah <emphasis>8D080768</emphasis>. Jika Anda kehilangan hasil keluaran, Anda bisa menemukan ID kunci 
	dari hasil perintah <command>gpg --list-keys</command>. Gunakan ID kunci ini untuk memberitahukan GnuPG bahwa 
	Anda hendak mengedit kunci Anda:
      </para>

      <screen>
$ <userinput>gpg --edit-key &lt;Key ID&gt;</userinput>
      </screen>

      <para>
	Dengan kunci diatas, perintah diatas menjadi:
      </para>

      <screen>
$ <userinput>gpg --edit-key 8D080768</userinput>
      </screen>

      <para>
	GnuPG akan menampilkan prompt perintah. Jalankan perintah <command>addkey</command> pada prompt ini:
      </para>

      <screen>
Command&gt; <userinput>addkey</userinput>
      </screen>

      <para>
	GnuPG akan menanyakan kata sandi yang Anda gunakan untuk kunci Anda:
      </para>

      <screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	Setelah memasukkan kata sandi, GnuPG akan menanyakan jenis kunci yang hendak Anda buat. Pilih 
	<emphasis>RSA (encrypt only)</emphasis>, dan isi informasi seperti sebelumnya (pastikan Anda menggunakan 
	kunci 2048 bit).  Sebagai contoh:
      </para>

      <screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <userinput>5</userinput>
What keysize do you want? (1024) <userinput>2048</userinput>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	Dan konfirmasikan bahwa informasi itu benar. Setelah kunci dibuat, Anda bisa meninggalkan prompt GnuPG, dan simpan 
	kunci baru dengan perintah <command>save</command>:
      </para>

      <screen>
Command&gt; <userinput>save</userinput>
      </screen>

      <para>
	Selamat!, Anda sudah menghasilkan kunci yang diperlukan untuk mengenkripsi dan mendekripsi email dan berkas. 
	Anda sekarang bisa mengkonfigurasikan klien email Anda untuk menggunakan GnuPG. Merupakan ide bagus untuk menyimpan 
	isi dari direktori <filename>.gnupg</filename> pada media yang dapat dipercaya, dan simpan dalam tempat yang amann! Jika 
	kunci private Anda hilang, Anda tidak bisa mendekripsi berkas dan pesan yang dienkripsi dengan kunci publik Anda. Jika 
	kunci private, dan kata sandi Anda dicuri, keamanan dari sistem ini jelas-jelas hilang.
      </para>
    </sect2>

    <sect2>
      <title>Mengekspor kunci publik Anda</title>

      <para>
	Untuk membuat GnuPG berguna, Anda harus memberikan kunci publik Anda kepada orang-orang yang 
	mengirimkan berkas atau email kepada Anda. Mereka bisa menggunakan kunci publik Anda untuk 
	mengenkripsi berkas, atau menggunakannya untuk memastikan apakah berkas memiliki signature 
	yang benar atau tidak. Kunci bisa diekspor dengan parameter 
	<parameter class="command">--export</parameter>. Merupakan ide yang bagus untuk menentukan parameter 
	<parameter class="command">--output</parameter>, hal ini akan menyimpan berkas pada sebuah berkas.
	Contoh berikut akan menyimpan kunci publik dari <emphasis>John Doe</emphasis>, yang digunakan pada contoh 
	sebelumnya, pada berkas <filename>key.gpg</filename>:
      </para>

      <screen>
$ <userinput>gpg --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	Hal ini menyimpan kunci dalam format biner. Seringkali, lebih nyaman untuk menggunakan apa yang disebut <quote>ASCII armored</quote>, yang lebih cocok untuk menambahkan kunci pada email, atau halaman web. Anda bisa mengekspor versi ASCII
	dengan menambahkan parameter <parameter
	class="command">--armor</parameter>:
      </para>

      <screen>
$ <userinput>gpg --armor --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	If you look at the <filename>key.gpg</filename> file you will
	notice that the ASCII armored key is a much more comfortable
	format.
      </para>
    </sect2>

    <sect2>
      <title>Tanda tangan</title>

      <para>
	Dengan GPG Anda bisa membuat tanda tangan (signature) untuk sebuah berkas. Tanda tangan
	ini bersifat unik, karena tanda tangan Anda hanya bisa dibuat oleh kunci pribadi Anda.
	Hal ini berarti orang lain bisa memastikan apakah berkas memang dikirim oleh Anda, dan apakah 
	diubah atau tidak selama pengiriman. Berkas bisa ditandai dengan parameter <parameter
	class="command">--detach-sign</parameter>. Mari kita lihat pada sebuah contoh. Perintah 
	berikut akan membuat sebuah tanda tangan untuk berkas <filename>memo.txt</filename>. Tanda 
	tangan akan disimpan pada <filename>memo.txt.sig</filename>.
      </para>

      <screen>
$ <userinput>gpg --output memo.txt.sig --detach-sign memo.txt</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	Seperti yang Anda lihat, GnuPG akan meminta Anda untuk memasukkan kata sandi untuk kunci private
	Anda. Setelah Anda memasukkan kunci yang benar, berkas signature (<filename>memo.txt.sig</filename>) akan dibuat.
      </para>

      <para>
	Anda bisa melakukan verifikasi sebuah berkas dengan signaturenya dengan menggunakan <parameter
	class="command">--verify</parameter>. Tentukan berkas signature sebagai parameter kepada <parameter
	class="command">--verify</parameter>. Berkas yang perlu diverifikasi bisa ditentukan sebagai parameter final:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	Hal ini akan mengkonfirmasikan bahwa berkas memang ditandatangani oleh 
	<emphasis>John Doe (Work) &lt;john@doe.com&gt;</emphasis>,
	dengan kunci <emphasis>8D080768</emphasis>, dan berkas tadi belum berubah. Jika misalnya 
	berkas berubah, GnuPG akan memprotesnya:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>
    </sect2>

    <sect2>
      <title>Enkripsi</title>

      <para>
	Salah satu fitur utama dari GnuPG adalah enkripsi. Karena penggunaan kriptografi asimetris, orang 
	yang mengenkripsi berkas dan orang yang mendekripsi berkas tidak harus berbagi kunci yang sama. Anda 
	bisa mengenkripsi sebuah berkas dengan kunci publik dari orang lain, dan hanya orang tersebut yang bisa 
	mendekripsinya dengan kunci privatenya. Anda bisa mengenkripsi berkas dengan <parameter
	class="command">--encrypt</parameter>. Jika Anda tidak menyatakan ID pengguna yang akan digunakan sebagai 
	penerima, GnuPG akan menanyakannya. Anda bisa menentukan ID pengguna dengan parameter 
	<parameter class="command">-r</parameter>. Pada contoh berikut, berkas <filename>secret.txt</filename>
	akan dienkripsi untuk orang lain bernama <emphasis>John
	Doe</emphasis>:
      </para>

      <screen>
$ <userinput>gpg --encrypt -r "John Doe" secret.txt</userinput>
      </screen>

      <para>
	ID pengguna diberi tanda kutip ganda untuk memastikan ID diinterpretasikan sebagai satu argumen. Setelah 
	enkripsi selesai, versi terenkripsi akan tersedia sebagai <filename>secret.txt.gpg</filename>.
      </para>

      <para>
	Pengguna yang menerima berkas bisa mendekripsinya dengan parameter 
	<parameter class="command">--decrypt</parameter> dari perintah <command>gpg</command>:
      </para>

      <screen>
$ <userinput>gpg --output secret.txt --decrypt secret.txt.gpg</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16 (main key ID EC3ED1AB)

Enter passphrase:

gpg: encrypted with 2048-bit RSA key, ID 8D080768, created 2004-07-16
      "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	Pada contoh ini, parameter <parameter
	class="command">--output</parameter> digunakan untuk menyimpan isi yang sudah didekripsi pada <filename>secret.txt</filename>.
      </para>
    </sect2>
  </sect1>
</chapter>
