<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 xml:lang="en"
	 xml:id="chap-filesystem">
  <title>Fichiers et répertoires</title>

  <sect1 xml:id="chap-filesystem-introduction">
    <title>Un peu de théorie</title>

    <para>
      Avant de regarder la pratique des opération sur les systèmes de fichiers,
      nous allors voir une vue d'ensemble plus théorique sur comment les
      systèmes de fichiers sur les systèmes de type UNIX fonctionnent. Slackware
      Linux supporte beaucoup de systèmes de fichiers différents, cependant tous
      ces systèmes de fichiers utilisent pratiquement la même sémantique. Cette
      sématique est fournie à travers la couche <emphasis>Système de Fichiers
      Virtuel</emphasis> (Virtual FileSystem - VFS), fournissant une interface
      générique pour les systèmes de fichiers disque et les réseau.
    </para>

    <sect2 xml:id="chap-filesystem-introduction-atoms">
      <title>inodes, répertoires et données</title>

      <para>
	Le système de fichiers comporte 2 type d'éléments : les données et les
	métadonnées. Les métadonnées décrivent les blocs réels sur le disque. La
	plupart des systèmes de fichiers utilisent des noeuds d'information
	(information nodes - inodes) pour stocker les métadata. La plupart des
	systèmes de fichiers stockent les données suivantes dans leurs inodes :
      </para>

      <table xml:id="chap-filesystem-introduction-atoms-inodes">
        <title>Champs d'inode courants</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Champ</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>Les droits d'accès du fichier.</entry>
            </row>
            <row>
              <entry>uid</entry>
              <entry>L'ID utilisateur du propriétaire du fichier.</entry>
            </row>
            <row>
              <entry>gid</entry>
              <entry>L'ID du groupe propriétaire du fichier.</entry>
            </row>
            <row>
              <entry>size</entry>
              <entry>Taille du fichier en octets.</entry>
            </row>
            <row>
              <entry>ctime</entry>
              <entry>Date de création du fichier.</entry>
            </row>
            <row>
              <entry>mtime</entry>
              <entry>Date de la dernière modification du fichier.</entry>
            </row>
            <row>
              <entry>links_count</entry>
              <entry>Le nombre de liens pointant sur cet inode.</entry>
            </row>
            <row>
              <entry>i_block</entry>
              <entry>Pointeurs vers des blocs de données.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Si vous n'êtes pas un afficionado d'UNIX ou Linux, ces noms ressemblent
	peut-être à du chinois pour vous, mais nous allons éclaircir leur
	signification dans les sections suivantes. En tout cas, vous pouvez
	probablement déduire la relation entre les inodes et les données à
	partir de ce tableau, et notamment le champ <emphasis>i_block</emphasis>
	: tout inode contient des pointeurs vers des blocs de données et les
	informations qui s'y rapportent. Ensemble, l'inode et les blocs de
	données constituent véritablement le fichier sur le système de fichiers.
      </para>

      <para>
	Vous vous demandez peut-être maintenant où sont les noms des fichiers
	(et répertoires), puisqu'il n'y a pas de champ nom de fichier dans
	l'inode. En fait, les noms des fichiers sont séparés des inodes et des
	blocs de données, ce qui vous permet de faire des choses épatantes,
	comme donner plus d'un nom à un fichier. Les noms de fichiers sont
	stockés dans ce qu'on appelle les entrées de répertoire. Ces entrées
	spécifient un nom de fichier et l'inode du fichier. Puisque les
	répertoires sont aussi représentés par des inodes, une structure de
	répertoire peut aussi être construit de cette manière.
      </para>

      <para>
	Nous pouvons montrer simplement comment tout cela fonctionne en
	illustrant ce que le noyau fait can nous exécutons la
	commande <command>cat /home/daniel/note.txt</command>
      </para>

      <orderedlist>
        <listitem>
	  <para>
	    Le système lit l'inode du répertoire <filename>/</filename>, vérifie
	    si l'utilisateur est autorisé d'accéder à cet inode, et lit le bloc
	    de données pour trouver le numéro d'inode du
	    répertoire <filename>home</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    Le système lit l'inode du répertoire <filename>home</filename>,
	    vérifie si l'utilisateur est autorisé d'accéder à cet inode, et lit
	    le bloc de données pour trouver le numéro d'inode du
	    répertoire <filename>daniel</filename>. </para>
        </listitem>
        <listitem>
          <para>
	    Le système lit l'inode du répertoire 
	    <filename>daniel</filename>, vérifie si l'utilisateur est autorisé
	    d'accéder à cet inode, et lit le bloc de données pour trouver le
	    numéro d'inode du fichier <filename>note.txt</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    Le système lit l'inode du fichier <filename>note.txt</filename>,
	    vérifie si l'utilisateur est autorisé d'accéder à cet inode, et
	    retourne les blocs de données à <command>cat</command> à travers
	    l'appel système <emphasis>read()</emphasis>. </para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="chap-filesystem-introduction-permissions">
      <title>Droits d'accès fichier</title>

      <para>
	Comme décrit précédemment, Linux est un système multi-utilisateur. Cela
	signifie que chaque utilisateur possède ses propres fichiers
	(habituellement situés dans le répertoire personnel). De plus les
	utilisateurs peuvent être membres d'un groupe, ce qui peut donner à
	l'utilsateur des privilèges supplémentaires.
      </para>

      <para>
	Comme vous avez pu voir dans la table des champs d'inode, chaque fichier
	at sont propriétaire et un groupe. Le contrôle d'accès traditionel UNIX
	offre les droits de lecture, d'écriture ou d'exécution au propriétaire
	du fichier, au groupe, et aux autres utilisateurs. Ces permissions sont
	stockées dans le champ <emphasis>mode</emphasis> de l'inode. Ce champ
	mode représenté les droits d'accès du fichier sous forme d'un nombre
	octal à 4 chiffres. Le premier chiffre représents quelques options
	spéciales, le deuxième chiffre stocke les permissions du propriétaire,
	le troisième les permissions du groupe, et le quatrième les permissions
	pour les autres utilisateurs. Les permissions sont établies par chiffre
	par chiffre en utilisant ou en additionnant un des nombres de
	<xref linkend="chap-filesystem-permissions-numbers"/>
      </para>

      <table xml:id="chap-filesystem-permissions-numbers">
        <title>Signification des nombres dans l'octet mode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Nombre</entry>
              <entry>Signification</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>Exécution (x)</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>Ecriture (w)</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>Lecture (r)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	A présent, supposez qu'un fichier a pour mode <emphasis>0644</emphasis>,
	cela signifie que le fichier peut être lu et écrit par le propriétaire
	(<emphasis>6</emphasis>), et lisible par le groupe
	(<emphasis>4</emphasis>) et les autres
	(<emphasis>4</emphasis>). </para>

      <para>
	La plupart des utilisateurs ne veulent pas manipuler les nombres octals,
	donc c'est pourquoi beaucoup d'utilitaires sont capables de manipuler
	les représentations alphabétiques des permissions de fichiers. Les
	lettres listées dans
	<xref linkend="chap-filesystem-permissions-numbers"/> entre parenthèses
	sont utilisées dans cette notation. Dans l'exemple suivant les
	informations sur un fichier ayant les
	permissions <emphasis>0644</emphasis> sont affichées. Les nombres sont
	remplacés par trois triplets rwx (le premier caractère peut lister des
	options de mode spéciales).
      </para>

      <screen>
$ <userinput>ls -l note.txt</userinput>
-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt
      </screen>

      <para>
	Avec les années ces permissions UNIX traditionelles ont prouvé leurs
	lacunes dans certains cas. La spécification POSIX 1003.1e visant à
	étendre le modèle de contrôle d'accès UNIX avec les <emphasis>Liste de
	Contrôle d'Accès</emphasis> (Access Control Lists - ACLs).
	Malheureusement cet effort a été vain, même si quelques systèmes (comme
	GNU/Linux) ont implementé les ACLs<footnote>
	<para>Au moment de l'écriture de ce livre, les ACLs étaient supportées
	sur les systèmes de fichiers ext2, ext3, et XFS </para> </footnote>. Les
	listes de contrôle d'accès suivent la même sémantique que les
	permissions normales sur les fichiers mais permettent d'ajouter des
	triplets <emphasis>rwx</emphasis> pour des utilisateurs et groupes
	supplémentaires.</para>

      <para>
	L'exemple suivant montre la liste de contrôle d'accès d'un
	fichier. Comme vous pouvez le voir, les permissions ressemblents aux
	permissions UNIX normales (les droits d'accès pour l'utilisateur, le
	groupe, et les autres sont spécifiés). Mais il y a aussi des entrées
	supplémentaires pour l'utilisateur <emphasis>joe</emphasis>.
      </para>

      <programlisting>
user::rwx
user:joe:r--
group::---
mask::r--
other::---
      </programlisting>

      <para>
	Pour rentre les choses encore plus compliquées (et sophistiquées),
	certains systèmes GNU/Linux ajoutent des contrôles d'accès plus fins
	avec les frameworks de contrôles d'accès obligatoires (Mandatory Access
	Control Frameworks - MAC) comme SELinux et AppArmor. Mais ces frameworks
	de contrôle d'accès sont au-delà du cadre de ce livre.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystems-introduction-links">
      <title>Les liens</title>

      <para>
	Une entrée de répertoire qui pointe vers un inode est nommé un
	<emphasis>lien physique</emphasis> (hard link). La plupart des fichiers
	sont liés une seule fois, mais rien ne vous empêche des lier un fichier
	deux fois. Cela va incrémenter le champ <emphasis>links_count</emphasis>
	de l'inode. C'est un bon moyen pour le système de voir quels inodes et
	blocs de données sont libres. Si links_count est égal à 0, l'inode n'est
	plus référencé, et peut être récupéré.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-hardlink">
        <title>La structure d'un lien physique</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/hardlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/hardlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
	Les liens physiques ont 2 limitations. Premièrement, les liens physiques
	ne peuvent pas être effectuées entre systèmes de fichiers différents,
	puisqu'ils pointent sur des inodes. Chaque système de fichiers a ses
	propres inodes et ses numéros d'inode correspondants. De plus, la
	plupart des systèmes de fichiers ne vous autorisent pas de créer des
	liens physiques vers des répertoires. Autoriser la création de liens
	physiques sur des répertoires pourrait conduire à des boucles de
	répertoires, potentiellement générateurs de bloquages et incohérence du
	système de fichiers. En plus, la plupart des implémentations
	de <command>rm</command> et <command>rmdir</command> ne savent pas se
	débrouiller avec les liens physiques de répertoires.
      </para>

      <para>
        <emphasis>Les liens symboliques</emphasis> n'ont pas ces limitations,
        car ils pointent vers les noms de fichiers, au lieu de pointer vers des
        inodes. Quand vous utilisez un lien symbolique, le système
        d'exploitation va suivre le chemin de ce lien. Les liens symboliques
        peuvent aussi faire référence à un fichier qui n'existe pas, puisqu'il
        ne contiennent qu'un nom. De tels liens sont appelés des liens cassés.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-symlink">
        <title>Structure d'un lien symbolique</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/symlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/symlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>
	  Si jamais vous faites de l'administration système, il est bon d'être
	  conscient des conséquences de la sécurité des liens physiques. Si le
	  répertoire <filename>/home</filename> est sur le même système de
	  fichiers que les binaires système, un utilisateur sera capable de
	  créér un lien physique sur ces binaires. Si un programme vulnérable
	  est mis à jour, le lien dans le répertoire personnel (home) de
	  l'utilisateur va continuer à pointer vers l'ancien binaire du
	  programme, conservant ainsi l'accès à un binaire vulnérable.
	</para>

        <para>
	  Pour cette raison, il est judicieux de placer tout répertoire que les
	  utilisateurs peuvent écrire sur des systèmes de fichiers
	  différents. En pratique, cela signifie qu'il est conseillé de mettre
	  au moins <filename>/home</filename> et <filename>/tmp</filename> sur
	  des systèmes de fichiers séparés.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystems-analyzing">
    <title>Analyser des fichiers</title>

    <para>
      Avant de s'aventurer autrepart, nous allons commencer par quelques bases sur l'utilisation des fichiers et répertoires.
    </para>

    <sect2 xml:id="chap-filesystems-analyzing-listing">
      <title>Lister des fichiers</title>

      <para>
	Une des choses les plus fréquentes que vous voudrez faire est de lister
	la totalité ou certains fichiers. La commande <command>ls</command>
	remplit très bien cet objectif. Utiliser <command>ls</command> sans
	argument affichera le contenu du répertoire courant :
      </para>

      <screen>
$ <userinput>ls</userinput>
dns.txt  network-hosts.txt  papers
      </screen>

      <para>
	Si vous utilisez une distribution GNU/Linux, vous voulez peut-être aussi
	voir de la coloration fantaisie basée sur le type du fichier. La sortie
	par défaut est pratique pour parcourir le contenu d'un répertoire, mais
	si vous voulez plus d'informations, vous pouvez utiliser le
	paramètre <parameter class="command">-l</parameter>. Ceci fournit un
	listing soit-disant long pour chaque fichier :
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Cela donne beaucoup plus d'informations sur les trois entrées du
	répertoire que nous avons eues avec <command>ls</command>. La première
	colonne indique les autorisations du fichier. La ligne qui affiche
	l'entrée <filename>papers</filename> commence par un <quote>d</quote>,
	ce qui signifie que cette entrée représente un répertoire. La deuxième
	colonne indique le nombre de liens physiques pointant vers le même inode
	pointé par ce même répertoire. Si ce nombre est supérieur à 1, il y a un
	autre nom de fichier pour le même fichier. Les entrées de répertoire ont
	généralement au moins deux liens physiques, à savoir le lien dans le
	répertoire parent et le lien dans le répertoire lui-même (chaque
	répertoire a une entrée <filename>.</filename>, qui référence le
	répertoire lui-même). Les troisième et la quatrième colonnes listent
	respectivement le propriétaire du fichier et le groupe. La cinquième
	colonne contient la taille du fichier en octets. La sixième colonne est
	la date de dernière modification et la date du fichier. Et enfin, la
	dernière colonne indique le nom de cette entrée.
      </para>

      <para>
	Les fichiers commençant par un point (.) ne seront pas affichés par la
	plupart des applications, y compris <command>ls</command>. Vous pouvez
	lister aussi ces fichiers, en ajoutant
	l'option <parameter class="command">-a</parameter> à
	<command>ls</command> :
      </para>

      <screen>
$ <userinput>ls -la</userinput>
total 60
drwxrwxr-x   3 daniel daniel  4096 Sep 11 10:01 .
drwx------  88 daniel daniel  4096 Sep 11 10:01 ..
-rw-rw-r--   1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--   1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x   2 daniel daniel  4096 Sep  4 15:55 papers
-rw-rw-r--   1 daniel daniel     5 Sep 11 10:01 .settings
      </screen>

      <para>
	Comme vous pouvez le voir, 3 entrées supplémentaires sont
	apparues. Premi_rement, le fichier <filename>.settings</filename> est
	maintenant affiché. De plus vous pouvez voir 2 entrées de répertoire
	supplémentaires, <filename>.</filename>
	et <filename>..</filename>. Celles-ci représentent respectivement le
	répertoire courant et le répertoire parent.
      </para>

      <para>
	Précédemment dans ce chapitre
	(<xref linkend="chap-filesystem-introduction-atoms"/>) nous avons parlé
	des inodes. Le numéro d'inode sur lequel pointe une entrée de répertoire
	peut être affiché avec le
	paramètre <parameter class="command">-i</parameter>. Supposez que j'aie
	créé un lien physique vers l'inode qui pointe sur le même inode
	que <filename>dns.txt</filename>, ils devraient avoir le même numéro
	d'inode. La sortie suivante de <command>ls</command> montre que c'est
	bien cela :
      </para>

      <screen>
$ <userinput>ls -i dns*</userinput>
3162388 dns-newhardlink.txt
3162388 dns.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-file">
      <title>Determiner le type d'un fichier</title>

      <para>
	Parfois vous voulez de l'aide pour déterminer le type d'un
	fichier. C'est là que l'utilitaire <command>file</command> devient
	pratique. Supposez que j'aie trouvé un fichier
	nommé <filename>HelloWorld.class</filename> quelque par sur mon
	disque. Je suppose que c'est un fichier qui contient du bytecode Java,
	mais nous pouvons utiliser <command>file</command> pour vérifier ceci :
      </para>

      <screen>
$ <userinput>file HelloWorld.class</userinput>
HelloWorld.class: compiled Java class data, version 49.0
      </screen>

      <para>
	C'est bien du bytecode Java. <command>file</command> est plutôt sympa,
	et gère la plupart des choses que vous lui envoyez. Par exemple, vous
	pouvez lui demander de fournir des informations sur un point d'accès de
	périphérique :
      </para>

      <screen>
$ <userinput>file /dev/zero</userinput>
/dev/zero: character special (1/5)
      </screen>

      <para>
	Ou sur un lien symbolique :
      </para>

      <screen>
$ <userinput>file /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: symbolic link to `Xorg'
      </screen>

      <para>
	Si vous êtres plutôt intéressé par le fichier pointé par
	<filename>/usr/X11R6/bin/X</filename>, vous pouvez utiliser
	l'option <parameter class="command">-L</parameter> de
	<command>file</command> :
      </para>

      <screen>
$ <userinput>file -L /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: setuid writable, executable, regular file, no read permission
      </screen>

      <para>
	Vous vous demandez comment <command>file</command> peut déterminer le
	type de fichier si facilement. La plupart des fichiers commencent par un
	soit-disant <emphasis>magic number</emphasis> (numéro magique), C'est un
	numéro unique qui dit aux programmes qui peuvent lire le fichier de quel
	type de fichier il s'agit. Le programme <command>file</command> utilise
	un fichier qui décrit beaucoup de types de fichiers avec leur magic
	number. Par exemple, le fichier magic sur mon système contient les
	lignes suivantes pour les fichiers de classes Java compilé :
      </para>

      <programlisting>
# Java ByteCode
# From Larry Schwimmer (schwim@cs.stanford.edu)
0       belong          0xcafebabe      compiled Java class data,
>6      beshort x       version %d.
>4      beshort x       \b%d
      </programlisting>

      <para>
	Cette entrée dit que si un fichier commence par un numéro magique
	hexadécimal long (32-bit) <emphasis>0xcafebabe</emphasis><footnote>
          <para>Ouais, vous pouvez aussi être inventif avec les magic numbers
          !</para> </footnote>, c'est un fichier qui contient
          <quote>compiled Java class data</quote>. L'entier court (short) quit
          suit détermine la version du format du fichier de classe.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-integrity">
      <title>Intégrité du fichier</title>

      <para>
	Comme nous allons voir plus tard des vérifications plus avancées
	d'intégrité de fichiers, <!-- XXX xref --> nous regarderons rapidement
	l'utilitaire <command>cksum</command>. <command>cksum</command> peut
	calculer un contrôle de redondance cyclique (Cyclic Redundancy Check
	-CRC) pour un fichier en entrée. C'est une méthode mathématique
	rationnelle pour calculer un nombre unique pour un fichier. Vous pouvez
	utiliser ce nombre pour vérifier si un fichier est inchangé (par
	exemple, après téléchargement d'un fichier à partir d'un serveur). Vous
	pouvez specifier le fichier pour lequel calculer le CRC en paramètre
	de <command>cksum</command>, et <command>cksum</command> va afficher le
	CRC, la taille du fichier en octets, et le nom du fichier :
      </para>

      <screen>
$ <userinput>cksum myfile</userinput>
1817811752 22638 myfile
      </screen>

      <para>
	Slackware Linux fournit aussi des utilitaires pour calculer des sommes
	de contrôle basées sur des tables de hachage (par exemple MD5 ou SHA-1).
	<!-- XXX - elaborate -->
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-viewing">
      <title>Voir des fichiers</title>

      <para>
	Comme la plupart des fichiers sur les systèmes UNIX sont des fichiers
	texte, ils sont faciles à voir à partir d'un terminal à base de
	caractères ou d'un émulateur de terminal. La manière la plus simple de
	regarder le contenu d'un fichier est
	d'utiliser <command>cat</command>. <command>cat</command> lit les
	fichiers qui ont été spécifiés en paramètres ligne par ligne, et écrit
	les lignes sur la sortie standard. Ainsi, vous pouvez écrire le contenu
	du fichier <nom_fichier>note.txt</filename> vers le terminal
	avec <command>cat note.txt</command>. Alors que certains systèmes et la
	plupart des émulateurs de terminaux fournissent une fonction de
	défilement, ce n'est pas un moyen pratique pour visualiser des fichiers
	volumineux. Vous pouvez rediriger la sortie de <command>cat</command>
	vers le paginateur <command>less</command> :
      </para>

      <screen>
$ <userinput>cat note.txt | less</userinput>
      </screen>

      <para>
	ou laisser <command>less</command> lire le fichier directement :
      </para>

      <screen>
$ <userinput>less note.txt</userinput>
      </screen>

      <para>
	Le paginateur <command>less</command> vous permet de faire défiler en
	avant et en arrière dans un
	fichier. <xref linkend="chap-filesystem-analyzing-viewing-less-keys"/>
	fournit un aperçu des touches les plus importantes utilisées pour
	contrôler <command>less</command>.
      </para>

      <table xml:id="chap-filesystem-analyzing-viewing-less-keys">
        <title>Touches de commande less</title>

        <tgroup cols="2" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Touche</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>j</entry>
              <entry>Défile en avant d'une ligne.</entry>
            </row>
            <row>
              <entry>k</entry>
              <entry>Défile en arrière d'une ligne.</entry>
            </row>
            <row>
              <entry>f</entry>
              <entry>Défile en avant d'une page de texte.</entry>
            </row>
            <row>
              <entry>b</entry>
              <entry>Défile en arrière d'une page de texte.</entry>
            </row>
            <row>
              <entry>q</entry>
              <entry>Quitter less.</entry>
            </row>
            <row>
              <entry>g</entry>
              <entry>Aller au début du fichier.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>Aller à la fin du fichier.</entry>
            </row>
            <row>
              <entry>/<emphasis>motif</emphasis></entry>
              <entry> Cherche l'<link xl:href="#chap-textproc-regexps">expression régulière</link>
                <emphasis>motif</emphasis>. </entry>
            </row>
            <row>
              <entry>n</entry>
              <entry> Cherche l'occurrence suivante de l'exmpression régulière spécifiée précédemment.
              </entry>
            </row>
            <row>
              <entry>m<emphasis>letter</emphasis></entry>
              <entry> Marque la position courant dans le fichier avec <emphasis>letter</emphasis>.
              </entry>
            </row>
            <row>
              <entry>'<emphasis>letter</emphasis></entry>
              <entry>Aller à la marque <emphasis>letter</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Les touches de commandes qui peuvent être quantifiées peuvent être
	préfixées par un nombre. Par exemple <emphasis>11j</emphasis> défile
	vers l'avant de 11 lignes, et <emphasis>3n</emphasis> cherche la
	troisième occurrence de l'expression régulière précédemment spécifiée.
      </para>

      <para>
	Slackware Linux fournit aussi une alternative à
	<command>less</command>, la commande plus ancienne <quote>more</quote>.
	Nous n'allons pas voir <emphasis>more</emphasis> ici,
	<command>less</command> est plus confortable, et aussi plus populaire
	actuellement.
      </para>

    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-filesize">
      <title>Taille des fichiers et répertoires</title>

      <para>
	La sortie de <command>ls -l</command> que nous avons vue précédemment
	fournit des informations à propos de la taille d'un fichier. Alors que
	cette information sur la taille des fichiers suffit la plupart du temps,
	vous voudriez peut-être savoir cette information pour des ensembles de
	fichiers ou répertoires. C'est là que la commande <command>du</command>
	entre en jeu. Par défaut, <command>du</command> affiche la taille des
	fichiers par répertoire. Par exemple :
      </para>

      <screen>
$ <userinput>du ~/qconcord</userinput>
72      /home/daniel/qconcord/src
24      /home/daniel/qconcord/ui
132     /home/daniel/qconcord
      </screen>

      <para>
        Par défaut, <command>du</command> represente la taille en blocs de 1024
        octets. Vous pouvez spécifier explicitement que <command>du</command>
        doit s'exprimer en blocs de 1024 octets en ajoutant le
        flag <parameter class="command" >-k</parameter>. C'est utile pour écrire
        des scripts, car d'autres systèmes utilisent par défaut des blocs de 512
        octets. Par exemple :
      </para>

      <screen>
$ <userinput>du -k ~/qconcord</userinput>
72	/home/daniel/qconcord/src
24	/home/daniel/qconcord/ui
132	/home/daniel/qconcord
      </screen>

      <para>
	Si vous voulez aussi l'espace disque utilisé par fichier, vous pouvez
	ajouter le flag <parameter class="command">-a</parameter> :
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord</userinput>
8       /home/daniel/qconcord/ChangeLog
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
12      /home/daniel/qconcord/Makefile
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
8       /home/daniel/qconcord/qconcord.pro
132     /home/daniel/qconcord
      </screen>

      <para>
	Vous pouvez aussi préciser le nom d'un fichier ou un joker en
	paramètre. Mais cela ne va pas afficher la taille des fichiers dans les
	répertoires, à moins que <parameter class="command">-a</parameter> soit
	précisé :
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord/*</userinput>
8       /home/daniel/qconcord/ChangeLog
12      /home/daniel/qconcord/Makefile
8       /home/daniel/qconcord/qconcord.pro
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
      </screen>

      <para>
	Si vous voulez avoir la somme totale d'occupation disque de fichiers et
	sous-répertoires dans un répertoire, utilisez le
	flag <parameter class="command">-s</parameter> :
      </para>

      <screen>
$ <userinput>du -k -s ~/qconcord</userinput>
132     /home/daniel/qconcord
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-directories">
    <title>Travailler avec les répertoires</title>

    <para>
      Après avoir survolé les répertoires dans
      <xref linkend="chap-filesystem-introduction-atoms"/>, nous allons voir
      quelques commandes liées aux répertoires.
    </para>

    <sect2 xml:id="chap-filesystem-directories-listing">
      <title>Lister des répertoires</title>

      <para>
	La commande <command>ls</command> que nous avons vue dans
	<xref linkend="chap-filesystems-analyzing-listing"/> peut aussi être
	utilisée pour lister les répertoires de plusieurs manières. Comme nous
	avons vu, la sortie par défaut de <command>ls</command> inclut les
	répertoires, et les répertoires peuvent être identifiés en regardant la
	première colonne de la sortie en mode long :
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Si un répertoire, ou si des jokers sont spécifiés,
	<command>ls</command> va lister respectivement le contenu du répertoire
	ou des répertoires qui correspondent au jocker. Par exemple, s'il y a un
	répertoire <filename>papers</filename>, <command>ls paper*</command> va
	lister le contenu de ce répertoire <filename>paper</filename>. Cela est
	souvent ennuyeux si vous voulez juste voir les occurrences, et non le
	contenu des répertoires
	correspondants. <parameter class="command">-d</parameter> empêche
	d'effectuer cette récursion :
      </para>

      <screen>
$ <userinput>ls -ld paper*</userinput>
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Vous pouvez aussi lister récursivement le contenu d'un répertoire, et
	ses sous-répertoires avec le
	paramètre <parameter class="command">-R</parameter> :
      </para>

      <screen>
$ <userinput>ls -R</userinput>
.:
dns.txt  network-hosts.txt  papers

./papers:
cs  phil

./papers/cs:
entr.pdf

./papers/phil:
logics.pdf
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-directories-management">
      <title>Créer et détruire des répertoires</title>

      <para>
	UNIX fournit la commande <command>mkdir</command> pour créer des
	répertoires. Si un chemin relatif est specifié, le répertoire est créé
	dans le répertoire de travail courant. La syntaxe de base est très
	simple : <emphasis>mkdir &lt;name&gt;</emphasis>, par exemple :
      </para>

      <screen>
$ <userinput>mkdir mydir</userinput>
      </screen>

      <para>
	Par défaut, <command>mkdir</command> ne crée qu'un seul niveau de
	répertoire. Donc, si vous utilisez <command>mkdir</command> pour
	créer <filename>mydir/mysubdir</filename>, <command>mkdir</command> va
	échouer si <filename>mydir</filename> n'existe pas déjà. Si vous voulez
	créer les 2 répertoires à la fois, utilisez le
	paramètre <parameter class="command">-p</parameter> :
      </para>

      <screen>
$ <userinput>mkdir -p mydir/mysubdir</userinput>
      </screen>

      <para>
	<command>rmdir</command> supprime un répertoire. Son comportement est
	comparable à <command>mkdir</command>. <command>rmdir
	mydir/mysubdir</command> supprime <filename>mydir/subdir</filename>,
	alors que <command>rmdir -p mydir/mysubdir</command>
	supprime <filename>mydir/mysubdir</filename> et
	ensuite <filename>mydir</filename>.
      </para>

      <para>
	Si un sous-répertoire que nous voulons supprimer contient des
	entrées, <command>rmdir</command> va échouer. Si vous voulez supprimer
	un répertoire, avec tout son contenu, utilisez la plutôt la
	commande <command>rm</command>. <!-- XXX - xref -->
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-managing">
    <title>Gérer des fichiers et des répertoires</title>

    <sect2 xml:id="chap-filesystem-managing-copying">
      <title>Copier</title>

      <para>
	Les fichiers et répertoires peuvent être copiés avec la commande
	<command>cp</command>. Dans sa syntaxe de base les fichiers source et
	destination sont spécifiés. L'exemple suivant va faire une copie
	de <filename>file1</filename> nommée <filename>file2</filename> :
      </para>

      <screen>
$ <userinput>cp file1 file2</userinput>
      </screen>

      <para>
	Il n'est pas surprenant que les chemins relatifs et absolus fonctionnent
	aussi :
      </para>

      <screen>
$ <userinput>cp file1 somedir/file2</userinput>
$ <userinput>cp file1 /home/joe/design_documents/file2</userinput>
      </screen>

      <para>
	Vous pouvez aussi spécifier un répertoire en tant que second
	parametètre. Dans ce cas, <command>cp</command> va créer la copie du
	fichier dans ce répertoire, lui donnant le même nom que celui du fichier
	original. S'il y a plus d'un paramètre, le dernier paramètre sera
	considéré comme le répertoire destination. Par exemple
      </para>

      <screen>
$ <userinput>cp file1 file2 somedir</userinput>
      </screen>

      <para>
	va copier à la fois <filename>file1</filename> et
	<filename>file2</filename> dans le répertoire
	<filename>somedir</filename>. Vous ne vous pouvez pas copier plusieurs
	fichiers dans un fichier. Vous devrez pour cela utiliser
	plutôt <command>cat</command> : <!-- XXX href -->
      </para>

      <screen>
$ <userinput>cat file1 file2 > combined_file</userinput>
      </screen>

      <para>
	Vous pouvez aussi utiliser <command>cp</command> pour copier des
	répertoires entiers, en
	ajoutant <parameter class="command">-R</parameter>. Cela va copier
	récursivement un répertoire et tous ses sous-répertoires. Si le
	répertoire destination existe, Le ou les répertoire(s) source seront
	copiés sous le répertoire destination. Si le répertoire destination
	n'existe pas, il sera créé s'il n'y a qu'un répertoire source.
      </para>

      <screen>
$ <userinput>cp -r mytree tree_copy</userinput>
$ <userinput>mkdir trees</userinput>
$ <userinput>cp -r mytree trees</userinput>
      </screen>

      <para>
	Après avoir exécuté ces commandes, il y a 2 copies du répertoire
        <filename>mytree</filename>, <filename>tree_copy</filename> et
        <filename>trees/mytree</filename>. Essayer de copier 2 répertoires vers
        un répertoire destination inexistant va échouer :
      </para>

      <screen>
$ <userinput>cp -R mytree mytree2 newdir</userinput>
usage: cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target
       cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory
      </screen>

      <note>
	<para>
	  Traditionellement, le
	  paramètre <parameter class="command">-r</parameter> est disponible sur
	  beaucoup de système UNIX pour copier récursivement des
	  répertoires. Cependant, le comportement de ce paramètre peut être
	  dépendant de l'implémentation, et la Single UNIX Specification
	  (spécification unique d'UNIX) version 3 dit qu'il pourrait être
	  supprimé dans des versions futures du standard.
	</para>
      </note>

      <para>
	Quand vous copiez des fichiers récursivement, il est judicieux de
	spécifier explicitement le comportement de <command>cp</command> quand
	un lien symbolique est rencontré, si vous voulez
	utiliser <command>cp</command> dans des scripts portables. La Single
	UNIX Specification version 3 ne spécifie pas comment ils doivent être
	gérés par défaut. Si <parameter class="command">-P</parameter> est
	utilisé, les liens symbolique ne seront pas explorés, mais recopiés tel
	quels. Si <parameter class="command">-H</parameter> est utilisé, les
	liens symboliques spécifiés en paramètre de <command>cp</command>
	devraient être explorés, en fonction du type et du contenu du fichier
	pointé. Si <parameter class="command">-L</parameter> est utilisé, les
	liens symboliques qui ont été spécifiés en paramètre
	de <command>cp</command> et les liens symboliques rencontrés au cours de
	la copie récursive devraient être explorés, en fonction du contenu du
	fichier pointé.
      </para>

      <para>
	Si vous voulez préserver les droits droits d'utilisation, les bits
	SGID/SUID, et les dates de modification et d'accès d'un fichier, vous
	pouvez utiliser le flag <parameter>-p</parameter>. Cela va tenter de
	préserver ces propriétés pour la copie du fichier ou répertoire. Des
	bonnes implémentations de <command>cp</command> fournissent aussi des
	protections supplémentaires - si le fichier destination existe déjà, il
	ne serait pas écrasé si les métadonnées associées ne pouvaient pas être
	conservées.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-moving">
      <title>Déplacer des fichiers et répertoires</title>

      <para>
	La commande UNIX pour déplacer les fichiers, <command>mv</command>, peut
	déplacer ou renommer des fichiers ou répertoires. Ce qu'il se passe
	vraiment dépend de l'endroit où se trouvent les fichiers ou
	répertoires. Si l'emplacement de source et la destination sont sur le
	même système de fichiers, généralement <command>mv</command> crée
	seulement des nouveaux liens physiques, renommant dans les faits les
	fichiers ou répertoires. Si les 2 sont sur des systèmes de fichiers, les
	fichiers sont réellement copiés et les fichiers ou répertoires source
	sont supprimés.
      </para>

      <para>
	La syntaxe de <command>mv</command> est comparable à
	<command>cp</command>. La syntaxe de base renomme 
	<filename>file1</filename> en <filename>file2</filename> :
      </para>

      <screen>
$ <userinput>mv file1 file2</userinput>
      </screen>

      <para>
	La même syntaxe peut être utilisée pour deux répertoires, ainsi, ce qui
	va renommer le répertoire donné en premier paramètre vers le second
	paramètre.
      </para>

      <para>
	Lorsque le dernier paramètre est un répertoire existant, le fichier ou
	le répertoire spécifié en tant que premier paramètre, est copié dans ce
	répertoire. Dans ce cas, vous pouvez spécifier plusieurs fichiers ou
	répertoires. Par exemple :
      </para>

      <screen>
$ <userinput>targetdir</userinput>
$ <userinput>mv file1 directory1 targetdir</userinput>
      </screen>

      <para> Cela crée le répertoire <filename>targetdir</filename>, et déplace
        <filename>file1</filename> et <filename>directory1</filename> vers ce
        répertoire.</para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-removing">
      <title>Supprimer des fichiers et répertoires</title>

      <para>
	Les fichiers et répertoires peuvent être supprimés avec la
	commande <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Cette commande supprime les fichiers et
        répertoires. S'il n'y a aucun autre lien sur le fichier, son inode et
        ses blocs disque peuvent être réutilisés pour des nouveaux fichiers. Les
        fichiers peuvent être supprimés en fournissant ceux-ci en tant que
        paramètre de <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Si un fichier n'est pas accessible en
        écriture, <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> demandera confirmation. Par exemple, pour supprimer
        <filename>file1</filename> et <filename>file2</filename>, vous pouvez
        exécuter : </para>

      <screen>
$ <userinput>rm file1 file2</userinput>
      </screen>

      <para>
	Si vous devez supprimer un nombre important de fichiers qui demandent
	confirmation avant d'être effacé, ou si vous voulez
	utiliser <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> pour supprimer des fichiers depuis un script qui ne sera
        pas exécuté depuis un terminal, ajoutez le paramètre
          <parameter class="command">-f</parameter> pour passer outre
          l'utilisation des questions. Les fichiers qui ne sont pas accessibles
          en écriture sont effacés avec le flag <filename>-f</filename> si les
          droits de propriété le permettent. Ce paramètre va aussi supprimer
          l'affichage des erreurs sur
          <emphasis>stderr</emphasis> si un fichier susceptible d'être supprimé
          est introuvable. </para>

      <para> Les répertoires peuvent être aussi supprimés récursivement avec le
        paramètre <parameter class="command" >-r</parameter>. <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> va parcourir la structure des répertoires, supprimant le
        lien et supprimant les répertoires à leur rencontre. La même sémantique
        est aussi utilisée pour supprimer des fichiers normaux, pour ce qui
        concerne le flag <parameter class="command">-f</parameter>. Pour donner
        un petit exemple, vous pouvez supprimer récursivement des fichiers et
        répertoires dans le répertoire <filename>notes</filename> avec :</para>

      <screen>
$ <userinput>rm -r notes</userinput>
      </screen>

      <!-- XXX - describe -i flag? -->

      <para> Puisque la commande <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> utilise la fonction <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>, les blocs de données ne sont pas réécrit à une valeur
        non initialisée. L'information dans les blocs de données ne sont
        écrasées que lorsqu'ils sont réalloués et réutilisés
        ultérieurement. Pour supprimer les fichiers y compris leur blocs de
        données de façon sécurisée, certains systèmes fournissent une
        commande <citerefentry>
          <refentrytitle>shred</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> qui écrase les blocs de données avec des informations
        aléatoires. Mais cela n'est pas le cas sur beaucoup de systèmes de
        fichiers modernes (avec journalisation), car ils n'écrivent pas les
        données localisées. </para>

      <para> La commande <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> fournit une implémentation directe de la
        fonction <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum>
        </citerefentry>. Elle est relativement peu utilisée, car elle ne peut
        pas supprimer des répertoires. </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-permissions">
    <title>Permissions</title>

    <para> Nous avons abordé le sujet des permissions sur les fichiers et
        répertoires dans
        <xref linkend="chap-filesystem-introduction-permissions"/>. Dans cette
        section, nous allons voir les commandes <citerefentry>
        <refentrytitle>chown</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry> and <citerefentry>
        <refentrytitle>chmod</refentrytitle>
        <manvolnum>1</manvolnum>
      </citerefentry>, qui sont utilisées pour configurer respectivement le
      propriétaire et les permission d'un fichier. Après ça, nous allons voir
      une extension moderne des permissions nommée Listes de Contrôle d'Accès
      (ACLs). </para>

    <sect2 xml:id="chap-filesystem-permissions-ownership">
      <title>Changer le propriétaire d'un fichier</title>

      <para> Comme nous l'avons vu précédemment, chaque fichier a un IP
      propriétaire (user) et un ID groupe stockés dans l'inode. La
      commande <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> peut être utilisée pour configurer ces champs. Cela est
        possible par IDs numérique, ou par leur noms. Par exemple, pour changer
        le propriétaire du fichier <filename>note.txt</filename>
        en <emphasis>john</emphasis>, et son groupe
        en <emphasis>staff</emphasis>, la commande suivante est lancée : </para>

      <screen>
$ <userinput>chown john:staff note.txt</userinput>
      </screen>

      <para> Vous pouvez omettre un des composants, pour ne configurer qu'un des
      2 champs. Si vous voulez configurer le nom du propriétaire, vous pouvez
      aussi omettre le deux-points. Donc, la commande ci-dessus peut être
      scindée en 2 étapes : </para>

      <screen>
$ <userinput>chown john note.txt</userinput>
$ <userinput>chown :staff note.txt</userinput>
      </screen>

      <para> Si vous voulez changer le propriétaire d'un répertoire, ainsi que
      celui des fichiers et répertoires qu'il contient, vous pouvez
      ajouter <parameter class="command">-R</parameter> à <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>: </para>

      <screen>
$ <userinput>chown -R john:staff notes</userinput>
      </screen>

      <para> Si le nom d'utilisateur et le nom de groupe ont été spécifié,
      plutôt que des IDs, les noms sont convertis par <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Cette conversion se base habituellement sur la base de
        données de mots de passe définie au niveau système. Si vous utilisez un
        système de fichiers qui utilise une autre base de données de mots de
        passe (e.g. si vous montez un système de fichiers racide depuis un autre
        système pour une restauration), il est souvent utile de changer le
        propriétaire du fichier en utilisant les ID utilisateur et groupe. De
        cette façon, vous pouvez préserver les correspondances des noms
        utilisateur/groupe et ID intactes. Donc, changer le propriétaire
        de <filename>note</filename> en UID 1000 et GUID 1000 est fait de la
        façon suivante (prévisible) : </para>

      <screen>
$ <userinput>chown 1000:1000 note.txt</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-permbits">
      <title>Changer les bits de permission</title>

      <para> Après avoir la lecture de l'introduction sur les permissions du
          système de fichiers en
          <xref linkend="chap-filesystem-introduction-permissions"/>, changer
          les bits de permission qui sont stockés dans l'inode est plutôt facile
          avec la commande <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> accepte à la fois la représentation numérique et
        symbolique des permissions.  Representer les permissions d'un fichier
        numeriquement est très pratique, car cela permet de configurer toutes
        les permissions brièvement. Par exemple : </para>

      <screen>
$ <userinput>chmod 0644 note.txt</userinput>
      </screen>

      <para> Configure <filename>note.txt</filename> en lecture et en écriture
      pour le propriétaire du fichier, et lisible pour le groupe et les
      autres. </para>

      <para> Les permissions symboliques fonctionnent par addition ou
      soustraction de droits, ce qui permet des changements relatifs des
      permissions d'un fichier. La syntaxe pour les permissions symboliques est
      : </para>

      <screen>
[ugo][-+][rwxst]
      </screen>

      <para> Le premier composant spécifie les classes d'utilisateur sur
        lesquelles s'appliquent le changement de permission (user, group ou
        other). La combinaison de plusieurs caractères pour ce composant est
        possible. Le deuxième composant supprime les droits
        (<emphasis>-</emphasis>), ou ajoute les droits
        (<emphasis>+</emphasis>). Le troisième composant est le type d'accès
        (read, write, execute, fixe UID/GID en exécution, sticky). La
        combinaison de plusieurs caractères est possible aussi pour ce
        composant. Regardons quelques exemples pour éclaircir tout ça : </para>

      <screen>
ug+rw        # Donne les droits de lecture/écriture à l'utilisateur et au groupe
             # du fichier
chmod go-x   # Supprime les droits d'exécution pour le groupe et autres du
             # fichier
chmod ugo-wx # Interdit toute classe d'utilisateur d'écrire dans le fichier et
             #d'exécuter le fichier.
      </screen>

      <para> Ces commandes peuvent être utilisées avec chmod de la manière
      suivante : </para>

      <screen>
$ <userinput>chmod ug+rw note.txt</userinput>
$ <userinput>chmod go-x script1.sh</userinput>
$ <userinput>chmod ugo-x script2.sh</userinput>
      </screen>

      <para> Les permissions des fichiers et répertoires peuvent être modifiées
          récursivement avec <parameter class="command">-R</parameter>. La
          commande a pour effet de rendre le répertoire
        <filename>notes</filename> en écriture pour tout le monde, y compris son
        contenu : </para>

      <screen>
$ <userinput>chmod -R ugo+r notes</userinput>
      </screen>

      <para> Il faut faire attention avec les répertoires, car le
      flag <emphasis>x</emphasis> a une signification spéciale dans le contexte
      répertoire. Les utilisateurs ayant les droits d'exécution sur les
      répertoires ont accès au répertoire. Les utilisateur n'ayant pas les
      droits d'exécution sur les répertoires ne le peuvent pas. A cause de ce
      comportement particulier, il est souvent plus facile de changer les
      permissions d'une structure de répertoire et de ses fichiers à l'aide de
      la commande <citerefentry>
          <refentrytitle>find</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry><!-- XXX xref -->. </para>

      <para> Il y a quelques bits de permission supplémentaires pouvant être
      configurés qui ont une signification spéciale. SUID et SGID sont les bitsz
      les plus intéressants parmi ces bits supplémentaires. Ces bits remplacent
      l'ID utilisateur et ID du groupe effectifs par l'ID utilisateur et l'ID
      groupe du fichier qui est exécuté. La commande <command>su(1)</command>
      est un bon exemple qui a le bit SUID activé : </para>

      <screen>
$ <userinput>ls -l /bin/su</userinput>
-rwsr-xr-x  1 root root 60772 Aug 13 12:26 /bin/su
      </screen>

      <para> Cela signifie que la commande <command>su</command> s'exécute en
      tant q'utilisateur <emphasis>root</emphasis> quand elle est exécutée. Le
      bit SUID peut être mis avec le modificateur <emphasis>s</emphasis>. Par
      exemple, si le bit SUID n'a pas été mis sur <filename>/bin/su</filename>
      cela peut être fait avec :</para>

      <screen>
$ <userinput>chmod u+s /bin/su</userinput>
      </screen>

      <note>
        <para> Soyez conscients que les bits SUID et SGID ont des conséquences
        sur la sécurité. Si un programme avec ces bits positionnés contient un
        bug, cela peut être exploité pour obtenir les droits de l'utilisateur ou
        du groupe du fichier. Pour cette raison, il est conseillé de réduire au
        strict minimum les fichiers avec les bits SUID et SGID activés.</para>
      </note>

      <para> Le sticky bit est aussi interessant quand il s'applique à un
      répertoire. Il interdit les utilisateurs de renommer ou supprimer des
      fichiers dont ils ne sont pas propriétaires, dans des répertoires pour
      lesquels ils ont les droits d'écriture. Cest habituellement utilisé sur
      des répertoires avec des accès en écriture pour tout le monde, comme le
      répertoire temporaire (<filename>/tmp</filename>) sur beaucoup de systèmes
      UNIX. Le sticky bit peut être mis avec le
      modificateur <emphasis>t</emphasis> : </para>

      <screen>
$ <userinput>chmod g+t /tmp</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-umask">
      <title>Masque de création des fichiers</title>

      <para>
	La question qui reste est quelles sont les permissions initiales à la
	cration d'un fichier. Cela dépend de 2 facteurs : le flag de mode passé
	à l'appel système <emphasis>open(2)</emphasis>, utilisé pour créer un
	fichier, et le masque de création de fichier. Le masque de création de
	fichier peut être représenté comme un nombre octal. Les permissions
	effectives pour la création du fichiers sont définies par
	le <emphasis>mode &amp; ~masque</emphasis>. Ou bien, si en
	représentation octale, vous pouvez soustraire les chiffres du masque du
	mode. Par exemple, si un fichier est créé avec les
	permissions <emphasis>0666</emphasis> (lecture et écriture pour le
	propriétaire du fichier, le groupe, et les autres), et le masque de
	création de fichiers est <emphasis>0022</emphasis>, les permissions
	effectives du fichier seront <emphasis>0644</emphasis>. Regardons un
	autre exemple. Supposez que les fichiers sont toujours créés avec pour
	permissions <emphasis>0666</emphasis>, et que vous êtes paranoïaque, et
	voulez supprimer toute permission en lecture et écriture sur le groupe
	d'appartenance du fichier et les autres. Cela signifie que vous devez
	avoir pour masque de création de fichiers <emphasis>0066</emphasis>, car
	soustraire <emphasis>0066</emphasis> de
	<emphasis>0666</emphasis> donne
	<emphasis>0600</emphasis>
      </para>
      
      <para>
	Le masque de création effectif peut être lu et écrit avec la
	commande <command>umask</command>, qui est normalement une commande
	interne au shell. Le masque effectif est affiché en
	lançant <command>umask</command> sans aucun paramètre :
      </para>
      
      <screen>
$ <userinput>umask</userinput>
0002
      </screen>
      
      <para>
	Le masque peut être modifié en donnant le numéro de masque en octal en
	paramètre. Par exemple :
      </para>
      
      <screen>
$ <userinput>umask 0066</userinput>
      </screen>
      
      <para>
	Nous pouvons vérifier que ça marche en créant un fichier vide :
      </para>
      
      <screen>
$ <userinput>touch test</userinput>
$ <userinput>ls -l test</userinput>
-rw-------  1 daniel daniel 0 Oct 24 00:10 test2
      </screen>
      
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-acl">
      <title>Listes de Contrôle d'Accès</title>

      <para>
	Les listes de Contrôle d'Accès (<acronym>ACL</acronym>s) sont une
	extension des permissions UNIX sur les fichiers, qui permettent des
	contrôles d'accès plus fins. La plupart des systèmes qui supportent les
	ACLs au niveau système de fichier ont une implémentation conforme aux
	spécifications POSIX.1e et POSIX.2c draft. Parmi les systèmes UNIX et
	systèmes de type UNIX qui implémentent les listes de contrôle d'accès
	conformément à ce draft sont FreeBSD, Solaris, et Linux.
      </para>

      <para>
	Comme nous l'avons vu dans
	<xref linkend="chap-filesystem-introduction-permissions" /> les listes
	de contrôle d'accès vous permettent de créer des triplets lecture,
	écriture et exécution pour des utilisateurs ou groupes
	additionnels. Contrairement aux permissions sur les fichiers
	traditionelles, les listes de contrôle d'accès additionnelles ne sont
	pas stockés dans le noeud, mais dans les attributs étendus associés aux
	fichiers. Vous devez savoir 2 choses quand vous utilisez les listes de
	contrôle d'accès, c'est que tous les systèmes ne le supportent pas, et
	tous les programmes ne le supportent pas.
      </para>

      <sect3 xml:id="chap-filesystem-permissions-acl-reading">
	<title>Lire les listes de contrôle d'accès</title>

	<para>
	  Sur la plupart des systèmes qui supportent les
	  ACLs, <command>ls</command> utilise un indicateur visuel pour montrer
	  qu'il y a des ACLs associés à un fichier. Par exemple :
	</para>

	<screen>
$ <userinput>ls -l index.html</userinput>
-rw-r-----+ 1 daniel daniel 3254 2006-10-31 17:11 index.html
	</screen>

	<para>
	  Comme vous pouvez le voir, la colonne des permissions affiche un signe
	  plus (<emphasis>+</emphasis>) additionnel. Les bits de permission ne
	  sont pas vraiment à ce que vous espériez. Nous allons y revenir dans
	  une minute.
	</para>

	<para>
	  Les ACLs pour un fichier peuvent être consultés avec la commande
	  <command>getfacl</command> :
	</para>

	<screen>
$ <userinput>getfacl index.html</userinput>
# file: index.html
# owner: daniel
# group: daniel
user::rw-
group::---
group:www-data:r--
mask::r--
other::---
	</screen>

	<para>
	  La plupart des lignes peuvent être interpretées très facilement : le
	  propriétaire du fichier a les permissions de lecture/écriture, le
	  groupe du fichier aucune permission, les utilisateurs du
	  groupe <emphasis>www-data</emphasis> ont les permissions de lecture,
	  et les autres utilisateurs n'ont aucune permission. Mais pourquoi
	  l'entrée groupe n'a aucune permission pour le groupe du fichier alors
	  que la commande <command>ls</command> en affiche une ? Le secret est
	  que s'il y a une entrée masque <emphasis>mask</emphasis>,
	  <command>ls</command> affiche la valeur du masque, plutôt que les
	  permissions groupe du fichier.
	</para>

	<para>
	  L'entrée <emphasis>mask</emphasis> est utilisée pour restreindre
	  toutes les entrées sauf l'entrée user du fichier, et celle des autres
	  utilisateurs (other). Le mieux est de mémoriser les règles suivantes
	  pour comprendre les ACLs:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Les permissions de l'entrée <emphasis>user::</emphasis>
	      correspondent aux permissions du propriétaire du fichier.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Les permissions de l'entrée <emphasis>group::</emphasis>
	      correspondent aux permissions du groupe du fichier à moins qu'il y
	      ait une entrée <emphasis>mask::</emphasis> . S'il y a une
	      entrée <emphasis>mask::</emphasis> entry, les permissions du
	      groupe correspondent à l'entrée groupe avec comme permissions
	      maximum celles de l'entrée mask (cela veut dirque que les
	      permissions du groupe peuvent être plus restrictives, mais pas
	      moins).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Les permissions des autres utilisateurs et groupes correspondent
	      aux entrées <emphasis>user:</emphasis>
	      et <emphasis>group:</emphasis>, avec les valeurs
	      de <emphasis>mask::</emphasis> comme permissions maximum.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Les deuxième et troisième règles peuvent vraiment se voir s'il y a un
	  utilisateur ou group qui a plus de droits que le masque pour le
	  fichier :
	</para>

	<screen>
$ <userinput>getfacl links.html</userinput>
# file: links.html
# owner: daniel
# group: daniel
user::rw-
group::rw-                      #effective:r--
group:www-data:rw-              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Bien ques les permissions en lecture et écritures sont données pour le
	  groupe du fichier fichier et pour le
	  groupe <emphasis>www-data</emphasis>, ces deux groupes n'auront dans
	  les faits qu'une permission de lecture, car c'est la permission
	  maximale que l'entrée mask permet.
	</para>

	<para>
	  Un autre aspect à souligner est la manipulation des ACLs sur les
	  répertoires. Les listes de contrôle d'accès peuvent être ajoutées sur
	  les répertoires pour restreindre l'accès, mais les répertoires peuvent
	  aussi avoir des <emphasis>ACLs par défaut</emphasis> qui définissent
	  les valeurs d'ACLs pour les fichiers et sous-répertoires créés dans ce
	  répertoire.
	</para>

	<para>
	  Supposez que le répertoire <filename>reports</filename> a l'ACL
	  suivante:
	</para>

	<screen>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
group:www-data:r-x
mask::r-x
other::---
default:user::rwx
default:group::r-x
default:group:www-data:r-x
default:mask::r-x
default:other::---
	</screen>

	<para>
	  Les nouveaux fichiers créés dans le
	  répertoire <filename>reports</filename> obtiennent une ACL basé sur
	  les entrées avec le préfixe <emphasis>default:</emphasis>. Par exemple
	  :
	</para>

	<screen>
$ touch reports/test
$ getfacl reports/test
# file: reports/test
# owner: daniel
# group: daniel
user::rw-
group::r-x                      #effective:r--
group:www-data:r-x              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Comme vous pouvez le voir, l'ACL par défaut a été copiée. Le bit
	  d'exécution est supprimé du masque, car le nouveau fichier n'a pas été
	  créé avec les permissions d'exécution.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-permissions-acl-setting">
	<title>Creating access control lists</title>

	<para>
	  L'ACL pour un fichier ou répertoire peut être changée avec le
	  programme <command>setfacl</command>. Malheureusement, l'utilisation
	  de ce programme est fortement dépendant du système utilisé. Pour
	  ajouter à la confusion, au moins un flag important
	  (<parameter class="command">-d</parameter>) a des significations
	  différentes sur différents systèmes. On ne peut qu'espérer que cette
	  commande va être standardisée.
	</para>

	<table xml:id="chap-filesystem-permissions-acl-setting-flags">
	  <title>Flags spécifiques au système de <command>setfacl</command></title>
	  
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Opération</entry>
		<entry>Linux</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Ecrit les entrées, supprimant les anciennes entrées</entry>
		<entry><parameter class="command">--set</parameter></entry>
	      </row>
	      <row>
		<entry>Modifie les entrées</entry>
		<entry><parameter class="command">-m</parameter></entry>
	      </row>
	      <row>
		<entry>Modifie les entrées ACL par défaut</entry>
		<entry><parameter class="command">-d</parameter></entry>
	      </row>
	      <row>
		<entry>Efface une entrée</entry>
		<entry><parameter class="command">-x</parameter></entry>
	      </row>
	      <row>
		<entry>
		  Supprime toutes les entrées ACL (sauf les 3 entrées
		  obligatoires)
		</entry>
		<entry><parameter class="command">-b</parameter></entry>
	      </row>
	      <row>
		<entry>Recalcule le masque</entry>
		<entry>
		  Toulouse recalculé, sauf si <parameter
		  class="command">-n</parameter> est utilisé, ou une entrée mask
		  est specifiée explicitement.
		</entry>
	      </row>
	      <row>
		<entry>Utilise la spécification d'une ACL depuis un fichier</entry>
		<entry>
		  <parameter class="command">-M</parameter> (modifie),
		  <parameter class="command">-X</parameter> (supprime),
		  ou <parameter class="command">--restore</parameter> (restaure)
		</entry>
	      </row>
	      <row>
		<entry>Modifications récursive des ACLs</entry>
		<entry><parameter class="command">-R</parameter></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Comme nous avons vu dans la section précédente, les entrées peuvent
	  être specifiées pour les utilisateurs et groupes, en utilisant la
	  syntaxe suivante :
	  <emphasis>user/group:name:permissions</emphasis>. Les permissions
	  peuvent être specifiées sous forme de triplet en utilisant les lettres
	  <emphasis>r</emphasis> (lecture), <emphasis>w</emphasis>
	  (écriture), ou <emphasis>x</emphasis> (execution). Un tiret
	  (<emphasis>-</emphasis>) doit être utilisé pour les permissions que
	  vous ne voulez pas donner à l'utilisateur ou au groupe, comme le
	  demande Solaris. Si vous voulez interdire complètement l'accès, vous
	  pouvez utiliser le triplet <emphasis>---</emphasis>.
	</para>

	<para>
	  La spécification des autres utilisateurs, et du masque suit ce format
	  : <emphasis>other:r-x</emphasis>. Le format suivant moins ambigu peut
	  aussi être utilisé : <emphasis>other::r-x</emphasis>.
	</para>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-modify">
	  <title>Modifier les entrées ACL</title>

	  <para>
	    L'opération la plus simple est de modifier une entrée ACL
	    entry. Cela va créer une nouvelle entrée si l'entrée est
	    inexistante. Les entrées peuvent être modifiées avec <parameter
	    class="command">-m</parameter>. Par exemple, supposez que vous
	    voulez donner au groupe <emphasis>friend</emphasis> les accès en
	    lecture et en écriture au
	    fichier <filename>report.txt</filename>. Cela peut être fait avec :
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw- report.txt</userinput>
	  </screen>

	  <para>
	    L'entrée mask va être recalculée, à partir de l'union de toutes les
	    entrées groupe, et les entrées utilisateur additionnels :
	  </para>

	  <screen>
$ <userinput>getfacl report.txt</userinput>
# file: report.txt
# owner: daniel
# group: daniel
user::rw-
group::r--
group:friends:rw-
mask::rw-
other::r--
	  </screen>

	  <para>
	    Vous pouvez combiner plusieurs entrées ACL en les séparant par le
	    caractère virgule. Par exemple :
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw-,group:foes:--- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-removing">
	  <title>Supprimer les entrées ACL</title>

	  <para>
	    Une entrée peut être supprimée avec l'option <parameter
	    class="command">-x</parameter>:
	  </para>

	  <screen>
$ <userinput>setfacl -x group:friends: report.txt</userinput>
	  </screen>

	  <para>
	    Le deux-points à la fin est optionnel et peut être omis.
	  </para>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-new">
	  <title>Créer une nouvelle ACL</title>

	  <para>
	    L'option <parameter class="command">--set</parameter> est disponible
	    pour créer une nouvelle liste de contrôle d'accès pour un fichier,
	    effaçant les entrées existante, sauf les 3 entrées obligatoires.
	    Il faut que les entrées utilisateur, groupe et autres (user, group
	    et other) soient spécifiées. Par exemple :
	  </para>

	  <screen>
$ <userinput>setfacl --set user::rw-,group::r--,other:---,group:friends:rwx report.txt</userinput>
	  </screen>

	  <para>
	    Si vous ne voulez pas effacer les permissions user, group et other,
	    mais voulez supprimer toutes les autres entrées ACL, vous pouvez
	    utiliser
	    l'option <parameter class="command">-b</parameter>. L'exemple
	    suivant effectue cela avec
	    l'option <parameter class="command">-m</parameter> pour supprimer
	    toutes les entrées ACL (sauf pour user, group, et other), et pour
	    ajouter une entrée pour le groupe <emphasis>friends</emphasis> :
	  </para>

	  <screen>
$ <userinput>setfacl -b -m group:friends:rw- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-default">
	  <title>Configurer l'ACL par défaut</title>

	  <para>
	    Comme nous avons vu dans
	    <xref linkend="chap-filesystem-permissions-acl" />, les répertoires
	    peuvent avoir des entrées ACL par défaut qui spécifient quelles
	    permissions doivent être utilisées pour les fichiers et
	    sous-répertoires créés dans ce
	    répertoire. L'option <parameter class="command">-d</parameter> est
	    utilisée pour fixer les entrées par défaut :
	  </para>

	  <screen>
$ <userinput>setfacl -d -m group:friends:rwx reports</userinput>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:friends:rwx
default:mask::rwx
default:other::r-x
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-filesource">
	  <title>Utiliser une ACL d'un fichier de référence</title>

	  <para>
	    Vous pouvez utiliser la spécification d'une ACL à partir d'un
	    fichier, plutôt que de spécifier en commande en ligne. Un fichier en
	    d'entrée suit la même syntaxe que la spécification des entrées en
	    paramètre de <command>setfacl</command>, mais les entrées sont
	    séparées par des retours à la ligne, plutôt que des virgules. C'est
	    très utile car vous pouvez l'ACL pour un fichier existant comme
	    référence :
	  </para>

	  <screen>
$ <userinput>getfacl report.txt > ref</userinput>
	  </screen>

	  <para>
	    L'option <parameter class="command">-M</parameter> est disponible
	    pour modifier l'ACL pour un fichier en lisant les entrées d'un autre
	    fichier. Donc, si nous avons un fichier
	    nommé <filename>report2.txt</filename>, nous pouvons modifier l'ACL
	    pour ce fichier avec les entrées depuis <filename>ref</filename>
	    avec :
	  </para>

	  <screen>
$ <userinput>setfacl -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Si vous voulez commencer avec une ACL propre, et ajouter des entrées
	    depuis <filename>ref</filename>, vous pouvez ajouter le flag
	    <parameter class="command">-b</parameter> que nous avons vu
	    précédemment :
	  </para>

	  <screen>
$ <userinput>setfacl -b -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Bien sûr, il n'est pas nécessaire d'utiliser ce fichier
	    intermédiaire. Nous pouvons utiliser rediriger directement la sortie
	    de <command>getfacl</command> ver <command>setfacl</command>, en
	    utilisant le nom symbolique de l'entrée standard
	    (<emphasis>-</emphasis>), plutôt qu'un nom de fichier :
	  </para>

	  <screen>
$ <userinput>getfacl report.txt | setfacl -b -M - report2.txt</userinput>
	  </screen>

	  <para>
	    <parameter class="command">-X</parameter> supprime toutes les
	    entrées ACL définies dans un fichier. Cela suit la même syntaxe que
	    le flag <parameter class="command">-x</parameter>, avec des virgules
	    remplaçant les retours à la ligne.
	  </para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-finding">
    <title>Rechercher des fichiers</title>

    <sect2 xml:id="chap-filesystem-finding-find">
      <title>find</title>

      <para>
	La commande <command>find</command> est sans aucun doute l'outil le plus
	complet pour rechercher des fichiers sur les systèmes UNIX. De plus elle
	fonctionne de manière simple et déterministe :
	<command>find</command> parcours l'arborescence des répertoires ou les
	arborescences spécifiées en paramètre
	de <command>find</command>. L'utilisateur peut en plus spécifier une
	expression qui sera évaluée sur chaque fichier et répertoire trouvé.
	Le nom d'un fichier ou répertoire sera affiché si l'expression est
	évaluée à <emphasis>vrai</emphasis>. Le premier argument qui commence
	par un tirer (<emphasis>-</emphasis>), point d'exclamation
	(<emphasis>!</emphasis>, ou une parenthèse ouvrante
	(<emphasis>(</emphasis>, signifie le début de l'expression. L'expression
	peut être constituée de plusieurs opérandes. En bref, la syntaxe de
	<command>find</command> est : <emphasis>find paths
	expression</emphasis>.
      </para>

      <para>
	L'utilisation la plus simple de <command>find</command> est de ne
	spécifier aucune expression. Puisque cela correspond à toute entrée de
	répertoire et de sous-répertoire, tous les fichiers et répertoires
	seront affichés. Par exemple :
      </para>

      <screen>
$ <userinput>find .</userinput>
.
./economic
./economic/report.txt
./economic/report2.txt
./technical
./technical/report2.txt
./technical/report.txt
      </screen>

      <para>
	Vous pouvez aussi spécifier plusieurs répertoires :
      </para>

      <screen>
$ <userinput>find economic technical</userinput>
economic
economic/report.txt
economic/report2.txt
technical
technical/report2.txt
technical/report.txt
      </screen>

      <sect3 xml:id="chap-filesystem-finding-find-nametype">
	<title>Operandes limitant par nom d'objet ou type</title>

	<para>
	  Un scénario courant pour rechercher des fichiers ou répertoires est de
	  les chercher par nom. L'opérande <emphasis>-name</emphasis> peut être
	  utilisé pour trouver des objets qui correspondent à un certain nom, ou
	  qui correspondent à un joker particulier. Par exemple, l'opérande
	  <emphasis>-name 'report.txt'</emphasis> ne sera vrai seulement que
	  pour les fichiers ou répertoires dont le nom
	  est <filename>report.txt</filename>. Par exemple :
	</para>

	<screen>
$ <userinput>find economic technical -name 'report.txt'</userinput>
economic/report.txt
technical/report.txt
	</screen>

	<para>
	  La même règle s'applique pour les jokers :
	</para>

	<screen>
$ <userinput>find economic technical -name '*2.txt'</userinput>
economic/report2.txt
technical/report2.txt
	</screen>

	<note>
	  <para>
	    Quand vous utilisez <command>find</command> vous voudrez passer le
	    joker à <command>find</command>, plutôt que de laisser le shell le
	    résoudre. Donc, vérifiez bien que les motifs sont entre guillemets,
	    ou que les jokers sont préfixés par le caractère d'échappement.
	  </para>
	</note>

	<para>
	  Il est aussi possible d'évaluer le type de l'objet avec
	  l'opérande <emphasis>-type c</emphasis>, où <emphasis>c</emphasis>
	  spécifie le type correspondant.
	  <xref
	  linkend="chap-filesystem-finding-find-nametype-type-params"
	  /> liste les divers types d'objet pouvant être utilisés.
	</para>

	<table xml:id="chap-filesystem-finding-find-nametype-type-params">
	  <title>Paramètres pour l'opérande '-type'</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Paramètre</entry><entry>Signification</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>b</entry><entry>Fichier périphérique bloc</entry>
	      </row>
	      <row>
		<entry>c</entry><entry>Fichier périphérique caractère</entry>
	      </row>
	      <row>
		<entry>d</entry><entry>Répertoire</entry>
	      </row>
	      <row>
		<entry>f</entry><entry>Fichier régulier</entry>
	      </row>
	      <row>
		<entry>l</entry><entry>Lien symbolique</entry>
	      </row>
	      <row>
		<entry>p</entry><entry>FIFO</entry>
	      </row>
	      <row>
		<entry>s</entry><entry>Socket</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Donc, par exemple, si vous voulez trouver les répertoires, vous pouvez
	  utiliser le paramètre <emphasis>d</emphasis> pour l'opérande
	  <emphasis>-type</emphasis> :
	</para>

	<screen>
$ <userinput>find . -type d</userinput>
.
./economic
./technical
	</screen>

	<para>
	  Nous allons voir comment faire une expression complexe à la fin de
	  cette section pour <command>find</command>, mais à ce point il est
	  utile de savoir que vous pouvez faire des expressions booléenes 'et'
	  en spécifiant plusieurs opérandes. Par exemple <emphasis>operand1
	  operand2</emphasis> est vrai si à la fois
	  <emphasis>operand1</emphasis> et
	  <emphasis>operand2</emphasis> sont vraisare true pour l'objet en cours
	  d'évaluation. Donc, vous pouvez combiner les opérandes
	  <emphasis>-name</emphasis> et <emphasis>-type</emphasis>
	  pour rechercher tous les répertoires qui commencent par 
	  <emphasis>eco</emphasis> :
	</para>

	<screen>
$ <userinput>find . -name 'eco*' -type d</userinput>
./economic
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-perms">
	<title>Les operandes qui limitent par propriétaire d'objet ou par permissions</title>

	<para>
	  En plus de chercher les objets par nom ou type, vous pouvez aussi
	  chercher par leur permissions ou par propriétaire d'objet.
	  Il est souvent utile de rechercher des fichiers avec des permissions
	  ou propriétaires incorrects.
	</para>

> The name of a user or group will be interpreted as a user ID or group
> ID if the name is decimal, and could not be found on the system with  
 	<para>
	  Le propriétaire (user) ou groupe d'un objet peut être repéré avec
	  respectivement les variantes <emphasis>-user username</emphasis> et
	  <emphasis>-group groupname</emphasis>. Le nom d'un utilisateur ou d'un
	  groupe sera interprété comme un ID utilisateur ou ID de groupe
	  si le nom est décimal, et s'il n'a pu être trouvé sur le système avec
	  <citerefentry><refentrytitle>getpwnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>
	  ou
	  <citerefentry><refentrytitle>getgrnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>. Donc
	  si vous voulez chercher tous les objets dont <emphasis>joe</emphasis>
	  est le propriétaire, vous pouvez utiliser l'opérande 
	  <emphasis>-user joe</emphasis> :
	</para>

	<screen>
$ <userinput>find . -user joe</userinput>
./secret/report.txt
	</screen>

	<para>
	  Ou pour trouver tous les objets avec le
	  groupe <emphasis>friend</emphasis> en tant que groupe de fichier :
	</para>

	<screen>
$ <userinput>find . -group friends</userinput>
./secret/report.txt
	</screen>

	<para>
	  L'opérande pour vérifier les permissions du fichier
	  <emphasis>-perm</emphasis> est moins évident. Comme la commande
	  <command>chmod</command> cet opérateur peut travailler avec les
	  notations octale et symbolique. Nous allons commencer par la
	  notation octale. Si un nombre octal est spécifié en paramètre de
	  l'opérande <emphasis>-perm</emphasis>, cela va trouver tous les objets
	  ayant exactement ces permissions. Par exemple, <emphasis>-perm
	  0600</emphasis> va trouver tous les objets en lecture et écriture
	  seulement pour l'utilisateur, sans autre flag positionné :
	</para>

	<screen>
$ <userinput>find . -perm 0600</userinput>
./secret/report.txt
	</screen>

	<para>
	  Si un tiret est ajouté en préfixe d'un nombre, cela correspond à tout
	  objet ayant au moins les bits positionnés spéfifiés dans le nombre
	  octal. Un exemple utile est de rechercher tous les fichiers qui ont au
	  moins les permissions d'écritures pour les utilisateurs
	  <emphasis>autre</emphasis> (other) avec <emphasis>-perm
	  -0002</emphasis>. Cela peut vous aider à rechercher les point d'accès
	  de périphériques ou autres objets avec des permissions non sûres.
	</para>

	<screen>
$ <userinput>find /dev -perm -0002</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>

	<note>
	  <para>
	    Certains points d'accès de périphériques doivent être en écriture
	    pour tout le monde pour qu'un système UNIX fonctionne
	    correctement. Par exemple le
	    périphérique <filename>/dev/null</filename> est toujours en
	    écriture.
	  </para>
	</note>

	<para>
	  La notation symbolique des paramètres <emphasis>-perm</emphasis>
	  utilise la même notation que la commande <command>chmod</command>. Les
	  permissions symboliques sont contruite avec un mode de fichier où tous
	  les bits sont effacés, donc il n'est jamais nécessaire d'utiliser le
	  tiret pour supprimer les droits. Cela lève aussi toute ambiguité qu'il
	  pourrait y avoir avec le préfixe tiret. Comme la syntaxe en octal,
	  prefixer les permissions avec un tiret cherchera les objets qui ont au
	  moins les bits de permissions spécifiés. L'utilisation des noms
	  symboliques est assez déterministe - les 2 commandes suivantes
	  répètent les exemples précédents avec les permissions symboliques :
	</para>

	<screen>
$ <userinput>find . -perm u+rw</userinput>
./secret/report.txt
	</screen>

	<screen>
$ <userinput>find /dev -perm -o+w</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-time">
	<title>Opérandes qui filtrent par date de creation d'object</title>

	<para>
	  Il y a 3 opérandes qui fonctionnent sur des intervalles de temps.
	  La syntax de l'opérande est <emphasis>operand n</emphasis>,
	  où <emphasis>n</emphasis> est le temps en jours. Tous les 3 operateurs
	  calculent un delta de temps en secondes divisé par le nombre de
	  secondes dans un jour (86400), supprimant le reste de la
	  division. Donc, si le delta est un jour,
	  <emphasis>operand 1</emphasis> va chercher l'objet. Les 3 opérandes
	  sont :
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>-atime n</emphasis> - cet opérande vaut vrai si la date
	      de début d'exécution de <command>find</command> moins la date du
	      dernier accès à l'objet est égale à <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-ctime n</emphasis> - cet opérande vaut vrai si la date
	      de début d'exécution de <command>find</command> moins la date du
	      dernier changement de statut de l'objet est égale à
	      <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-mtime n</emphasis> -  cet opérande vaut vrai si la date
	      de début d'exécution de <command>find</command> moins la date de
	      dernière modification de l'objet est égale
	      à <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Donc, ces opérandent cherchent si le dernier accès, changement,
	  modification respectivement a été fait il y a <emphasis>n</emphasis>
	  jours. Pour donner un exemple, la commande suivante montre tous les
	  objets dans <filename>/etc</filename> qui ont été modifiés il y a 1
	  jour :
	</para>

	<screen>
$ <userinput>find /etc -mtime 1</userinput>
/etc
/etc/group
/etc/master.passwd
/etc/spwd.db
/etc/passwd
/etc/pwd.db
	</screen>

	<para>
	  Le signe plus ou moins peut être utilisé pour modifier sa
	  signification de <emphasis>n</emphasis>. <emphasis>+n</emphasis>
	  signifie de plus de <emphasis>n</emphasis>
	  jours, <emphasis>-n</emphasis> signifie de moins
	  de <emphasis>n</emphasis> jours. Donc, pour trouver tous les fichiers
	  dans <filename>/etc</filename> qui ont été modifiés depuis moins de 2
	  jours, vous pouvez exécuter :
	</para>

	<screen>
$ <userinput>find /etc -mtime -2</userinput>
/etc
/etc/network/run
/etc/network/run/ifstate
/etc/resolv.conf
/etc/default
/etc/default/locale
[...]
	</screen>

	<para>
	  Un autre opérande utile basé sur le temps est
	  l'opérande <emphasis>-newer reffile</emphasis>. Il cherche tous les
	  fichiers qui ont été modifiés plus tard que le fichier dont le nom est
	  <filename>reffile</filename>. L'exemple suivant montre comment
	  utiliser cela pour lister tous les fichiers qui ont une date de
	  modification supérieure que celle
	  de <filename>economic/report2.txt</filename> :
	</para>

	<screen>
$ <userinput>find . -newer economic/report2.txt</userinput>
.
./technical
./technical/report2.txt
./technical/report.txt
./secret
./secret/report.txt
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-depth">
	<title>Opérandes qui influent sur le parcours de l'arborescence</title>

	<para>
	  Certains opérandes influent sur la façon dont la commande
	  <command>find</command> parcours l'arborescence. Le premier de ces
	  opérandes est
	  l'opérande <emphasis>-xdev</emphasis>. <emphasis>-xdev</emphasis>
	  empêche <command>find</command> d'explorer les répertoires qui ont un
	  ID de périphérique, empêchant dans les fait l'exploration d'autres
	  systèmes de fichiers. Le répertoire dans lequel le système de fichiers
	  est monté, est affiché, car cet opérande retourne
	  toujours <emphasis>vrai</emphasis>. Un bon exemple est un système où
	  <filename>/usr</filename> est monté sur un système de fichiers
	  différent de <filename>/</filename>. Par conséquent, si nous cherchons
	  les répertoires dont le nom est <emphasis>bin</emphasis>, cela doit
	  conduire au résultat suivant :
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d</userinput>
/usr/bin
/bin
	</screen>

	<para>
	  Mais si nous ajoutons <emphasis>-xdev</emphasis>
	  <filename>/usr/bin</filename> n'est pas trouvé, car il est sur un
	  système de fichiers différent (et sur un périphérique différent) :
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d -xdev</userinput>
/bin
	</screen>

	<para>
	  L'opérande <emphasis>-depth</emphasis> change l'ordre d'évaluation des
	  répertoires. Avec <emphasis>-depth</emphasis> le contenu d'un
	  répertoire est évalué en premier, et ensuite le répertoire
	  lui-même. Cela peut être vu dans l'exmple suivant :
	</para>

	<screen>
$ <userinput>find . -depth</userinput>
./economic/report.txt
./economic/report2.txt
./economic
./technical/report2.txt
./technical/report.txt
./technical
.
	</screen>

	<para>
	  Comme vous pouvez le voir dans la sortie, les fichiers dans le
	  répertoire <emphasis>./economic</emphasis> sont évalués
	  avant <filename>.</filename>,
	  et  <filename>./economic/report.txt</filename> avant
	  <filename>./economic</filename>. <emphasis>-depth</emphasis>
	  vaut toujours <emphasis>vrai</emphasis>.
	</para>

	<para>
	  Enfin, l'opérande <emphasis>-prune</emphasis> fait que find ne descend
	  pas dans un répertoire en cours d'évaluation.
	  <emphasis>-prune</emphasis> est ignoré si l'opérande
	  <emphasis>-depth</emphasis> est aussi
	  spécifié. <emphasis>-depth</emphasis> est toujours évalué à
	  <emphasis>vrai</emphasis>.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-exec">
	<title>Opérandes exécutant des utilitaires externes</title>

	<para>
	  <command>find</command> devient un outil très puissant dès qu'il est
	  combiné avec des utilitaires externes. Cela peut être fait avec
	  l'opérande <emphasis>-exec</emphasis>. Il y a 2 syntaxes pour
	  l'opérande <emphasis>-exec</emphasis>. La première syntaxe
	  est <emphasis>-exec utilitaire arguments ;</emphasis>. La
	  commande <emphasis>utilitaire</emphasis> sera exécutée avec les
	  arguments qui ont été spécifiés pour chaque objet évalué. Si un
	  quelconque argument est <emphasis>{}</emphasis>, ces accolades seront
	  remplacées par le fichier évalué. Cela est très utile, spécialement
	  quand on considère que, si nous n'utilisons pas d'autre syntaxe
	  d'expression supplémentaire, les operandes seront évalués de gauche à
	  droite. Regardons un exemple :
	  an example:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} \;</userinput>
	</screen>

	<para>
	 Le premier opérande retourne vrai pour les fichiers qui ont pour
	 permissions <emphasis>0666</emphasis>. Le second opérande
	 exécute <emphasis>chmod 0644 filename</emphasis> pour chaque fichier
	 évalué. Si vous vous demandez pourquoi la commande n'est pas exécutée
	 pour chaque fichier, c'est une bonne question. Comme beaucoup
	 d'interpréteurs d'expressions, <command>find</command> utilise
	 le <quote>court-circuit</quote>.
	 Comme aucun autre opérateur n'a été spécifié, l'opérateur logique
	 <emphasis>et</emphasis> est automatiquement appliqué entre les 2
	 opérandes. Si le premier opérande est évalué
	 à <emphasis>faux</emphasis>, il n'y a aucune raison pour évaluer un
	 quelconque autre opérande, cat l'expression complète sera toujours
	 évaluée à faux. Donc, l'opérande <emphasis>-exec</emphasis> ne sera
	 évalué que si le premier opérande est vrai. Une autre particularité est
	 que le point-virgule qui clos le <emphasis>-exec</emphasis> est préfixé
	 par le caractère d'échappementis escaped, pour empêcher le shell de le
	 prendre en compte.
	</para>

	<para>
	  Une chose intéressante sur l'opérateur <emphasis>-exec</emphasis> est
	  qu'il évalue à <emphasis>vrai</emphasis> si la commande se termine
	  avec succès.Donc, vous pouvez aussi utiliser la
	  commande <emphasis>-exec</emphasis> pour ajouter des conditions
	  supplémentaires qui ne sont pas representées par les opérandes
	  de <command>find</command>. Par exemple, la commande suivante affiche
	  tous les objets finissant par <emphasis>.txt</emphasis> qui
	  contiennent la chaîne de caractère <emphasis>gross income</emphasis> :
	</para>

	<screen>
$ <userinput>find . -name '*.txt' -exec grep -q 'gross income' {} \; -print</userinput>
./economic/report2.txt
	</screen>

	<para>
	  La commande <command>grep</command> sera vue plus tard.
	  <!-- XXX - xref --> Mais pour le moment, il est suffisant de savoir
	  qu'elle peut être utilisée pour chercher des motifs de
	  texte. L'opérande <emphasis>-print</emphasis> affiche le chemin
	  courant de l'objet. Il est toujours implicite, sauf quand les
	  opérandes <emphasis>-exec</emphasis> ou <emphasis>-ok</emphasis>
	  sont spécifiés. <!-- XXX - move to introduction? -->
	</para>

	<para>
	  La seconde syntaxe de l'opérande <emphasis>-exec</emphasis>
	  est <emphasis>-exec utilitaire arguments {} +</emphasis>. Cela
	  récupère la liste de tous les objets trouvés pour lesquels
	  l'expression est vraie, et fournit cette liste de fichiers en argument
	  de l'utlitaire spécifié. Le permier exemple de l'opérande
	  <emphasis>-exec</emphasis> peut aussi être écrit :
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} +</userinput>
	</screen>

	<para>
	  Cela va exécuter la commande <command>chmod</command> seulement une
	  seule fois, avec tous les fichiers pour lesquels l'expression est
	  vraie en tant qu'arguments. Cet opérande retourne
	  toujours <emphasis>vrai</emphasis>.
	</para>

	<para>
	  Si une commande exécutée par find retourne une valeur différente de
	  zéro (signifiant que l'exécution de la commande ne s'est pas terminée
	  avec succès), <command>find</command> va retourner également une
	  valeur non nulle.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-operators">
	<title>Opérateurs pour la construction d'expressions complexes</title>

	<para>
	  <command>find</command> fournir quelques opérateurs qui peuvent être
	  combinés pour faire des expressions plus complexes :
	</para>

	<variablelist>
	  <title>Operateurs</title>

	  <varlistentry>
	    <term>( expr )</term>
	    <listitem>
	      <para>
		Est évalué à <emphasis>vrai</emphasis> si
		<emphasis>expr</emphasis> est évalué à
		<emphasis>vrai</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 [-a] expr2</term>
	    <listitem>
	      <para>
		Evalue à <emphasis>vrai</emphasis> si à la fois
		<emphasis>expr1</emphasis> et <emphasis>expr2</emphasis>
		sont vrais. Si <emphasis>-a</emphasis> est omis, cet opérateur
		est considéré implicitement.
	      </para>

	      <para>
		<command>find</command> va utiliser le court-circuit quand cet
		opérateur est évalué : <emphasis>expr2</emphasis>
		ne sera pas évalue quand <emphasis>expr1</emphasis>
		est évalué à <emphasis>faux</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 -o expr2</term>
	    <listitem>
	      <para>
		Evalue à <emphasis>vrai</emphasis> si une des
		deux expressions <emphasis>expr1</emphasis>
		ou <emphasis>expr2</emphasis> est vrai.
	      </para>

	      <para>
		<command>find</command> va utiliser le court-circuit quand cet
		opérateur est évalué : <emphasis>expr2</emphasis>
		ne sera pas évalué si <emphasis>expr1</emphasis>
		vaut <emphasis>vrai</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>! expr</term>
	    <listitem>
	      <para>
		Fait une négation logique de <emphasis>expr</emphasis>. Donc, si
		<emphasis>expr</emphasis> est évalué à vrai, cette expression
		sera évaluée à <emphasis>faux</emphasis> et vice-versa.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>
	  Puisque les 2 parenthèses et le point d'exclamation sont interprétés
	  par la plupart des shells, il doivent être préfixés par le caractère
	  d'échappement.
	</para>

	<para>
	  L'exemple suivant montre quelques opérateurs en action. Cette commande
	  exécute <command>chmod</command> pour tous les fichiers qui ont soit
	  leur permissions à <emphasis>0666</emphasis> ou
	  bien <emphasis>0664</emphasis>.
	</para>

	<screen>
$ <userinput>find . \( -perm 0666 -o -perm 0664 \) -exec chmod 0644 {} \;</userinput>
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-which">
      <title>which</title>

      <para>
	La commande <command>which</command> ne fait pas partie de la Single
	UNIX Specification version 3, mais est disponible sur la plupart des
	systèmes. <command>which</command> trouve une commande dans le chemin de
	recherche de l'utilisateur (positionné dans la variable d'environnement
	PATH), et affiche son chemin complet. Ajouter le nom d'une commande en
	paramètre affichera le chemin complet :
      </para>

      <screen>
$ <userinput>which ls</userinput>
/bin/ls
      </screen>

      <para>
	Vous pouvez aussi demander le chemin de plusieurs commandes:
      </para>

      <screen>
$ <userinput>which ls cat</userinput>
/bin/ls
/bin/cat
      </screen>

      <para>
        <command>which</command> retournes une valeur non nulle si la commande
	est introuvable.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-whereis">
      <title>whereis</title>

      <para>
	La commande <command>whereis</command> recherche des binaires, des pages
	de manuel et les fichiers source d'une commande à certains endroits
	pré-définis. Par exemple, la commande suivante affiche le chemin
	de <command>ls</command> et la page de manuel
	<citerefentry><refentrytitle>ls</refentrytitle><manvolnum>1</manvolnum></citerefentry> :
      </para>

      <screen>
$ <userinput>whereis ls</userinput>
ls: /bin/ls /usr/share/man/man1/ls.1.gz
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-locate">
      <title>locate</title>

      <para>
        Slackware Linux offre aussi la commande
	<command>locate</command> qui recherche à travers une base de données de
	fichiers qui peut être générée périodiquement avec la commande
	<command>updatedb</command>. Puisqu'elle utilise une base de donnée
	pré-construite du système de fichier, elle est bien plus rapide que
	<command>which</command>, précisément quand l'information de l'entrée de
	répertoire n'a pas encore été mis en cache. Cependant, la combinaison
	<command>locate</command>/<command>updatedb</command> a quelques
	désavantages :
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Les nouveaux fichiers ne sont pas dans la base de données avant la
	    prochaine invocation de <command>updatedb</command>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <command>locate</command> n'a pas de concept de permissions, donc
	    les utilisateurs peuvent localiser des fichier qui leur sont
	    normalement cachés.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Une nouvelle implémentation, nommée <emphasis>slocate</emphasis>
	    prend en compte les permissions, mais requiert des privilèges
	    élevés. C'est cette variante de <command>locate</command> qui est
	    inclue dans with Slackware Linux.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	With filesystems becoming faster, and by applying common sense
	when formulating <command>find</command> queries,
	<command>locate</command> does not really seem worth the
	hassle. Of course, your mileage may vary. That said, the basic
	usage of <command>locate</command> is <emphasis>locate
	filename</emphasis>. For example:
      </para>

      <screen>
$ <userinput>locate locate</userinput>
/usr/bin/locate
/usr/lib/locate
/usr/lib/locate/bigram
/usr/lib/locate/code
/usr/lib/locate/frcode
[...]
      </screen>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-archives">
    <title>Archives</title>

    <sect2 xml:id="basics-filesystem-archives-introduction">
      <title>Introduction</title>

      <para>
	Sooner or later a GNU/Linux user will encounter
	<acronym>tar</acronym> archives, tar is the standard format
	for archiving files on GNU/Linux.  It is often used in
	conjunction with <command>gzip</command> or
	<command>bzip2</command>. Both commands can compress files and
	archives.  <xref linkend="archive-extentions" /> lists
	frequently used archive extensions, and what they mean.
      </para>

      <table xml:id="archive-extentions">
	<title>Archive file extensions</title>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Extension</entry>
	      <entry>Meaning</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>.tar</entry>
	      <entry>An uncompressed tar archive</entry>
	    </row>
	    <row>
	      <entry>.tar.gz</entry>
	      <entry>A tar archive compressed with gzip</entry>
	    </row>
	    <row>
	      <entry>.tgz</entry>
	      <entry>A tar archive compressed with gzip</entry>
	    </row>
	    <row>
	      <entry>.tar.bz2</entry>
	      <entry>A tar archive compressed with bzip2</entry>
	    </row>
	    <row>
	      <entry>.tbz</entry>
	      <entry>A tar archive compressed with bzip2</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	The difference between <command>bzip2</command> and
	<command>gzip</command> is that <command>bzip2</command> can
	find repeating information in larger blocks, resulting in
	better compression. But <command>bzip2</command> is also a lot
	slower, because it does more data analysis.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-extracting">
      <title>Extracting archives</title>

      <para>
	Since many software and data in the GNU/Linux world is
	archived with <command>tar</command> it is important to get
	used to extracting tar archives. The first thing you will
	often want to do when you receive a tar archive is to list its
	contents. This can be achieved by using the <parameter
	class="command">t</parameter> parameter. However, if we just
	execute <command>tar</command> with this parameter and the
	name of the archive it will just sit and wait until you enter
	something to the standard input:
      </para>

      <screen>
$ <userinput>tar t test.tar</userinput>
      </screen>

      <para>
	This happens because <command>tar</command> reads data from
	its standard input. If you forgot how redirection works, it is
	a good idea to reread <xref linkend="chap-shell-inout" />. Let's
	see what happens if we redirect our tar archive to tar:
      </para>

      <screen>
$ <userinput>tar t &lt; test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	That looks more like the output you probably expected. This
	archive seems to contain a directory
	<filename>test</filename>, which contains the files
	<filename>test2</filename> and <filename>test2</filename>.  It
	is also possible to specify the archive file name as an
	parameter to <command>tar</command>, by using the <parameter
	class="command">f</parameter> parameter:
      </para>

      <screen>
$ <userinput>tar tf test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	This looks like an archive that contains useful files ;). We
	can now go ahead, and extract this archive by using the
	<parameter class="command">x</parameter> parameter:
      </para>

      <screen>
$ <userinput>tar xf test.tar</userinput>
      </screen>

      <para>
	We can now verify that tar really extracted the archive by
	listing the contents of the directory with
	<command>ls</command>:
      </para>

      <screen>
$ <userinput>ls test/</userinput>
test1  test2
      </screen>

      <para>
	Extracting or listing files from a gzipped or bzipped archive
	is not much more difficult. This can be done by adding a
	<parameter class="command">z</parameter> or <parameter
	class="command">j</parameter> for respectively archives
	compressed with <command>gzip</command> or
	<command>bzip2</command>.  For example, we can list the
	contents of a gzipped archive with:
      </para>

      <screen>
$ <userinput>tar ztf archive2.tar.gz</userinput>
      </screen>

      <para>
	And a bzipped archive can be extracted with:
      </para>

      <screen>
$ <userinput>tar jxf archive3.tar.bz2</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-creating">
      <title>Creating archives</title>

      <para>
	You can create archives with the <parameter
	class="command">c</parameter> parameter. Suppose that we have
	the directory <filename>test</filename> shown in the previous
	example. We can make an archive with the
	<filename>test</filename> directory and the files in this
	directory with:
      </para>

      <screen>
$ <userinput>tar cf important-files.tar test</userinput>
      </screen>

      <para>
	This will create the <filename>important-files.tar</filename>
	archive (which is specified with the <parameter
	class="command">f</parameter> parameter). We can now verify
	the archive:
      </para>

      <screen>
$ <userinput>tar tf important-files.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Creating a gzipped or bzipped archive goes along the same
	lines as extracting compressed archives: add a <parameter
	class="command">z</parameter> for gzipping an archive, or
	<parameter class="command">b</parameter> for bzipping an
	archive. Suppose that we wanted to create a
	<command>gzip</command> compressed version of the archive
	created above. We can do this with:
      </para>

      <screen>
<userinput>tar zcf important-files.tar.gz test</userinput>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-mounting">
    <title>Mounting filesystems</title>

    <sect2 xml:id="basics-filesystem-mounting-introduction">
      <title>Introduction</title>

      <para>
	Like most Unices Linux uses a technique named
	<quote>mounting</quote> to access filesystems. Mounting means
	that a filesystem is connected to a directory in the root
	filesystem. One could for example mount a CD-ROM drive to the
	<filename>/mnt/cdrom</filename> directory. Linux supports many
	kinds of filesystems, like Ext2, Ext3, ReiserFS, JFS, XFS,
	ISO9660 (used for CD-ROMs), UDF (used on some DVDs) and
	DOS/Windows filesystems, like FAT, FAT32 and NTFS. These
	filesystems can reside on many kinds of media, for example
	hard drives, CD-ROMs and Flash drives. This section explains
	how filesystems can be mounted and unmounted.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-mount">
      <title>mount</title>

      <para>
	The <command>mount</command> is used to mount filesystems. The
	basic syntax is: <quote>mount /dev/devname
	/mountpoint</quote>. The device name can be any block device,
	like hard disks or CD-ROM drives. The mount point can be an
	arbitrary point in the root filesystem. Let's look at an
	example:
      </para>

      <screen>
# <userinput>mount /dev/cdrom /mnt/cdrom</userinput>
      </screen>

      <para>
	This mounts the <filename>/dev/cdrom</filename> on the
	<filename>/mnt/cdrom</filename> mountpoint. The
	<filename>/dev/cdrom</filename> device name is normally a link
	to the real CD-ROM device name (for example,
	<filename>/dev/hdc</filename>). As you can see, the concept is
	actually very simple, it just takes some time to learn the
	device names ;). Sometimes it is necessary to specify which
	kind of filesystem you are trying to mount.  The filesystem
	type can be specified by adding the <parameter
	class="command">-t</parameter> parameter:
      </para>

      <screen>
# <userinput>mount -t vfat /dev/sda1 /mnt/flash</userinput>
      </screen>

      <para>
	This mounts the vfat filesystem on
	<filename>/dev/sda1</filename> to
	<filename>/mnt/flash</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-umount">
      <title>umount</title>

      <para>
	The <command>umount</command> command is used to unmount
	filesystems.  <command>umount</command> accepts two kinds of
	parameters, mount points or devices. For example:
      </para>

      <screen>
# <userinput>umount /mnt/cdrom</userinput>
# <userinput>umount /dev/sda1</userinput>
      </screen>

      <para>
	The first command unmounts the filesystem that was mounted on
	<filename>/mnt/cdrom</filename>, the second commands unmounts
	the filesystem on <filename>/dev/sda1</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-fstab">
      <title>The fstab file</title>

      <para>
	The GNU/Linux system has a special file,
	<filename>/etc/fstab</filename>, that specifies which
	filesystems should be mounted during the system boot.  Let's
	look at an example:
      </para>

      <screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
      </screen>

      <para>
	As you can see each entry in the <filename>fstab</filename>
	file has five entries: fs_spec, fs_file, fs_vfstype,
	fs_mntops, fs_freq, and fs_passno.  We are now going to look
	at each entry.
      </para>

      <sect3>
	<title>fs_spec</title>

	<para>
	  The fs_spec option specifies the block device, or remote
	  filesystem that should be mounted. As you can see in the
	  example several /dev/hda partitions are specified, as well
	  as the CD-ROM drive and floppy drive. When NFS volumes are
	  mounted an IP address and directory can be specified, for
	  example: <filename>192.168.1.10:/exports/data</filename>.
	</para>
      </sect3>

      <sect3>
	<title>fs_file</title>

	<para>
	  fs_file specifies the mount point. This can be an arbitrary
	  directory in the filesystem.
	</para>
      </sect3>

      <sect3>
	<title>fs_vfstype</title>

	<para>
	  This option specifies what kind of filesystem the entry
	  represents. For example this can be: ext2, ext3, reiserfs,
	  xfs, nfs, vfat, or ntfs.
	</para>
      </sect3>

      <sect3>
	<title>fs_mntops</title>

	<para>
	  The fs_mntops option specifies which parameters should be
	  used for mounting the filesystem. The
	  <command>mount</command> manual page has an extensive
	  description of the available options. These are the most
	  interesting options:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>noauto</emphasis>: filesystems that are listed
	      in <filename>/etc/fstab</filename> are normally mounted
	      automatically. When the <quote>noauto</quote> option is
	      specified, the filesystem will not be mounted during the
	      system boot, but only after issuing a
	      <command>mount</command> command. When mounting such
	      filesystem, only the mount point or device name has to
	      be specified, for example: <command>mount
	      /mnt/cdrom</command>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>user</emphasis>: adding the
	      <quote>user</quote> option will allow normal users to
	      mount the filesystem (normally only the superuser is
	      allowed to mount filesystems).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>owner</emphasis>: the <quote>owner</quote>
	      option will allow the owner of the specified device to
	      mount the specified device. You can see the owner of a
	      device using <command>ls</command>, e.g.  <command>ls -l
	      /dev/cdrom</command>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>noexec</emphasis>: with this option enabled
	      users can not run files from the mounted
	      filesystem. This can be used to provide more security.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>nosuid</emphasis>: this option is comparable
	      to the <quote>noexec</quote> option. With
	      <quote>nosuid</quote> enabled SUID bits on files on the
	      filesystem will not be allowed. SUID is used for certain
	      binaries to provide a normal user to do something
	      privileged.  This is certainly a security threat, so
	      this option should really be used for removable media,
	      etc. A normal user mount will force the nosuid option,
	      but a mount by the superuser will not!
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>unhide</emphasis>: this option is only
	      relevant for normal CD-ROMs with the ISO9660
	      filesystem. If <quote>unhide</quote> is specified hidden
	      files will also be visible.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>fs_freq</title>

	<para>
	  If the <quote>fs_freq</quote> is set to 1 or higher, it
	  specifies after how many days a filesystem dump (backup) has
	  to be made. This option is only used when <ulink
	  url="http://dump.sourceforge.net/">dump</ulink> is
	  installed, and set up correctly to handle this.
	</para>
      </sect3>

      <sect3>
	<title>fs_passno</title>

	<para>
	  This field is used by <command>fsck</command> to determine
	  the order in which filesystems are checked during the system
	  boot.
	</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="basics-filesystem-gnupg">
    <title>Encrypting and signing files</title>

    <sect2>
      <title>Introduction</title>

      <para>
	There are two security mechanisms for securing files: signing
	files and encrypting files. Signing a file means that a
	special digital signature is generated for a file. You, or
	other persons can use the signature to verify the integrity of
	the file. File encryption encodes a file in a way that only a
	person for which the file was intended to read can read the
	file.
      </para>

      <para>
	This system relies on two keys: the private and the public
	key. Public keys are used to encrypt files, and files can only
	be decrypted with the private key. This means that one can
	sent his public key out to other persons. Others can use this
	key to send encrypted files, that only the person with the
	private key can decode. Of course, this means that the
	security of this system depends on how well the private is
	kept secret.
      </para>

      <para>
	Slackware Linux provides an excellent tool for signing and
	encrypting files, named GnuPG. GnuPG can be installed from the
	<quote>n</quote> disk set.
      </para>
    </sect2>

    <sect2>
      <title>Generating your private and public keys</title>

      <para>
	Generating public and private keys is a bit complicated,
	because GnuPG uses DSA keys by default. DSA is an encryption
	algorithm, the problem is that the maximum key length of DSA
	is 1024 bits, this is considered too short for the longer
	term. That is why it is a good idea to use 2048 bit RSA
	keys. This section describers how this can be done.
      </para>

      <note>
	<para>
	  1024-bit keys were believed to be secure for a long
	  time. But Bernstein's paper <emphasis>Circuits for Integer
	  Factorization: a Proposal</emphasis> contests this, the
	  bottom line is that it is quite feasible for national
	  security agencies to produce hardware that can break keys in
	  a relatively short amount of time.  Besides that it has be
	  shown that 512-bit RSA keys can be broken in a relatively
	  short time using common hardware. More information about
	  these issues can by found in this e-mail to the cypherpunks
	  list:
	<ulink url="http://lists.saigon.com/vault/security/encryption/rsa1024.html" />
	</para>
      </note>

      <para>
	We can generate a key by executing:
      </para>

      <screen>
$ <userinput>gpg --gen-key</userinput>
      </screen>

      <para>
	The first question is what kind of key you would like to
	make. We will choose <emphasis>(4) RSA (sign only)</emphasis>:
      </para>

      <screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <userinput>4</userinput>
      </screen>

      <para>
	You will then be asked what the size of the key you want to
	generate has to be. Type in <emphasis>2048</emphasis> to
	generate a 2048 bit key, and press enter to continue.
      </para>

      <screen>
What keysize do you want? (1024) <userinput>2048</userinput>
      </screen>

      <para>
	The next question is simple to answer, just choose what you
	like. Generally speaking it is not a bad idea to let the key
	be valid infinitely. You can always deactivate the key with a
	special revocation certificate.
      </para>

      <screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	GnuPG will then ask for confirmation. After confirming your
	name and e-mail address will be requested. GnuPG will also ask
	for a comment, you can leave this blank, or you could fill in
	something like <quote>Work</quote> or <quote>Private</quote>,
	to indicate what the key is used for. For example:
      </para>

      <screen>
Real name: <userinput>John Doe</userinput>
Email address: <userinput>john@doe.com</userinput>
Comment: <userinput>Work</userinput>              
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	GnuPG will the ask you to confirm your user ID. After
	confirming it GnuPG will ask you to enter a password. Be sure
	to use a good password:
      </para>

      <screen>
You need a Passphrase to protect your secret key.    

Enter passphrase:
      </screen>

      <para>
	After entering the password twice GnuPG will generate the
	keys. But we are not done yet. GnuPG has only generated a key
	for signing information, not for encryption of information. To
	continue, have a look at the output, and look for the key
	ID. In the information about the key you will see
	<emphasis>pub 2048R/</emphasis>. The key ID is printed after
	this fragment.  In this example:
      </para>

      <screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
      </screen>

      <para>
	the key ID is <emphasis>8D080768</emphasis>. If you lost the
	output of the key generation you can still find the key ID in
	the output of the <command>gpg --list-keys</command>
	command. Use the key ID to tell GnuPG that you want to edit
	your key:
      </para>

      <screen>
$ <userinput>gpg --edit-key &lt;Key ID&gt;</userinput>
      </screen>

      <para>
	With the example key above the command would be:
      </para>

      <screen>
$ <userinput>gpg --edit-key 8D080768</userinput>
      </screen>

      <para>
	GnuPG will now display a command prompt. Execute the
	<command>addkey</command> command on this command prompt:
      </para>

      <screen>
Command&gt; <userinput>addkey</userinput>
      </screen>

      <para>
	GnuPG will now ask the password you used for your key:
      </para>

      <screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	After entering the password GnuPG will ask you what kind of
	key you would like to create. Choose <emphasis>RSA (encrypt
	only)</emphasis>, and fill in the information like you did
	earlier (be sure to use a 2048 bit key).  For example:
      </para>

      <screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <userinput>5</userinput>
What keysize do you want? (1024) <userinput>2048</userinput>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	And confirm that the information is correct. After the key is
	generated you can leave the GnuPG command prompt, and save the
	new key with the <command>save</command> command:
      </para>

      <screen>
Command&gt; <userinput>save</userinput>
      </screen>

      <para>
	Congratulations! You have now generated the necessary keys to
	encrypt and decrypt e-mails and files. You can now configure
	your e-mail client to use GnuPG. It is a good idea to store
	the contents of the <filename>.gnupg</filename> directory on
	some reliable medium, and store that in a safe place! If your
	private key is lost you can't decrypt files and messages that
	were encrypted with your public key. If the private key, and
	your password are stolen, the security of this system is
	completely compromised.
      </para>
    </sect2>

    <sect2>
      <title>Exporting your public key</title>

      <para>
	To make GnuPG useful, you have to give your public key to
	people who send you files or e-mails. They can use your public
	key to encrypt files, or use it to verify whether a file has a
	correct signature or not. The key can be exported using the
	<parameter class="command">--export</parameter> parameter. It
	is also a good idea to specify the <parameter
	class="command">--output</parameter> parameter, this will save
	the key in a file. The following command would save the public
	key of <emphasis>John Doe</emphasis>, used in earlier
	examples, to the file <filename>key.gpg</filename>:
      </para>

      <screen>
$ <userinput>gpg --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	This saves the key in binary format. Often it is more
	convenient to use the so-called <quote>ASCII armored
	output</quote>, which fits better for adding the key to
	e-mails, or websites. You export an ASCII armored version of
	the key by adding the <parameter
	class="command">--armor</parameter> parameter:
      </para>

      <screen>
$ <userinput>gpg --armor --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	If you look at the <filename>key.gpg</filename> file you will
	notice that the ASCII armored key is a much more comfortable
	format.
      </para>
    </sect2>

    <sect2>
      <title>Signatures</title>

      <para>
	With GPG you can make a signature for a file. This signature
	is unique, because your signature can only be made with your
	private key. This means that other people can check whether
	the file was really sent by you, and whether it was in any way
	altered or not. Files can be signed with the <parameter
	class="command">--detach-sign</parameter> parameter. Let us
	look at an example. This command will make a signature for the
	<filename>memo.txt</filename> file. The signature will be
	stored in <filename>memo.txt.sig</filename>.
      </para>

      <screen>
$ <userinput>gpg --output memo.txt.sig --detach-sign memo.txt</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	As you can see, GnuPG will ask you to enter the password for
	your private key. After you have entered the right key the
	signature file (<filename>memo.txt.sig</filename>) will be
	created.
      </para>

      <para>
	You can verify a file with its signature using the <parameter
	class="command">--verify</parameter> parameter. Specify the
	signature file as a parameter to the <parameter
	class="command">--verify</parameter> parameter. The file that
	needs to be verified can be specified as the final parameter:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	This will confirm that the file was indeed signed by
	<emphasis>John Doe (Work) &lt;john@doe.com&gt;</emphasis>,
	with the key <emphasis>8D080768</emphasis>, and that the file
	is unchanged. Suppose the file was changed, GnuPG would have
	complained about it loudly:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>
    </sect2>

    <sect2>
      <title>Encryption</title>

      <para>
	One of the main features of GnuPG is encryption. Due to its
	use of asymmetric cryptography, the person who encrypts a file
	and the person who decrypts a file do not need to share a
	key. You can encrypt a file with the public key of another
	person, and that other person can decrypt it with his or her
	private key. You can encrypt files with the <parameter
	class="command">--encrypt</parameter>. If you do not specify a
	user ID for which the file should be encrypted, GnuPG will
	prompt for the user ID. You can specify the user ID with the
	<parameter class="command">-r</parameter> parameter. In the
	following example, the file <filename>secret.txt</filename>
	will be encrypted for another person named <emphasis>John
	Doe</emphasis>:
      </para>

      <screen>
$ <userinput>gpg --encrypt -r "John Doe" secret.txt</userinput>
      </screen>

      <para>
	The user ID is quoted with double quotes for making sure that
	the ID is interpreted as a single program argument. After the
	encryption is completed, the encrypted version of the file
	will be available as <filename>secret.txt.gpg</filename>.
      </para>

      <para>
	The user who receives the file can decrypt it with the
	<parameter class="command">--decrypt</parameter> parameter of
	the <command>gpg</command> command:
      </para>

      <screen>
$ <userinput>gpg --output secret.txt --decrypt secret.txt.gpg</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16 (main key ID EC3ED1AB)

Enter passphrase:

gpg: encrypted with 2048-bit RSA key, ID 8D080768, created 2004-07-16
      "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	In this example the <parameter
	class="command">--output</parameter> parameter is used store
	the decrypted content in <filename>secret.txt</filename>.
      </para>
    </sect2>
  </sect1>
</chapter>
