<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="en"
  xml:id="chap-textproc">
  <title>Traitement de texte</title>

  <para>
    L'édition de texte est un des domaines où UNIX excelle, car cela forme le
    coeur de la philosophie UNIX, comme décrit dans
    <xref linkend="chap-intro-unix" />. La plupart des commandes UNIX sont de
    simples programmes qui lisent des données de l'entrée standard, effectuent
    des opérations sur les données, et envoient les résultats vers la sortie
    standard du programme. Ces programmes agissent essentiellement comme des
    filtres, qui peuvent être connectés en pipeline. Cela permet à l'utilisateur
    de mettre en oeuvre les outils UNIX dans des situations que l'auteur n'a
    jamais envisagé. Dans les chapitres suivants nous allons voir comment
    fabriquer des filtes simples nous-même. <!-- XXX - xref -->
  </para>

  <para>
    This chapter describes some simple, but important, UNIX commands
    that can be used to manipulate text. After that, we will dive into
    regular expressions, a sublanguage that can be used to match text
    patterns.
  </para>
 
  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulation de texte simple</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Répeter ce qui est dit</title>

      <para>
	La filtre texte le plus simple est <command>cat</command>, il ne fait
	rien d'autre qu'envoyer les données depuis stdin vers stdout :
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
	Une autre fonctionnalité utile est de lui faire envoyer le contenu d'un
	fichier vers la sortie standard :
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
	<command>cat</command> (Ndt: cat=concatène) porte bien son nom lorsque
	plusieurs fichiers sont ajoutés en arguments. Cela va concaténer les
	fichiers ; autrement dit, il va envoyer le contenu de tous les fichiers
	vers la sortie standard, dans le même ordre où ils ont été spécifiés en
	argument. La capture d'écran suivante montre cela :
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Statistiques de texte</title>

      <para>
	La commande <command>wc</command> fournit des statistiques sur un
	fichier texte ou flux texte. Sans paramètre, elle va afficher le nombre
	de lignes, de mots et le nombre d'octects respectivement. Un mot est
	délimité par un caractère d'espacement, ou une sequence de caractères
	d'espacement.
      </para>

      <para>
	L'exemple suivant montre le nombre de lignes, de mots, et d'octets dans
	l'exemple classique <quote>Hello world!</quote> :
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput> 
       1       2      13
      </screen>

      <para>
	Si vous désirez afficher seulement une de ces composantes, vous pouvez
	utiliser un des paramètres <parameter class="command">-l</parameter>
	(lignes), <parameter class="command">-w</parameter> (mots), ou
	<parameter class="command">-c</parameter> (octets).
	Par exemple, ajouter seulement le paramètre
	<parameter class="command">-l</parameter> affichera le nombre de lignes
	dans un fichier :
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command> 
  235882 /usr/share/dict/words
      </screen>

      <para>
	Ou vous pouvez afficher des champs supplémentaires en ajoutant un
	paramètre :
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
	Notez que peu importe l'ordre dans lequel les options sont spécifiées,
	l'ordre d'affichage sera toujours le même (lignes, mots, octets).
      </para>

      <para>
	Puisque <parameter class="command">-c</parameter> affiche le nombre
	d'octets, ce paramètre peut ne pas représenter le nombre de caractères
	que comporte un texte, car le jeu de caractères utilisé peut dépasser la
	taille d'un octet. Pour y remédier, le paramètre <parameter
	class="command">-m</parameter> a été ajouté affichant le nombre de
	caractères dans un texte, indépendant du jeu de caractères.
	<parameter class="command">-c</parameter> et
	<parameter class="command">-m</parameter> se substituent, et ne peuvent
	jamais être utilisés en même temps.
      </para>

      <para>
	Les statistiques que <command>wc</command> fournit sont plus utiles
	qu'il n'y paraît. Par exemple, le paramètre
	<parameter class="command">-l</parameter> est souvent utilisé en tant
	que compteur de la sortie d'une commande. C'est utile, car beaucoup de
	commandes séparent les unités logiques par un caractère de nouvelle
	ligne. Supposez que vous voulez compter le nombre de fichiers dans votre
	répertoire home ayant l'extension <filename>.txt</filename>. Vous pouvez
	réaliser ceci en combinant <command>find</command> pour chercher les
	fichiers concernés et	<command>wc</command> pour compter le nombre
	d'occurrences :
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Manipulation de caractères</title>

      <para>
	La commande <command>tr</command> peut être utilisée pour réaliser des
	opérations communes sur les caractères, comme échanger des caractères,
	supprimer des caractères, et rétrécir des séquences de caractères.
	Suivant l'opération, 1 ou 2 séquences de caractères doivent être
	spécifiées. Ajoutés aux caractères normaux, certaines séquences de
	caractères spéciaux peuvent être utilisées :
      </para>

      <variablelist>
	<varlistentry>
	  <term>\caractère</term>
	  <listitem>
	    <para>
	      Cette notation est utilisée pour spécifier des caractères qui
	      nécessitent un échappement, les plus célèbres sont
	      <emphasis>\n</emphasis> (saut de ligne), <emphasis>\t</emphasis>
	      (tabulation horizontale), et <emphasis>\\</emphasis> (backslash).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>caractère1-caractère2</term>
	  <listitem>
	    <para>
	      Insère implicitement tout caractère de
	      <emphasis>caractère1</emphasis> en
	      <emphasis>caractère2</emphasis>. Cette notation doit être utilisée
	      avec attention, car elle ne donne pas toujours le résultat escompté. Par exemple, la séquence
	      <emphasis>a-d</emphasis> peut signifier
	      <emphasis>abcd</emphasis> pour la locale POSIX (configuration de
	      la langue), mais cela peut ne pas être vrai pour d'autres locales.
	      <!-- XXX - locale footnote -->
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:classe:]</term>
	  <listitem>
	    <para>
	      Trouve une classe prédéfinie de caractères. Toutes les classes
	      possibles sont dans <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*]</term>
	  <listitem>
	    <para>
	      Répète <emphasis>caractère</emphasis> jusqu'à ce que la seconde
	      séquence soit aussi longue que la première séquence de caractères.
	      Cette notation ne peut être employée que dans la seconde séquence.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[caractère*n]</term>
	  <listitem>
	    <para>
	      Répète <emphasis>caractère</emphasis>
	      <emphasis>n</emphasis> fois.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>classes de caractères tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Classe</entry><entry>Signification</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Toute lettre ou tout chiffre.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Lettres.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Espace blanc horizontal (e.g. espaces et tabulations).
	      </entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Caractères de contrôle.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Tout chiffre (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Tout caractère imprimable, sauf espace blanc.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Lettres minuscules.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Tout caractère imprimable, inclus l'espace blanc
		horizontal, mais excepté l'espace blanc vertical.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Caractères de ponctuation.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
	      <entry>Tout espace blanc.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Lettres majuscules.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Chiffres hexadécimaux (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Echanger des caractères</title>

	<para>
	  L'opération par défaut de <command>tr</command> est d'échanger
	  (transformer) des caractères. Cela signifie que le
	  <emphasis>n</emphasis>-ème caractère dans la première séquence est
	  remplacé par le <emphasis>n</emphasis>-ème caractère dans la seconde
	  séquence. Par exemple, vous pouvez remplacer tous les
	  <emphasis>e</emphasis> par des <emphasis>i</emphasis> et les
	  <emphasis>o</emphasis> par des <emphasis>a</emphasis> avec une seule
	  opération <command>tr</command> :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
	  Lorsque la seconde séquence n'est pas aussi longue que la première, le
	  dernier caractère de la seconde séquence est répété. Cependant cela ne
	  s'applique pas nécessairement à d'autres systèmes UNIX. Donc, si vous
	  voulez utiliser <command>tr</command> de façon indépendante du
	  système, définissez explicitement le caractère qui doit être répété.
	  Par exemple :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
	  Une autre particularité est l'utilisation de la syntaxe de répétition
	  au milieu de la séquence. Supposez que la séquence 1 est
	  <emphasis>abcdef</emphasis>, et la séquence 2 est
	  <emphasis>@[-*]!</emphasis>. <command>tr</command> va remplacer
	  <emphasis>a</emphasis> avec <emphasis>@</emphasis>,
	  <emphasis>b</emphasis>, <emphasis>c</emphasis>,
	  <emphasis>d</emphasis>, et <emphasis>e</emphasis> avec
	  <emphasis>-</emphasis>, et <emphasis>f</emphasis> avec
	  <emphasis>!</emphasis>.
	  Cependant d'autres systèmes UNIX remplacent
	  <emphasis>a</emphasis> avec
	  <emphasis>@</emphasis>, et le reste de la séquence de caractères avec
	  <emphasis>-</emphasis>. Donc, une notation plus correcte et explicite
	  serait <emphasis>@[-*4]!</emphasis>,
	  ce qui conduit au même résultat sur presque tous les systèmes UNIX :
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Supprimer des séquences de caractères</title>

	<para>
	  Lorque le paramètre <parameter class="command">-s</parameter>
	  est précisé, <command>tr</command> va supprimer tous les caractères
	  présent dans la seconde séquence. Cela signifie qu'une séquence d'un
	  même caractère va être réduite à 1 caractère. Supprimons le caractère
	  &quot;<emphasis>e</emphasis>&quot; :
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
	  Nous pouvons combiner cela avec la transformation pour montrer un
	  exemple utile de <command>tr</command> en action. Supposez que vous
	  voulez marquer toutes les voyelles avec le signe
	  <emphasis>at</emphasis> (<emphasis>@</emphasis>), ainsi que les
	  voyelles consécutives par un seul signe <emphasis>at</emphasis>.
	  Cela se réalise facilement en pipelinant 2 commandes
	  <command>tr</command> :
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Supprimer des caractères</title>

	<para>
	  Enfin, <command>tr</command> peut être utilisé pour supprimer des
	  caractères. Si le paramètre <parameter class="command">-d</parameter>
	  est précisé, tout caractère de la première séquence est supprimé :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Couper et coller des colonnes de texte</title>

      <para>
	La commande <command>cut</command> est fournie par les systèmes UNIX
	pour <quote>couper</quote> une ou plusieurs colonnes d'un fichier ou
	d'un flux, et l'afficher sur la sortie standard. Il est souvent utilse
	d'extraire de façon sélective des informations dans un texte.
	<command>cut</command> fournit 3 approches pour couper des information
	provenant de fichiers :
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Par octet.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Par caractère, ce qui est différent du découpage par octet sur des
	    systèmes qui utilisent un jeu de caractères plus large que 8 bits.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Par champ, délimité par un caractère.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Dans les 3 approches, vous pouvez spécifier l'élément à choisir par son
	numéro en partant de <emphasis>1</emphasis>. Vous pouvez spécifier un
	intervalle en utilisant le tiret (<emphasis>-</emphasis>). Donc,
	<emphasis>M-N</emphasis> signifie du Mième au N-ième
	élément. Omettre M (<emphasis>-N</emphasis>) sélectionne tous les
	éléments depuis le premier élément jusqu'au N-ième élément. Omettre N
	(<emphasis>M-</emphasis>) sélectionne le M-ième élément jusqu'au dernier
	élément. Des éléments multiples ou intervalles peuvent être combinés en
	les séparant par des virgules (<emphasis>,</emphasis>). Donc, en
	l'occurrence, <emphasis>1,3-</emphasis> selectionne le premier élément
	et du troisième jusqu'au dernier élément.
      </para>

      <para>
	Les données peuvent être coupée par champ avec le paramètre <parameter
	class="command">-f champs</parameter>. Par défaut, la tabulation
	horizontale est utilisée en tant que séparateur. Voyons
	<command>cut</command> en action avec un petit dictionnaire hollandais à
	anglais :
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
	Nous pouvons récupérer tous les mots anglais en sélectionnant le second
	champ :
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
	Plutôt facile. Maintenant faisons la même chose avec un fichier ayant
	comme séparateur de champs le deux-points. Nous pouvons essayer ceci
	facilement en convertissant le dictionnaire avec la commande
	<command>tr</command> que nous avons vu précédamment, en remplaçant les
	tabulations par des deux-points :
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Si nous utilisons la même commande que dans l'exemple précédent, nous
	n'obtenons pas le résultat correct :
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Le délimiteur n'a pas été trouvé, c'est ce qui se produit.
	Si une ligne ne contient pas le délimiteur escompté, le comportement par
	défaut de <command>cut</command> est d'afficher la ligne complète. Vous
	pouvez empêcher cela avec le paramètre <parameter
	class="command">-s</parameter>.
      </para>

      <para>
	Pour utiliser un délimiteur différent de la tabulation horizontale,
	ajoutez le paramètre <parameter class="command">-d
        car_délimiteur</parameter> pour fixer le caractère de délimitation.
	Donc, dans le cas de notre fichier <filename>dictionary-new</filename>,
	nous allons demander à <command>cut</command> d'utiliser le deux-points
	comme délimiteur :
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
	Si un champ spécifié n'existe pas dans une ligne, ce champ particulier
	ne sera pas affiché.
      </para>

      <para>
	<parameter class="command">-b bytes</parameter> et
	<parameter class="command">-c characters</parameter> sélectionnent
	respectivement les octets et les caractères dans le texte. Sur des
	systèmes plus anciens, un caractère était traditionnellement sur un
	octet. Cependant les nouveaux systèmes peuvent fournir des jeux de
	caractères sur plus d'un octet. Donc, si vous voulez être sûr de
	capturer des caractères complets, utilisez le paramètre
	<parameter class="command">-c</parameter>.
	Un exemple d'entraînement pour voir le paramètre <parameter
	class="command">-c</parameter> à l'oeuvre est de chercher le top 10 des
	ensembles de mots ayant les 3 premiers caractères en commun. La plupart
	des systèmes UNIX fournissent une liste de mots séparés par un caractère
	de saut de ligne. Nous pouvons utiliser <command>cut</command> pour
	récupérer les 3 premiers caractères des mots de la liste, ajouter
	<parameter class="command">uniq</parameter> <!-- XXX -
	where? --> pour compter les séquences de 3 caractères égales, et
	utiliser <command>sort</command> pour trier dans l'ordre inverse
	numérique (<command>sort</command> est décrit dans <xref
	linkend="chap-textproc-simple-sort" />). Enfin, nous utiliserons
	<command>head</command> pour obtenir les 10 séquences les plus
	fréquentes :
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
	Ayant conclu avec cette jolie mise en oeuvre de commandes UNIX,	nous
	allons passer à la commande <command>paste</command>
	(NdT : paste=coller), qui combine des fichiers en colonnes en un seul
	flux texte.
      </para>

      <para>
	L'utilisation de <command>paste</command> est très simple, elle va
	combiner tous les fichiers passés en argument, séparé par une
	tabulation.
	Avec la liste des mots anglais et hollandais, nous pouvons générer un
	petit dictionnaire :
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
	Vous pouvez aussi combiner plus de 2 fichiers :
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput> 
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
	Si un des fichiers est plus long, l'ordre des colonnes est conservé, des
	entrées vides sont insérées pour compléter les entrées des fichiers plus
	courts.
      </para>

      <para>
	Vous pouvez utiliser un autre délimiteur en ajoutant le paramètre
	<parameter class="command">-d délimiteur</parameter>. Par exemple, nous
	pouvons fabriquer un dictionnaire avec des deux-points comme
	séparateurs :
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
	Normalement, <command>paste</command> combine les fichiers en colonnes
	différentes. Vous pouvez aussi dire à <command>paste</command>
	d'utiliser les lignes de chaque fichier en tant que colonnes, et placer
	les colonnes de chaque fichier sur une ligne séparée. Cela se fait avec
	le paramètre <parameter	class="command">-s</parameter> :
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Trier un texte</title>

      <para>
	UNIX offre la commande <command>sort</command> pour trier du texte.
	<command>sort</command> peut aussi vérifier si un fichier est trié, et
	fusionner 2 fichiers triés. <command>sort</command> peut trier dans
	l'ordre du dictionnaire ou dans l'ordre numérique. L'ordre de tri par
	défaut est l'odre du dictionnaire. Cela signifie que les lignes de texte
	sont comparées caractère par caractère, trié comme spécifié dans la
	séquence de groupage courante (spécifiée via la variable d'environnement
	LC_COLLATE). Cela pose un piège lorsque vous triez des nombre en
	l'occurrence, si vous avez les nombre de 1 à 10 sur une ligne
	différente, la séquence triée sera 1, 10, 2, 3, etc. Cela est dû à
	l'interprétation par caractère du tri par dictionnaire. Si vous voulez
	trier des lignes en tant que nombres, utilisez le tri numérique.
      </para>

      <para>
	Si aucun paramètre n'est spécifié, <command>sort</command> trie les lignes en entrée dans l'ordre du dictionnaire. Par exemple :
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Comme vous pouvez le voir, les entrées sont correctement triées. Parfois
	il peut y avoir 2 lignes identiques. Vous pouvez fusionner les lignes
	identiques en ajoutant le paramètre
	<parameter class="command">-u</parameter>. Les 2 exemples ci-dessous
	illustrent ceci.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Il existe quelques paramètres supplémentaires pouvant être utiles pour
	modifier un peu le résultat :
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Le paramètre <parameter class="command">-f</parameter> permet un tri
	    un tri insensible à la casse.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Si <parameter class="command">-d</parameter> est ajouté, seuls les
	    caractères blancs et les caractères sont utilisés pour déterminer
	    l'ordre de tri.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Le paramètre <parameter class="command">-i</parameter> dit à
	    <command>sort</command> d'ignorer les caractères non imprimables.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
	Vous pouvez trier les fichiers par ordre numérique en ajoutant le
	paramètre <parameter class="command">-n</parameter>. Ce paramètre
	arrète la lecture de la ligne en entrée dès qu'un caractère non
	numérique est rencontré. Les signe moins, point décimal, séparateur de
	milliers, caractère de base numérique (qui distingue une écriture en
	exponentielle d'un nombre standard), et caractères blancs peuvent être
	utilisés en tant que nombre. Ces caractères sont interprétés en
	conséquence.
      </para>

      <para>
	L'exemple suivant montre un tri numérique mis en oeuvre, en pipelinant
	la sortie de <command>du</command> vers	<command>sort</command>. Ca
	marche car <command>du</command> spécifie la taille de chaque fichier
	en premier champ.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
	Dans ce cas, la sortie n'est probablement pas utile si vous voulez lire
	la sortie dans un outil de mise en pages, car les fichiers les plus
	petits sont affichés en premier. C'est là que le paramètre
	<parameter class="command">-r</parameter> devient pratique. Il inverse
	l'ordre de tri.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
	Le paramètre <parameter class="command">-r</parameter> fonctionne aussi
	pour les tris par dictionnaire.
      </para>

      <para>
	Assez souvent, les fichiers sont structurés en plusieurs colonnes, et
	vous voulez trier un fichier par une colonne autre que la première. Par
	exemple, voyons le fichier score suivant nommé
	<filename>score.txt</filename> :
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>
     
    <para>
      Supposons que nous voulons trier les entrées dans ce fichier par les noms
      de pays sur 2 lettres. <command>sort</command> nous permet de trier un
      fichier par une colonne avec le paramètre <parameter
      class="command">-k col1[,col2]</parameter>.  Où <emphasis>col1</emphasis>
      à <emphasis>col2</emphasis> sont utilisés comme champs en entrée soumis au
      tri. Si <emphasis>col2</emphasis> n'est pas spécifié, tous les champs
      jusqu'à la fin de la ligne sont utilisés. Donc si vous ne voulez utiliser
      qu'une seule colonne, utilisez <parameter
      class="command">-k col1,col1</parameter>. Vous pouvez aussi spécifier le
      caractère de départ dans une colonne en ajoutant un point
      (<emphasis>.</emphasis>) et un index de caractère. Par exemple, <parameter
      class="command">-k 2.3,4.2</parameter> signifie la deuxième colonne
      démarrant au troisième caractère, la troisième colonne, et la quatrième
      colonne jusqu'au deuxième caractère inclus.
    </para>

    <!-- XXX - document -b? Mentioned lateron (-k) -->

    <para>
      Il y a encore une autre particularité lors du tri par colonnes : par
      défaut, <command>sort</command> utilise le caractère blanc comme
      séparateur de colonne. Si vous utilisez un caractère de séparation
      différent, vous aurez à utiliser le paramètre
      <parameter>-t char</parameter>, qui est utilisé pour spécifier le
      séparateur de champ.
    </para>

    <para>
      Avec les paramètres <parameter class="command">-t</parameter> et
      <parameter class="command">-k</parameter> combinés, nous pouvons trier le
      fichier de scores par code de pays :
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Donc, comment nous pouvons trier le fichier par score ? Evidemment, nous
      devons demander à sort d'utiliser la troisième colonne. Cependant sort
      utilise un tri par dictionnaire par défaut<footnote><para>Bien sûr, ça n'a
      pas d'importance, car nous n'utilisons pas de nombres supérieurs à 9, et
      pratiquement tous les jeux de caractères ont les nombres dans l'ordre
      numérique.</para></footnote>. Vous pouvez utiliser <parameter
      class="command">-n</parameter>, mais <command>sort</command> permet aussi
      une tournure plus sophistiquée. Vous pouvez ajouter un ou plusieurs
      <emphasis>n</emphasis>, <emphasis>r</emphasis>>,
      <emphasis>f</emphasis>, <emphasis>d</emphasis>,
      <emphasis>i</emphasis>, ou <emphasis>b</emphasis> au spécifieur de
      colonne. Ces lettres représentent les paramètres de
      <command>sort</command> du même nom. Si vous ajoutez seulement la colonne
      de départ, ajoutez-la dans cette colonne, sinon, ajoutez-la à la dernière
      colonne.
    </para>

    <para>
      La commande suivante trie le fichier par score :
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      Il est bon de suivre cette approche, plutôt que d'utiliser les paramètres,
      car <command>sort</command> vous permet d'utiliser plus d'un paramètre
      <parameter class="command">-k</parameter>. Et l'ajout de ces flags aux
      spécifieurs de colonnes vous permettra de trier des colonnes différentes
      de façon différente. Par exemple, utiliser <command>sort</command> avec
      les paramètres <parameter class="command">-k 3,3n -k 2,2</parameter> va
      trier toutes les lignes dans l'ordre numérique sur la troisième colonne.
      Si des lignes on un nombre identique dans la troisième colonne, ces lignes
      peuvent alors être triées par dictionnaire sur la deuxième colonne.
    </para>

    <para>
      Si vous voulez vérifier si un fichier est déjà trié, vous pouvez utiliser
      le paramètre <parameter class="command">-c</parameter>. Si un fichier est
      déja trié, sort retournera la valeur <emphasis>0</emphasis>, sinon
      <emphasis>1</emphasis>. Nous pouvons vérifier ceci en affichant la valeur
      de la variable <emphasis>?</emphasis>, qui contient la valeur de retour de
      la dernière commande exécutée.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      La seconde commande montre qu'effectivement ça fonctionne, en pipelinant
      la sortie du tri de <filename>scores.txt</filename> vers
      <command>sort</command>.
    </para>

    <para>
      Enfin, vous pouver fusionner 2 fichiers triés avec le paramètre <parameter
      class="command">-m</parameter>, en conservant l'ordre de tri correct. Cela
      est plus rapide que de concaténer les fichiers et de les trier ensuite.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Différences entre fichiers</title>

      <para>
	Vu que les flux de texte et les fichiers texte sont très importants en
	UNIX, il est souvent utile de voir les différences entre 2 fichiers
	texte. Les utilitaires principaux pour manipuler les différences entre
	fichiers sont <command>diff</command> et <command>patch</command>.
	<command>diff</command> affiche les différences entre fichiers. La
	sortie de <command>diff</command> (NdT: diff=différence) peut être
	exploitée par <command>patch</command> pour appliquer les modifications
	entre 2 fichiers, à un fichier. <quote>Les différences</quote> sont
	aussi la base des systèmes de gestion de sources/versions.
	<!-- XXX - xref to version management chapters --> La section suivante
	décrit <command>diff</command> and <command>patch</command>.
	Pour avoir un peu de matière sur laquelle travailler, les fichiers
	source C suivants sont utilisés pour démontrer l'utilisation de ces
	commandes. Ces fichiers sont nommés respectivement
	<filename>hello.c</filename> et	<filename>hello2.c</filename>.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Lister les différences entre fichiers</title>

	<para>
	  Supposez que vous avez reçu de la part d'un ami le programme
	  <filename>hello.c</filename>, et que vous l'avez modifié pour fournir
	  à l'utilisateur les date et heure courantes. Vous pourriez simplement
	  envoyer à votre ami le programme modifié. Mais si le fichier grossit,
	  cela peut devenir gênant, car les modifications sont alors difficiles
	  à trouver. De plus, votre ami a pu aussi recevoir des modifications
	  des sources du programme d'autres personnes. C'est une situation
	  typique où <command>diff</command> devient utile.
	  <command>diff</command> affiche les différences entre 2 fichiers. Sa
	  syntaxe la plus simple est <command>diff file
	  file2</command>, qui affiche les différences entre
	  <filename>file</filename> et
	  <filename>file2</filename>. Essayons avec nos fichiers source :
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  Les ajouts de <filename>hello2.c</filename> sont visibles par cette
	  sortie, mais le format peut sembler un peu étrange. En fait, ce sont
	  des commandes qui peuvent être interprétées par l'éditeur de lignes
	  <command>ed</command>. Nous allons voir un format plus agréable après
	  avoir touché du doigt le format de sortie par défaut.
	</para>

	<para>
	  2 éléments différents peuvent être tirés de cette sortie :
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      C'est une commande <application>ed</application> qui spécifie que
	      le texte doit être ajouté
	      (<literal>a</literal>) après la ligne <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      C'est le texte destiné à être ajouté après la deuxième ligne. Le
	      signe <quote><emphasis>&gt;</emphasis></quote> est utilisé pour
	      marquer les lignes ajoutées.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Les mêmes éléments sont utilisés pour ajouter le second bloc de texte.
	  Qu'en est-il des lignes supprimées ? Nous pouvons facilement voir
	  comment elles sont représentées en permutant les 2 paramètres de
	  <command>diff</command>, affichant les différences entre
	  <filename>hello2.c</filename> et
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Les éléments suivants peuvent être distingués :
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      C'est la commande de suppression de <application>ed</application>
	      (<literal>d</literal>), indiquant que la ligne 2 doit être
	      supprimée. La seconde commande de suppression utilise un
	      intervalle (ligne 14 à 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      Le texte à supprimer est précédé du signe
	      <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>

	<!-- XXX - Changed lines? -->

	<para>
	  C'est suffisant pour la sortie du style <application>ed</application>.
	  Le programme GNU diff inclus dans Slackware Linux supporte ce qu'on
	  appelle les diffs unifiés. Les diffs unifiés sont très lisibles et
	  fournissent le contexte par défaut. <command>diff</command> peut 
	  fournir une sortie unifiée avec l'option
	  <parameter class="command">-u</parameter> :
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Les éléments suivants peuvent être vus dans la sortie :
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      Le nom du fichier original, et la date de la dernière
	      modification.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      Le nom du fichier modifié, et la date de la dernière modification.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Ce couple de nombres situe l'endroit et la taille du morceau que
	      le texte qui suit va impacter dans le fichier original, et dans
	      le fichier modifié. Donc, ici les nombres signifient que le
	      morceau impacté dans le fichier original débute à la ligne 1, et
	      fait 4 lignes. Dans le fichier modifié le morceau impacté débute
	      à la ligne 1, et fait 5 lignes. Les différents morceaux de la
	      sortie de diff débutent par cette entête.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Une ligne qui n'est pas précédée par un signe moins
	      (<emphasis>-</emphasis>) ou un signe plus
	      (<emphasis>+</emphasis>) reste inchangé. Les lignes inchangées
	      sont inclues car elles donnent une indication de contexte, et
	      évitent la multiplication de morceaux. S'il n'y a que quelques
	      lignes inchangées entre 2 changements, <command>diff</command> va
	      choisire de ne faire qu'un seul morceau plutôt que 2 morceaux.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Une ligne précédée par un signe plus
	      (<emphasis>+</emphasis>) est un ajout dans le fichier modifié par
	      rapport au fichier original.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Comme pour le format à la ed <command>diff</command>, nous pouvons
	  voir des suppressions en permutant les noms de fichiers :
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Comme vous pouvez le voir sur cette sortie, les lignes qui sont
	  supprimées dans le fichier modifié par rapport au fichier original
	  sont précédés par le signe moins (<emphasis>-</emphasis>).
	</para>

	<para>
	  Quand on travaille sur un ensemble plus grand de fichiers, il est
	  souvent utile de comparer des répertoires entiers. Par exemple, si
	  vous avez la version d'origine des sources d'un programme dans un
	  répertoire nommé <filename>hello.orig</filename>, et que la version
	  modifiée est dans un répertoire nommé <filename>hello</filename>, vous
	  pouvez utiliser le paramètre <parameter class="command">-r</parameter>
	  pour comparer récursivement les 2 répertoires. Par exemple :
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  A noter que cela ne va comparer que les fichiers qui sont présents
	  dans les 2 répertoires à la fois. La version GNU de diff, qui est
	  utilisée par Slackware Linux fournit le paramètre
	  <parameter class="command">-N</parameter>. Ce paramètre considère les
	  fichiers présents seulement dans un seul des 2 répertoires comme s'il
	  état vide. Donc par exemple, si nous avons ajouté un fichier nommé
	  <filename>Makefile</filename> au répertoire
	  <filename>hello</filename>, utiliser le parausing
	  <parameter class="command">-N</parameter> produira la sortie
	  suivante :
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Comme vous pouvez le voir l'indicateur du moreceau dans le fichier
	  original commence à la ligne 0 et fait 0 lignes.
	</para>

	<para>
	  Les utilisateurs UNIX s'échangent souvent les sorties de
	  <command>diff</command>, généralement appelées <quote>diffs</quote>
	  ou <quote>patches</quote>. La section suivante va vous montrer comment
	  manipuler les diffs. Mais vous êtes capables de les créer par
	  vous-même, en redirigeant la sortie de diff vers un fichier.
	  Par exemple :
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Si vous avez des diffs multiples, vous pouvez combiner facilement les
	  combiner en un seul diff, juste en concaténant les diffs :
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Mais assurez-vous qu'ils ont été créés depuis le même répertoire si
	  vous voulez vous servir de l'utilitaire <command>patch</command> qui
	  sera couvert dans la section suivante.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Modifier les fichiers avec la sortie de diff</title>

	<para>
	  Supposez que quelqu'un vous envoie la sortie de 
	  <command>diff</command> pour un fichier que vous avez créé. Il serait
	  fastidieux d'intégrer manuellement toutes les modifications qui ont
	  été faites. Heureusement, <command>patch</command> peut faire cela
	  pour vous. <command>patch</command> accepte les diffs en entrée
	  standard, et va tenter de modifier le fichier original, en fonction
	  des différences qui sont enregistrées dans le diff. Donc, par exemple,
	  si nous avons le fichier <filename>hello.c</filename>, et le patch
	  que nous avons produit précédemment basé sur les modifications entre
	  <filename>hello.c</filename> et
	  <filename>hello2.c</filename>, nous pouvons patcher
	  <filename>hello.c</filename> pour le rendre identique à son associé:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  Si vous avez <filename>hello2.c</filename>, vous pouvez vérifier que
	  les fichiers sont à présent identiques :
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  Il n'y a rien en sortie, donc c'est bien le cas. Une des
	  fonctionnalités intéressantes de <command>patch</command> est qu'elle
	  peut annuler les modifications faites à l'aide de diff, en utilisant
	  le paramètre <parameter class="command">-R</parameter> :
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  Dans ces exemples, le fichier original est patché. Parfois vous voulez
	  appliquer un patch sur un fichier avec un nom différent. Vous pouvez
	  le faire en fournissant le nom du fichier en tant que dernier
	  argument :
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  Vous pouvez aussi utiliser <command>patch</command> avec des diffs
	  qui ont été générés avec le paramètre <parameter
	  class="command">-r</parameter>, cependant vous devez prendre quelques
	  précautions. Supposez que l'entête d'un fichier particulier dans le
	  diff est ainsi :
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Si vous traitez ce diff avec <command>patch</command>, il va tenter
	  de modifier <filename>hello.c</filename>. Donc, le répertoire qui
	  contient ce fichier doit être le répertoire courant. Vous pouvez
	  utiliser le chemin d'accès complet avec <parameter
	  class="command">-p n</parameter>, où <emphasis>n</emphasis> est le
	  nombre de sous-répertoires composant le chemin qui doivent être
	  passés. Une valeur à <emphasis>0</emphasis> utilisera 
	  le chemin comme spécifié dans le patch,
	  <emphasis>1</emphasis> omettra le premier élément du chemin, etc.
	  Dans cet exemple, omettre le premier élément aura pour résultat le
	  patch de <filename>hello.c</filename>. Selon le standard Single UNIX
	  Specification version 3, le chemin qui est précédé par
	  <emphasis>---</emphasis> doit être utilisé pour construire le fichier
	  qui doit être patché. La version GNU de patch ne suit pas le standard
	  dans ce cas. Donc, c'est mieux d'omettre les éléments jusqu'à avoir
	  les 2 noms de répertoires identiques (habituellement le répertoire de
	  plus haut niveau dans le l'arborescence à modifier). Dans la plupart
	  des cas où on utilise des chemins relatif, on peut le faire en
	  utilisant <emphasis>-p 1</emphasis>. Par exemple :
	</para>

	<!-- XXX - add more examples for -p n -->

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  Ou vous pouvez utiliser le paramètre <parameter
	  class="command">-d</parameter> pour spécifier dans quel répertoire la
	  modification doit être appliquée :
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Si vous voulez conserver une sauvegarde lors de la modification d'un
	  fichier, vous pouvez utiliser le paramètre <parameter
	  class="command">-b</parameter> de <command>patch</command>.
	  Cela va créer une copie de chaque fichier concerné, nommée
	  <filename>filename.orig</filename>, avant d'effectuer réellement la
	  modification du fichier :
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Parfois un fichier ne peut pas être patché. Par exemple, s'il a déjà
	  été patché, s'il a trop changé pour appliquer le patch proprement, ou
	  si le fichier n'existe plus. Dans ce cas, les portions qui n'ont pas
	  pu être sauvées sont enregistrées dans un fichier nommé
	  <filename>filename.rej</filename>, où
	  <emphasis>filename</emphasis> est le fichier que
	  <command>patch</command> a tenté de modifier.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Expressions régulières</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Introduction</title>

      <para>Dans la vie de tous les jours, vous voudrez souvent manipuler du
	texte correspondant à un certain motif, plutôt qu'une chaîne de
	caractères litérale. Beaucoup d'utilitaires UNIX implémente un langage
	pour identifier des motifs de texte,
      <emphasis>les expressions regulières</emphasis> (regexps). Avec le temps
      le langage à expressions régulière a grandi, il a principalement à présent
      3 syntaxes d'expressions régulières : </para>

      <itemizedlist>
        <listitem>
          <para> Les expressions régulières traditionnelles UNIX. </para>
        </listitem>
        <listitem>
          <para> Les expressions régulières étendues POSIX. </para>
        </listitem>
        <listitem>
          <para> Les expressions régulières compatibles Perl (PCRE - NdT :
	    Perl-Compatible Regular Expressions). </para>
        </listitem>
      </itemizedlist>

      <para>
	POSIX regexps are mostly a superset of traditional UNIX
	regexps, and PCREs a superset of POSIX regexps. The syntax
	that an application supports differs per application, but
	almost all applications support at least POSIX
	regexps.
      </para>

      <para>
	Each syntactical unit in a regexp expresses one of the
	following things:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">A character</emphasis>: this is the
            basis of every regular expression, a character or a set of
            characters to be matched. For instance, the letter
            <emphasis>p</emphasis> or the the sign
            <emphasis>,</emphasis>. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Quantification</emphasis>: a
            quantifier specifies how many times the preceding
            character or set of characters should be matched. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternation</emphasis>: alternation
            is used to match <quote>a or b</quote> in which
            <emphasis>a</emphasis> and <emphasis>b</emphasis> can be a
            character or a regexp. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Grouping</emphasis>: this is used to
            group subexpressions, so that quantification or
            alternation can be applied to the group. </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Traditional UNIX regexps</title>

      <para>
	This section describes traditional UNIX regexps. Because of a
	lack of standardisation, the exact syntax may differ a bit per
	utility. Usually, the manual page of a command provides more
	detailed information about the supported basic or traditional
	regular expressions. It is a good idea to learn traditional
	regexps, but to use POSIX regexps for your own
	scripts.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Matching characters</title>

        <para>
	  Characters are matched by themselves. If a specific
	  character is used as a syntactic character for regexps, you
	  can match that character by adding a backslash. For
	  instance, <emphasis>\+</emphasis> matches the plus
	  character. </para>

        <para>
	  A period (<emphasis>.</emphasis>) matches any character, for
	  instance, the regexp <emphasis>b.g</emphasis> matches
	  <emphasis>bag</emphasis>, <emphasis>big</emphasis>, and
	  <emphasis>blg</emphasis>, but not
	  <emphasis>bit</emphasis>. </para>

        <para>
	  The period character, often provides too much freedom. You
	  can use square brackets (<emphasis>[]</emphasis>) to specify
	  characters which can be matched. For instance, the regexp
	  <emphasis>b[aei]g</emphasis> matches
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, and
	  <emphasis>big</emphasis>, but nothing else. You can also
	  match any character but the characters in a set by using the
	  square brackets, and using the caret
	  (<emphasis>^</emphasis>) as the first character. For
	  instance, <emphasis>b[^aei]g</emphasis> matches any three
	  character string that starts with <emphasis>b</emphasis> and
	  ends with <emphasis>g</emphasis>, with the exception of
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, and
	  <emphasis>big</emphasis>. It is also possible to match a
	  range of characters with a dash
	  (<emphasis>-</emphasis>). For example,
	  <emphasis>a[0-9]</emphasis> matches a followed by a single
	  number character. </para>

        <para>
	  Two special characters, the caret (<emphasis>^</emphasis>)
	  and the dollar sign (<emphasis>$</emphasis>), respectively
	  match the start and end of a line. This is very handy for
	  parsing files. For instance, you can match all lines that
	  start with a hash (<emphasis>#</emphasis>) with the regexp
	  <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Quantification</title>

        <para>
	  The simplest quantification sign that traditional regular
	  expressions support is the (Kleene) star
	  (<emphasis>*</emphasis>). This matches zero or arbitrary
	  instances of the preceding character. For instance,
	  <emphasis>ba*</emphasis> matches <emphasis>b</emphasis>,
	  <emphasis>ba</emphasis><emphasis>baa</emphasis>, etc. You
	  should be aware that a single character folowed by a star
	  without any context matches every string, because
	  <emphasis>c*</emphasis> also matches a string that has zero
	  <emphasis>c</emphasis> characters. </para>

        <para>
	  More specific repetitions can be specified with
	  backslash-escaped curly braces.
	  <emphasis>\{x,y\}</emphasis> matches the preceding character
	  at least <emphasis>x</emphasis> times, but not more than
	  <emphasis>y</emphasis> times. So,
	  <emphasis>ba\{1,3\}</emphasis> matches
	  <emphasis>ba</emphasis>, <emphasis>baa</emphasis>, and
	  <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Grouping</title>

        <para>
	  Backslash-escaped parentheses group various characters
	  together, so that you can apply quantification or
	  alternation to a group of characters. For instance,
	  <emphasis>\(ab\)\{1,3\}</emphasis> matches
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, and
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternation</title>

        <para>
	  A backslash-escaped pipe vertical bar
	  (<emphasis>\|</emphasis>) allows you to match either of two
	  expressions. This is not useful for single characters,
	  because <emphasis>a\|b</emphasis> is equivalent to
	  <emphasis>[ab]</emphasis>, but it is very useful in
	  conjunction with grouping. Suppose that you would like an
	  expression that matches <emphasis>apple</emphasis> and
	  <emphasis>pear</emphasis>, but nothing else. This can be
	  done easily with the vertical bar:
	  <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>POSIX extended regular expressions</title>

	<para>
	  POSIX regular expressions build upon traditional regular
	  expressions, adding some other useful primitives. Another
	  comforting difference is that grouping parenthesises,
	  quantification accolades, and the alternation sign
	  (<emphasis>|</emphasis>) are not backslash-escaped.  If they
	  are escaped, they will match the literal characters instead,
	  thus resulting in the opposite behavior of traditional
	  regular expressions. Most people find POSIX extended regular
	  expressions much more comfortable, making them more widely
	  used.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	  <title>Matching characters</title>

	  <para>
	    Normal character matching has not changed compared to the
	    traditional regular expressions described in <xref
	    linkend="chap-textproc-regexps-traditional-characters" />
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Quantification</title>

	  <para>
	    Besides the Kleene star (<emphasis>*</emphasis>), that
	    matches the preceding character or group zero or more
	    times, POSIX extended regular expressions add two new
	    simple quantification primitives. The plus sign
	    (<emphasis>+</emphasis>) matches the preceding character
	    or group one or more times. For example,
	    <emphasis>a+</emphasis>, matches <emphasis>a</emphasis>
	    (or any string with more consecutive
	    <emphasis>a</emphasis>'s), but does not match zero
	    <emphasis>a</emphasis>'s. The questions mark character
	    (<emphasis>?</emphasis>) matches the preceding character
	    zero or one time. So, <emphasis>ba?d</emphasis> matches
	    <emphasis>bd</emphasis> and <emphasis>bad</emphasis>, but
	    not <emphasis>baad</emphasis> or <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Curly braces are used for repetition, like traditional
	    regular expressions. Though the backslash should be
	    omitted. To match <emphasis>ba</emphasis> and
	    <emphasis>baa</emphasis>, one should use
	    <emphasis>ba{1,2}</emphasis> rather than
	    <emphasis>ba\{1,2\}</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Grouping</title>

	  <para>
	    Grouping is done in the same manner as traditional regular
	    expressions, leaving out the escape-backslashes before the
	    parenthesises. For example, <emphasis>(ab){1,3}</emphasis>
	    matches <emphasis>ab</emphasis>,
	    <emphasis>abab</emphasis>, and
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	  <title>Alternation</title>

	  <para>
	    Alternation is done in the same manner as with traditional
	    regular expressions, leaving out the escape-backslashes
	    before the vertical bar. So,
	    <emphasis>(apple)|(pear)</emphasis> matches
	    <emphasis>apple</emphasis> and <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

      <!--      
      <sect2 xml:id="chap-textproc-regexps-perl"> <title>Perl</title>
      </sect2>
    -->

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>

    <!-- XXX - document -c, -l, -x, -n, -q parameters -->

    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Basic grep usage</title>

      <para>
	We have now arrived at one of the most important utilties of
	the UNIX System, and the first occasion to try and use regular
	expressions. The <command>grep</command> command is used to
	search a text stream or a file for a pattern. This pattern is
	a regular expression, and can either be a basic regular
	expression or a POSIX extended regular expression (when the
	<parameter class="command">-E</parameter> parameter is
	used). By default, <command>grep</command> will write the
	lines that were matched to the standard output. In the most
	basic syntax, you can specify a regular expression as an
	argument, and <command>grep</command> will search matches in
	the text from the standard input. This is a nice manner to
	practice a bit with regular expressions.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	The example listed above shows a basic regular expression in
	action, that matches a line solely consisting of two or three
	times the <emphasis>ab</emphasis> string. You can do the same
	thing with POSIX extended regular expressions, by adding the
	<parameter class="command">-E</parameter> (for extended)
	parameter:
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Since the default behavior of <command>grep</command> is to
	read from the standard input, you can add it to a pipeline to
	get the interesting parts of the output of the preceding
	commands in the pipeline. For instance, if you would like to
	search for the string <emphasis>2006</emphasis> in the third
	column in a file, you could combine the <command>cut</command>
	and <command>grep</command> command:
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>grepping files</title>

      <para>
	Naturally, <command>grep</command> can also directly read a
	file, rather than the standard input. As usual, this is done
	by adding the files to be read as the last arguments. The
	following example will print all lines from the
	<filename>/etc/passwd</filename> file that start with the
	string <emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <!-- XXX - filename notation when multiple files are specified -->

      <para>
        With the <parameter class="command">-r</parameter> option,
	<command>grep</command> will recursively traverse a directory
	structure, trying to find matches in each file that was encountered
	during the traversal.
	Though, it is better to combine <command>grep</command> with
	<command>find</command> and the <emphasis>-exec</emphasis>
	operand in scripts that have to be portable.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	is the non-portable functional equivalent of
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Pattern behavior</title>

      <para>
	<command>grep</command> can also print all lines that do not
	match the pattern that was used.  This is done by adding the
	<parameter class="command">-v</parameter> parameter:
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	If you want to use the pattern in a case-insensitive manner,
	you can add the <parameter class="command">-i</parameter>
	parameter. For example:
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	You can also match a string literally with the <parameter
	class="command">-F</parameter> parameter:
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Using multiple patterns</title>

      <para>
	As we have seen, you can use the alternation character
	(<emphasis>|</emphasis>) to match either of two or more
	subpatterns. If two patterns that you would like to match
	differ a lot, it is often more comfortable to make two
	separate patterns. <command>grep</command> allows you to use
	more than one pattern by separating patterns with a newline
	character. So, for example, if you would like to print lines
	that match either the <emphasis>a</emphasis> or
	<emphasis>b</emphasis> pattern, this can be done easily by
	starting a new line:
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	This works, because quotes are used, and the shell passes
	quoted parameters literally. Though, it must be admitted that
	this is not quite pretty. <command>grep</command> accepts one
	or more <parameter class="command">-e pattern</parameter>
	parameters, giving the opportunity to specify more than one
	parameter on one line. The <command>grep</command> invocation
	in the previous example could be rewritten as:
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
