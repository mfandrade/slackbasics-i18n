<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="fr"
  xml:id="chap-textproc">
  <title>Traitement de texte</title>

  <para>
    L'édition de texte est un des domaines où UNIX excelle, car cela forme le
    coeur de la philosophie UNIX, comme décrit dans
    <xref linkend="chap-intro-unix" />. La plupart des commandes UNIX sont de
    simples programmes qui lisent des données de l'entrée standard, effectuent
    des opérations sur les données, et envoient les résultats vers la sortie
    standard du programme. Ces programmes agissent essentiellement comme des
    filtres, qui peuvent être connectés en pipeline. Cela permet à l'utilisateur
    de mettre en oeuvre les outils UNIX dans des situations que l'auteur n'a
    jamais envisagé. Dans les chapitres suivants nous allons voir comment
    fabriquer des filtes simples nous-même. <!-- XXX - xref -->
  </para>

  <para>
    This chapter describes some simple, but important, UNIX commands
    that can be used to manipulate text. After that, we will dive into
    regular expressions, a sublanguage that can be used to match text
    patterns.
  </para>
 
  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulation de texte simple</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Répeter ce qui est dit</title>

      <para>
	La filtre texte le plus simple est <command>cat</command>, il ne fait
	rien d'autre qu'envoyer les données depuis stdin vers stdout :
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
	Une autre fonctionnalité utile est de lui faire envoyer le contenu d'un
	fichier vers la sortie standard :
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
	<command>cat</command> (Ndt: cat=concatène) porte bien son nom lorsque
	plusieurs fichiers sont ajoutés en arguments. Cela va concaténer les
	fichiers ; autrement dit, il va envoyer le contenu de tous les fichiers
	vers la sortie standard, dans le même ordre où ils ont été spécifiés en
	argument. La capture d'écran suivante montre cela :
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Statistiques de texte</title>

      <para>
	La commande <command>wc</command> fournit des statistiques sur un
	fichier texte ou flux texte. Sans paramètre, elle va afficher le nombre
	de lignes, de mots et le nombre d'octects respectivement. Un mot est
	délimité par un caractère d'espacement, ou une sequence de caractères
	d'espacement.
      </para>

      <para>
	L'exemple suivant montre le nombre de lignes, de mots, et d'octets dans
	l'exemple classique <quote>Hello world!</quote> :
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput> 
       1       2      13
      </screen>

      <para>
	Si vous désirez afficher seulement une de ces composantes, vous pouvez
	utiliser un des paramètres <parameter class="command">-l</parameter>
	(lignes), <parameter class="command">-w</parameter> (mots), ou
	<parameter class="command">-c</parameter> (octets).
	Par exemple, ajouter seulement le paramètre
	<parameter class="command">-l</parameter> affichera le nombre de lignes
	dans un fichier :
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command> 
  235882 /usr/share/dict/words
      </screen>

      <para>
	Ou vous pouvez afficher des champs supplémentaires en ajoutant un
	paramètre :
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
	Notez que peu importe l'ordre dans lequel les options sont spécifiées,
	l'ordre d'affichage sera toujours le même (lignes, mots, octets).
      </para>

      <para>
	Puisque <parameter class="command">-c</parameter> affiche le nombre
	d'octets, ce paramètre peut ne pas représenter le nombre de caractères
	que comporte un texte, car le jeu de caractères utilisé peut dépasser la
	taille d'un octet. Pour y remédier, le paramètre <parameter
	class="command">-m</parameter> a été ajouté affichant le nombre de
	caractères dans un texte, indépendant du jeu de caractères.
	<parameter class="command">-c</parameter> et
	<parameter class="command">-m</parameter> se substituent, et ne peuvent
	jamais être utilisés en même temps.
      </para>

      <para>
	Les statistiques que <command>wc</command> fournit sont plus utiles
	qu'il n'y paraît. Par exemple, le paramètre
	<parameter class="command">-l</parameter> est souvent utilisé en tant
	que compteur de la sortie d'une commande. C'est utile, car beaucoup de
	commandes séparent les unités logiques par un caractère de nouvelle
	ligne. Supposez que vous voulez compter le nombre de fichiers dans votre
	répertoire home ayant l'extension <filename>.txt</filename>. Vous pouvez
	réaliser ceci en combinant <command>find</command> pour chercher les
	fichiers concernés et	<command>wc</command> pour compter le nombre
	d'occurrences :
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Manipulation de caractères</title>

      <para>
	La commande <command>tr</command> peut être utilisée pour réaliser des
	opérations communes sur les caractères, comme échanger des caractères,
	supprimer des caractères, et rétrécir des séquences de caractères.
	Suivant l'opération, 1 ou 2 séquences de caractères doivent être
	spécifiées. Ajoutés aux caractères normaux, certaines séquences de
	caractères spéciaux peuvent être utilisées :
      </para>

      <variablelist>
	<varlistentry>
	  <term>\caractère</term>
	  <listitem>
	    <para>
	      Cette notation est utilisée pour spécifier des caractères qui
	      nécessitent un échappement, les plus célèbres sont
	      <emphasis>\n</emphasis> (saut de ligne), <emphasis>\t</emphasis>
	      (tabulation horizontale), et <emphasis>\\</emphasis> (backslash).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>caractère1-caractère2</term>
	  <listitem>
	    <para>
	      Insère implicitement tout caractère de
	      <emphasis>caractère1</emphasis> en
	      <emphasis>caractère2</emphasis>. Cette notation doit être utilisée
	      avec attention, car elle ne donne pas toujours le résultat escompté. Par exemple, la séquence
	      <emphasis>a-d</emphasis> peut signifier
	      <emphasis>abcd</emphasis> pour la locale POSIX (configuration de
	      la langue), mais cela peut ne pas être vrai pour d'autres locales.
	      <!-- XXX - locale footnote -->
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:classe:]</term>
	  <listitem>
	    <para>
	      Trouve une classe prédéfinie de caractères. Toutes les classes
	      possibles sont dans <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*]</term>
	  <listitem>
	    <para>
	      Répète <emphasis>caractère</emphasis> jusqu'à ce que la seconde
	      séquence soit aussi longue que la première séquence de caractères.
	      Cette notation ne peut être employée que dans la seconde séquence.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[caractère*n]</term>
	  <listitem>
	    <para>
	      Répète <emphasis>caractère</emphasis>
	      <emphasis>n</emphasis> fois.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>classes de caractères tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Classe</entry><entry>Signification</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Toute lettre ou tout chiffre.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Lettres.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Espace blanc horizontal (e.g. espaces et tabulations).
	      </entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Caractères de contrôle.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Tout chiffre (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Tout caractère imprimable, sauf espace blanc.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Lettres minuscules.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Tout caractère imprimable, inclus l'espace blanc
		horizontal, mais excepté l'espace blanc vertical.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Caractères de ponctuation.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
	      <entry>Tout espace blanc.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Lettres majuscules.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Chiffres hexadécimaux (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Echanger des caractères</title>

	<para>
	  L'opération par défaut de <command>tr</command> est d'échanger
	  (transformer) des caractères. Cela signifie que le
	  <emphasis>n</emphasis>-ème caractère dans la première séquence est
	  remplacé par le <emphasis>n</emphasis>-ème caractère dans la seconde
	  séquence. Par exemple, vous pouvez remplacer tous les
	  <emphasis>e</emphasis> par des <emphasis>i</emphasis> et les
	  <emphasis>o</emphasis> par des <emphasis>a</emphasis> avec une seule
	  opération <command>tr</command> :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
	  Lorsque la seconde séquence n'est pas aussi longue que la première, le
	  dernier caractère de la seconde séquence est répété. Cependant cela ne
	  s'applique pas nécessairement à d'autres systèmes UNIX. Donc, si vous
	  voulez utiliser <command>tr</command> de façon indépendante du
	  système, définissez explicitement le caractère qui doit être répété.
	  Par exemple :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
	  Une autre particularité est l'utilisation de la syntaxe de répétition
	  au milieu de la séquence. Supposez que la séquence 1 est
	  <emphasis>abcdef</emphasis>, et la séquence 2 est
	  <emphasis>@[-*]!</emphasis>. <command>tr</command> va remplacer
	  <emphasis>a</emphasis> avec <emphasis>@</emphasis>,
	  <emphasis>b</emphasis>, <emphasis>c</emphasis>,
	  <emphasis>d</emphasis>, et <emphasis>e</emphasis> avec
	  <emphasis>-</emphasis>, et <emphasis>f</emphasis> avec
	  <emphasis>!</emphasis>.
	  Cependant d'autres systèmes UNIX remplacent
	  <emphasis>a</emphasis> avec
	  <emphasis>@</emphasis>, et le reste de la séquence de caractères avec
	  <emphasis>-</emphasis>. Donc, une notation plus correcte et explicite
	  serait <emphasis>@[-*4]!</emphasis>,
	  ce qui conduit au même résultat sur presque tous les systèmes UNIX :
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Supprimer des séquences de caractères</title>

	<para>
	  Lorque le paramètre <parameter class="command">-s</parameter>
	  est précisé, <command>tr</command> va supprimer tous les caractères
	  présent dans la seconde séquence. Cela signifie qu'une séquence d'un
	  même caractère va être réduite à 1 caractère. Supprimons le caractère
	  &quot;<emphasis>e</emphasis>&quot; :
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
	  Nous pouvons combiner cela avec la transformation pour montrer un
	  exemple utile de <command>tr</command> en action. Supposez que vous
	  voulez marquer toutes les voyelles avec le signe
	  <emphasis>at</emphasis> (<emphasis>@</emphasis>), ainsi que les
	  voyelles consécutives par un seul signe <emphasis>at</emphasis>.
	  Cela se réalise facilement en pipelinant 2 commandes
	  <command>tr</command> :
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Supprimer des caractères</title>

	<para>
	  Enfin, <command>tr</command> peut être utilisé pour supprimer des
	  caractères. Si le paramètre <parameter class="command">-d</parameter>
	  est précisé, tout caractère de la première séquence est supprimé :
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Couper et coller des colonnes de texte</title>

      <para>
	La commande <command>cut</command> est fournie par les systèmes UNIX
	pour <quote>couper</quote> une ou plusieurs colonnes d'un fichier ou
	d'un flux, et l'afficher sur la sortie standard. Il est souvent utilse
	d'extraire de façon sélective des informations dans un texte.
	<command>cut</command> fournit 3 approches pour couper des information
	provenant de fichiers :
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Par octet.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Par caractère, ce qui est différent du découpage par octet sur des
	    systèmes qui utilisent un jeu de caractères plus large que 8 bits.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Par champ, délimité par un caractère.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Dans les 3 approches, vous pouvez spécifier l'élément à choisir par son
	numéro en partant de <emphasis>1</emphasis>. Vous pouvez spécifier un
	intervalle en utilisant le tiret (<emphasis>-</emphasis>). Donc,
	<emphasis>M-N</emphasis> signifie du Mième au N-ième
	élément. Omettre M (<emphasis>-N</emphasis>) sélectionne tous les
	éléments depuis le premier élément jusqu'au N-ième élément. Omettre N
	(<emphasis>M-</emphasis>) sélectionne le M-ième élément jusqu'au dernier
	élément. Des éléments multiples ou intervalles peuvent être combinés en
	les séparant par des virgules (<emphasis>,</emphasis>). Donc, en
	l'occurrence, <emphasis>1,3-</emphasis> selectionne le premier élément
	et du troisième jusqu'au dernier élément.
      </para>

      <para>
	Les données peuvent être coupée par champ avec le paramètre <parameter
	class="command">-f champs</parameter>. Par défaut, la tabulation
	horizontale est utilisée en tant que séparateur. Voyons
	<command>cut</command> en action avec un petit dictionnaire hollandais à
	anglais :
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
	Nous pouvons récupérer tous les mots anglais en sélectionnant le second
	champ :
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
	Plutôt facile. Maintenant faisons la même chose avec un fichier ayant
	comme séparateur de champs le deux-points. Nous pouvons essayer ceci
	facilement en convertissant le dictionnaire avec la commande
	<command>tr</command> que nous avons vu précédamment, en remplaçant les
	tabulations par des deux-points :
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Si nous utilisons la même commande que dans l'exemple précédent, nous
	n'obtenons pas le résultat correct :
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Le délimiteur n'a pas été trouvé, c'est ce qui se produit.
	Si une ligne ne contient pas le délimiteur escompté, le comportement par
	défaut de <command>cut</command> est d'afficher la ligne complète. Vous
	pouvez empêcher cela avec le paramètre <parameter
	class="command">-s</parameter>.
      </para>

      <para>
	Pour utiliser un délimiteur différent de la tabulation horizontale,
	ajoutez le paramètre <parameter class="command">-d
        car_délimiteur</parameter> pour fixer le caractère de délimitation.
	Donc, dans le cas de notre fichier <filename>dictionary-new</filename>,
	nous allons demander à <command>cut</command> d'utiliser le deux-points
	comme délimiteur :
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
	Si un champ spécifié n'existe pas dans une ligne, ce champ particulier
	ne sera pas affiché.
      </para>

      <para>
	<parameter class="command">-b bytes</parameter> et
	<parameter class="command">-c characters</parameter> sélectionnent
	respectivement les octets et les caractères dans le texte. Sur des
	systèmes plus anciens, un caractère était traditionnellement sur un
	octet. Cependant les nouveaux systèmes peuvent fournir des jeux de
	caractères sur plus d'un octet. Donc, si vous voulez être sûr de
	capturer des caractères complets, utilisez le paramètre
	<parameter class="command">-c</parameter>.
	Un exemple d'entraînement pour voir le paramètre <parameter
	class="command">-c</parameter> à l'oeuvre est de chercher le top 10 des
	ensembles de mots ayant les 3 premiers caractères en commun. La plupart
	des systèmes UNIX fournissent une liste de mots séparés par un caractère
	de saut de ligne. Nous pouvons utiliser <command>cut</command> pour
	récupérer les 3 premiers caractères des mots de la liste, ajouter
	<parameter class="command">uniq</parameter> <!-- XXX -
	where? --> pour compter les séquences de 3 caractères égales, et
	utiliser <command>sort</command> pour trier dans l'ordre inverse
	numérique (<command>sort</command> est décrit dans <xref
	linkend="chap-textproc-simple-sort" />). Enfin, nous utiliserons
	<command>head</command> pour obtenir les 10 séquences les plus
	fréquentes :
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
	Ayant conclu avec cette jolie mise en oeuvre de commandes UNIX,	nous
	allons passer à la commande <command>paste</command>
	(NdT : paste=coller), qui combine des fichiers en colonnes en un seul
	flux texte.
      </para>

      <para>
	L'utilisation de <command>paste</command> est très simple, elle va
	combiner tous les fichiers passés en argument, séparé par une
	tabulation.
	Avec la liste des mots anglais et hollandais, nous pouvons générer un
	petit dictionnaire :
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
	Vous pouvez aussi combiner plus de 2 fichiers :
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput> 
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
	Si un des fichiers est plus long, l'ordre des colonnes est conservé, des
	entrées vides sont insérées pour compléter les entrées des fichiers plus
	courts.
      </para>

      <para>
	Vous pouvez utiliser un autre délimiteur en ajoutant le paramètre
	<parameter class="command">-d délimiteur</parameter>. Par exemple, nous
	pouvons fabriquer un dictionnaire avec des deux-points comme
	séparateurs :
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
	Normalement, <command>paste</command> combine les fichiers en colonnes
	différentes. Vous pouvez aussi dire à <command>paste</command>
	d'utiliser les lignes de chaque fichier en tant que colonnes, et placer
	les colonnes de chaque fichier sur une ligne séparée. Cela se fait avec
	le paramètre <parameter	class="command">-s</parameter> :
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Trier un texte</title>

      <para>
	UNIX offre la commande <command>sort</command> pour trier du texte.
	<command>sort</command> peut aussi vérifier si un fichier est trié, et
	fusionner 2 fichiers triés. <command>sort</command> peut trier dans
	l'ordre du dictionnaire ou dans l'ordre numérique. L'ordre de tri par
	défaut est l'odre du dictionnaire. Cela signifie que les lignes de texte
	sont comparées caractère par caractère, trié comme spécifié dans la
	séquence de groupage courante (spécifiée via la variable d'environnement
	LC_COLLATE). Cela pose un piège lorsque vous triez des nombre en
	l'occurrence, si vous avez les nombre de 1 à 10 sur une ligne
	différente, la séquence triée sera 1, 10, 2, 3, etc. Cela est dû à
	l'interprétation par caractère du tri par dictionnaire. Si vous voulez
	trier des lignes en tant que nombres, utilisez le tri numérique.
      </para>

      <para>
	Si aucun paramètre n'est spécifié, <command>sort</command> trie les lignes en entrée dans l'ordre du dictionnaire. Par exemple :
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Comme vous pouvez le voir, les entrées sont correctement triées. Parfois
	il peut y avoir 2 lignes identiques. Vous pouvez fusionner les lignes
	identiques en ajoutant le paramètre
	<parameter class="command">-u</parameter>. Les 2 exemples ci-dessous
	illustrent ceci.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Il existe quelques paramètres supplémentaires pouvant être utiles pour
	modifier un peu le résultat :
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Le paramètre <parameter class="command">-f</parameter> permet un tri
	    un tri insensible à la casse.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Si <parameter class="command">-d</parameter> est ajouté, seuls les
	    caractères blancs et les caractères sont utilisés pour déterminer
	    l'ordre de tri.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Le paramètre <parameter class="command">-i</parameter> dit à
	    <command>sort</command> d'ignorer les caractères non imprimables.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
	Vous pouvez trier les fichiers par ordre numérique en ajoutant le
	paramètre <parameter class="command">-n</parameter>. Ce paramètre
	arrète la lecture de la ligne en entrée dès qu'un caractère non
	numérique est rencontré. Les signe moins, point décimal, séparateur de
	milliers, caractère de base numérique (qui distingue une écriture en
	exponentielle d'un nombre standard), et caractères blancs peuvent être
	utilisés en tant que nombre. Ces caractères sont interprétés en
	conséquence.
      </para>

      <para>
	L'exemple suivant montre un tri numérique mis en oeuvre, en pipelinant
	la sortie de <command>du</command> vers	<command>sort</command>. Ca
	marche car <command>du</command> spécifie la taille de chaque fichier
	en premier champ.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
	Dans ce cas, la sortie n'est probablement pas utile si vous voulez lire
	la sortie dans un outil de mise en pages, car les fichiers les plus
	petits sont affichés en premier. C'est là que le paramètre
	<parameter class="command">-r</parameter> devient pratique. Il inverse
	l'ordre de tri.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
	Le paramètre <parameter class="command">-r</parameter> fonctionne aussi
	pour les tris par dictionnaire.
      </para>

      <para>
	Assez souvent, les fichiers sont structurés en plusieurs colonnes, et
	vous voulez trier un fichier par une colonne autre que la première. Par
	exemple, voyons le fichier score suivant nommé
	<filename>score.txt</filename> :
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>
     
    <para>
      Supposons que nous voulons trier les entrées dans ce fichier par les noms
      de pays sur 2 lettres. <command>sort</command> nous permet de trier un
      fichier par une colonne avec le paramètre <parameter
      class="command">-k col1[,col2]</parameter>.  Où <emphasis>col1</emphasis>
      à <emphasis>col2</emphasis> sont utilisés comme champs en entrée soumis au
      tri. Si <emphasis>col2</emphasis> n'est pas spécifié, tous les champs
      jusqu'à la fin de la ligne sont utilisés. Donc si vous ne voulez utiliser
      qu'une seule colonne, utilisez <parameter
      class="command">-k col1,col1</parameter>. Vous pouvez aussi spécifier le
      caractère de départ dans une colonne en ajoutant un point
      (<emphasis>.</emphasis>) et un index de caractère. Par exemple, <parameter
      class="command">-k 2.3,4.2</parameter> signifie la deuxième colonne
      démarrant au troisième caractère, la troisième colonne, et la quatrième
      colonne jusqu'au deuxième caractère inclus.
    </para>

    <!-- XXX - document -b? Mentioned lateron (-k) -->

    <para>
      Il y a encore une autre particularité lors du tri par colonnes : par
      défaut, <command>sort</command> utilise le caractère blanc comme
      séparateur de colonne. Si vous utilisez un caractère de séparation
      différent, vous aurez à utiliser le paramètre
      <parameter>-t char</parameter>, qui est utilisé pour spécifier le
      séparateur de champ.
    </para>

    <para>
      Avec les paramètres <parameter class="command">-t</parameter> et
      <parameter class="command">-k</parameter> combinés, nous pouvons trier le
      fichier de scores par code de pays :
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Donc, comment nous pouvons trier le fichier par score ? Evidemment, nous
      devons demander à sort d'utiliser la troisième colonne. Cependant sort
      utilise un tri par dictionnaire par défaut<footnote><para>Bien sûr, ça n'a
      pas d'importance, car nous n'utilisons pas de nombres supérieurs à 9, et
      pratiquement tous les jeux de caractères ont les nombres dans l'ordre
      numérique.</para></footnote>. Vous pouvez utiliser <parameter
      class="command">-n</parameter>, mais <command>sort</command> permet aussi
      une tournure plus sophistiquée. Vous pouvez ajouter un ou plusieurs
      <emphasis>n</emphasis>, <emphasis>r</emphasis>>,
      <emphasis>f</emphasis>, <emphasis>d</emphasis>,
      <emphasis>i</emphasis>, ou <emphasis>b</emphasis> au spécifieur de
      colonne. Ces lettres représentent les paramètres de
      <command>sort</command> du même nom. Si vous ajoutez seulement la colonne
      de départ, ajoutez-la dans cette colonne, sinon, ajoutez-la à la dernière
      colonne.
    </para>

    <para>
      La commande suivante trie le fichier par score :
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      Il est bon de suivre cette approche, plutôt que d'utiliser les paramètres,
      car <command>sort</command> vous permet d'utiliser plus d'un paramètre
      <parameter class="command">-k</parameter>. Et l'ajout de ces flags aux
      spécifieurs de colonnes vous permettra de trier des colonnes différentes
      de façon différente. Par exemple, utiliser <command>sort</command> avec
      les paramètres <parameter class="command">-k 3,3n -k 2,2</parameter> va
      trier toutes les lignes dans l'ordre numérique sur la troisième colonne.
      Si des lignes on un nombre identique dans la troisième colonne, ces lignes
      peuvent alors être triées par dictionnaire sur la deuxième colonne.
    </para>

    <para>
      Si vous voulez vérifier si un fichier est déjà trié, vous pouvez utiliser
      le paramètre <parameter class="command">-c</parameter>. Si un fichier est
      déja trié, sort retournera la valeur <emphasis>0</emphasis>, sinon
      <emphasis>1</emphasis>. Nous pouvons vérifier ceci en affichant la valeur
      de la variable <emphasis>?</emphasis>, qui contient la valeur de retour de
      la dernière commande exécutée.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      La seconde commande montre qu'effectivement ça fonctionne, en pipelinant
      la sortie du tri de <filename>scores.txt</filename> vers
      <command>sort</command>.
    </para>

    <para>
      Enfin, vous pouver fusionner 2 fichiers triés avec le paramètre <parameter
      class="command">-m</parameter>, en conservant l'ordre de tri correct. Cela
      est plus rapide que de concaténer les fichiers et de les trier ensuite.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Différences entre fichiers</title>

      <para>
	Vu que les flux de texte et les fichiers texte sont très importants en
	UNIX, il est souvent utile de voir les différences entre 2 fichiers
	texte. Les utilitaires principaux pour manipuler les différences entre
	fichiers sont <command>diff</command> et <command>patch</command>.
	<command>diff</command> affiche les différences entre fichiers. La
	sortie de <command>diff</command> (NdT: diff=différence) peut être
	exploitée par <command>patch</command> pour appliquer les modifications
	entre 2 fichiers, à un fichier. <quote>Les différences</quote> sont
	aussi la base des systèmes de gestion de sources/versions.
	<!-- XXX - xref to version management chapters --> La section suivante
	décrit <command>diff</command> and <command>patch</command>.
	Pour avoir un peu de matière sur laquelle travailler, les fichiers
	source C suivants sont utilisés pour démontrer l'utilisation de ces
	commandes. Ces fichiers sont nommés respectivement
	<filename>hello.c</filename> et	<filename>hello2.c</filename>.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Lister les différences entre fichiers</title>

	<para>
	  Supposez que vous avez reçu de la part d'un ami le programme
	  <filename>hello.c</filename>, et que vous l'avez modifié pour fournir
	  à l'utilisateur les date et heure courantes. Vous pourriez simplement
	  envoyer à votre ami le programme modifié. Mais si le fichier grossit,
	  cela peut devenir gênant, car les modifications sont alors difficiles
	  à trouver. De plus, votre ami a pu aussi recevoir des modifications
	  des sources du programme d'autres personnes. C'est une situation
	  typique où <command>diff</command> devient utile.
	  <command>diff</command> affiche les différences entre 2 fichiers. Sa
	  syntaxe la plus simple est <command>diff file
	  file2</command>, qui affiche les différences entre
	  <filename>file</filename> et
	  <filename>file2</filename>. Essayons avec nos fichiers source :
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  Les ajouts de <filename>hello2.c</filename> sont visibles par cette
	  sortie, mais le format peut sembler un peu étrange. En fait, ce sont
	  des commandes qui peuvent être interprétées par l'éditeur de lignes
	  <command>ed</command>. Nous allons voir un format plus agréable après
	  avoir touché du doigt le format de sortie par défaut.
	</para>

	<para>
	  2 éléments différents peuvent être tirés de cette sortie :
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      C'est une commande <application>ed</application> qui spécifie que
	      le texte doit être ajouté
	      (<literal>a</literal>) après la ligne <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      C'est le texte destiné à être ajouté après la deuxième ligne. Le
	      signe <quote><emphasis>&gt;</emphasis></quote> est utilisé pour
	      marquer les lignes ajoutées.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Les mêmes éléments sont utilisés pour ajouter le second bloc de texte.
	  Qu'en est-il des lignes supprimées ? Nous pouvons facilement voir
	  comment elles sont représentées en permutant les 2 paramètres de
	  <command>diff</command>, affichant les différences entre
	  <filename>hello2.c</filename> et
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Les éléments suivants peuvent être distingués :
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      C'est la commande de suppression de <application>ed</application>
	      (<literal>d</literal>), indiquant que la ligne 2 doit être
	      supprimée. La seconde commande de suppression utilise un
	      intervalle (ligne 14 à 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      Le texte à supprimer est précédé du signe
	      <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>

	<!-- XXX - Changed lines? -->

	<para>
	  C'est suffisant pour la sortie du style <application>ed</application>.
	  Le programme GNU diff inclus dans Slackware Linux supporte ce qu'on
	  appelle les diffs unifiés. Les diffs unifiés sont très lisibles et
	  fournissent le contexte par défaut. <command>diff</command> peut 
	  fournir une sortie unifiée avec l'option
	  <parameter class="command">-u</parameter> :
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Les éléments suivants peuvent être vus dans la sortie :
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      Le nom du fichier original, et la date de la dernière
	      modification.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      Le nom du fichier modifié, et la date de la dernière modification.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Ce couple de nombres situe l'endroit et la taille du morceau que
	      le texte qui suit va impacter dans le fichier original, et dans
	      le fichier modifié. Donc, ici les nombres signifient que le
	      morceau impacté dans le fichier original débute à la ligne 1, et
	      fait 4 lignes. Dans le fichier modifié le morceau impacté débute
	      à la ligne 1, et fait 5 lignes. Les différents morceaux de la
	      sortie de diff débutent par cette entête.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Une ligne qui n'est pas précédée par un signe moins
	      (<emphasis>-</emphasis>) ou un signe plus
	      (<emphasis>+</emphasis>) reste inchangé. Les lignes inchangées
	      sont inclues car elles donnent une indication de contexte, et
	      évitent la multiplication de morceaux. S'il n'y a que quelques
	      lignes inchangées entre 2 changements, <command>diff</command> va
	      choisire de ne faire qu'un seul morceau plutôt que 2 morceaux.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Une ligne précédée par un signe plus
	      (<emphasis>+</emphasis>) est un ajout dans le fichier modifié par
	      rapport au fichier original.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Comme pour le format à la ed <command>diff</command>, nous pouvons
	  voir des suppressions en permutant les noms de fichiers :
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Comme vous pouvez le voir sur cette sortie, les lignes qui sont
	  supprimées dans le fichier modifié par rapport au fichier original
	  sont précédés par le signe moins (<emphasis>-</emphasis>).
	</para>

	<para>
	  Quand on travaille sur un ensemble plus grand de fichiers, il est
	  souvent utile de comparer des répertoires entiers. Par exemple, si
	  vous avez la version d'origine des sources d'un programme dans un
	  répertoire nommé <filename>hello.orig</filename>, et que la version
	  modifiée est dans un répertoire nommé <filename>hello</filename>, vous
	  pouvez utiliser le paramètre <parameter class="command">-r</parameter>
	  pour comparer récursivement les 2 répertoires. Par exemple :
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  A noter que cela ne va comparer que les fichiers qui sont présents
	  dans les 2 répertoires à la fois. La version GNU de diff, qui est
	  utilisée par Slackware Linux fournit le paramètre
	  <parameter class="command">-N</parameter>. Ce paramètre considère les
	  fichiers présents seulement dans un seul des 2 répertoires comme s'il
	  état vide. Donc par exemple, si nous avons ajouté un fichier nommé
	  <filename>Makefile</filename> au répertoire
	  <filename>hello</filename>, utiliser le parausing
	  <parameter class="command">-N</parameter> produira la sortie
	  suivante :
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Comme vous pouvez le voir l'indicateur du moreceau dans le fichier
	  original commence à la ligne 0 et fait 0 lignes.
	</para>

	<para>
	  Les utilisateurs UNIX s'échangent souvent les sorties de
	  <command>diff</command>, généralement appelées <quote>diffs</quote>
	  ou <quote>patches</quote>. La section suivante va vous montrer comment
	  manipuler les diffs. Mais vous êtes capables de les créer par
	  vous-même, en redirigeant la sortie de diff vers un fichier.
	  Par exemple :
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Si vous avez des diffs multiples, vous pouvez combiner facilement les
	  combiner en un seul diff, juste en concaténant les diffs :
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Mais assurez-vous qu'ils ont été créés depuis le même répertoire si
	  vous voulez vous servir de l'utilitaire <command>patch</command> qui
	  sera couvert dans la section suivante.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Modifier les fichiers avec la sortie de diff</title>

	<para>
	  Supposez que quelqu'un vous envoie la sortie de 
	  <command>diff</command> pour un fichier que vous avez créé. Il serait
	  fastidieux d'intégrer manuellement toutes les modifications qui ont
	  été faites. Heureusement, <command>patch</command> peut faire cela
	  pour vous. <command>patch</command> accepte les diffs en entrée
	  standard, et va tenter de modifier le fichier original, en fonction
	  des différences qui sont enregistrées dans le diff. Donc, par exemple,
	  si nous avons le fichier <filename>hello.c</filename>, et le patch
	  que nous avons produit précédemment basé sur les modifications entre
	  <filename>hello.c</filename> et
	  <filename>hello2.c</filename>, nous pouvons patcher
	  <filename>hello.c</filename> pour le rendre identique à son associé:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  Si vous avez <filename>hello2.c</filename>, vous pouvez vérifier que
	  les fichiers sont à présent identiques :
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  Il n'y a rien en sortie, donc c'est bien le cas. Une des
	  fonctionnalités intéressantes de <command>patch</command> est qu'elle
	  peut annuler les modifications faites à l'aide de diff, en utilisant
	  le paramètre <parameter class="command">-R</parameter> :
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  Dans ces exemples, le fichier original est patché. Parfois vous voulez
	  appliquer un patch sur un fichier avec un nom différent. Vous pouvez
	  le faire en fournissant le nom du fichier en tant que dernier
	  argument :
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  Vous pouvez aussi utiliser <command>patch</command> avec des diffs
	  qui ont été générés avec le paramètre <parameter
	  class="command">-r</parameter>, cependant vous devez prendre quelques
	  précautions. Supposez que l'entête d'un fichier particulier dans le
	  diff est ainsi :
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Si vous traitez ce diff avec <command>patch</command>, il va tenter
	  de modifier <filename>hello.c</filename>. Donc, le répertoire qui
	  contient ce fichier doit être le répertoire courant. Vous pouvez
	  utiliser le chemin d'accès complet avec <parameter
	  class="command">-p n</parameter>, où <emphasis>n</emphasis> est le
	  nombre de sous-répertoires composant le chemin qui doivent être
	  passés. Une valeur à <emphasis>0</emphasis> utilisera 
	  le chemin comme spécifié dans le patch,
	  <emphasis>1</emphasis> omettra le premier élément du chemin, etc.
	  Dans cet exemple, omettre le premier élément aura pour résultat le
	  patch de <filename>hello.c</filename>. Selon le standard Single UNIX
	  Specification version 3, le chemin qui est précédé par
	  <emphasis>---</emphasis> doit être utilisé pour construire le fichier
	  qui doit être patché. La version GNU de patch ne suit pas le standard
	  dans ce cas. Donc, c'est mieux d'omettre les éléments jusqu'à avoir
	  les 2 noms de répertoires identiques (habituellement le répertoire de
	  plus haut niveau dans le l'arborescence à modifier). Dans la plupart
	  des cas où on utilise des chemins relatif, on peut le faire en
	  utilisant <emphasis>-p 1</emphasis>. Par exemple :
	</para>

	<!-- XXX - add more examples for -p n -->

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  Ou vous pouvez utiliser le paramètre <parameter
	  class="command">-d</parameter> pour spécifier dans quel répertoire la
	  modification doit être appliquée :
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Si vous voulez conserver une sauvegarde lors de la modification d'un
	  fichier, vous pouvez utiliser le paramètre <parameter
	  class="command">-b</parameter> de <command>patch</command>.
	  Cela va créer une copie de chaque fichier concerné, nommée
	  <filename>filename.orig</filename>, avant d'effectuer réellement la
	  modification du fichier :
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Parfois un fichier ne peut pas être patché. Par exemple, s'il a déjà
	  été patché, s'il a trop changé pour appliquer le patch proprement, ou
	  si le fichier n'existe plus. Dans ce cas, les portions qui n'ont pas
	  pu être sauvées sont enregistrées dans un fichier nommé
	  <filename>filename.rej</filename>, où
	  <emphasis>filename</emphasis> est le fichier que
	  <command>patch</command> a tenté de modifier.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Expressions régulières</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Introduction</title>

      <para>Dans la vie de tous les jours, vous voudrez souvent manipuler du
	texte correspondant à un certain motif, plutôt qu'une chaîne de
	caractères litérale. Beaucoup d'utilitaires UNIX implémente un langage
	pour identifier des motifs de texte,
      <emphasis>les expressions regulières</emphasis> (regexps). Avec le temps
      le langage à expressions régulière a grandi, il a principalement à présent
      3 syntaxes d'expressions régulières : </para>

      <itemizedlist>
        <listitem>
          <para> Les expressions régulières traditionnelles UNIX. </para>
        </listitem>
        <listitem>
          <para> Les expressions régulières étendues POSIX. </para>
        </listitem>
        <listitem>
          <para> Les expressions régulières compatibles Perl (PCRE - NdT :
	    Perl-Compatible Regular Expressions). </para>
        </listitem>
      </itemizedlist>

      <para>
	Les expressions régulières POSIX sont principalement un surensemble des
	expressions régulières traditionnelles UNIX, et les PCREs un surensemble
	des expressions régulières POSIX. La syntaxe supportée par les
	applications diffèrent au cas par cas, mais à peu près toutes les
	applications supportent au moins les expressions régulières POSIX.
      </para>

      <para>
	Chaque unité syntaxique dans une expression régulière signifie une des
	choses suivantes :
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">Un caractère</emphasis> : c'est la base de
	    toute expression régulière, un caractère ou un ensemble de
	    caractères à trouver. Par exemple, la lettre <emphasis>p</emphasis>
	    ou le signe <emphasis>,</emphasis>. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Quantification</emphasis>: un quantifieur
	    spécifie combien de fois le caractère précédé ou l'ensemble de
	    caractère doivent être trouvés.</para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternative</emphasis>: l'alternative est
	    utilisée pour chercher <quote>a ou b</quote> où
	    <emphasis>a</emphasis> et <emphasis>b</emphasis> peuvent être un
	    caractère ou une expression régulière.</para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Groupement</emphasis>: ceci est utilisé pour
	    grouper des sous-expressions, afin de pouvoir appliquer une
	    quantification ou une alternative au groupe.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Expressions régulières traditionnelles d'UNIX</title>

      <para>
	Cette section décrit les expressions régulières traditionnelles UNIX.
	Vu le manque de standardisation, la syntaxe exacte peut sensiblement
	changer en fonction de l'utilitaire. D'habitude, la page de manuel
	d'une commande fournit des informations plus détaillées sur les
	expressions régulières basiques ou les expressions régulières
	supportées. Il est judicieux d'apprendre les expressions régulières
	traditionnelles, cependant il vaut mieux utiliser les expressions
	régulières POSIX pour vos propres scripts.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Chercher des caractères</title>

        <para>
	  Les caractères sont recherchés en tant que tels. Si un caractère
	  spécial est utilisé comme un caractère syntaxique pour les expressions
	  régulières, vous pouvez chercher ce caractère en ajoutant un
	  backslash. Par exemple, <emphasis>\+</emphasis> correspond au
	  caractère plus. </para>

        <para>
	  Un point (<emphasis>.</emphasis>) correspond à tout caractère, par
	  exemple, l'expression régulière <emphasis>b.g</emphasis> correspond à
	  <emphasis>bag</emphasis>, <emphasis>big</emphasis>, et
	  <emphasis>blg</emphasis>, mais pas à
	  <emphasis>bit</emphasis>. </para>

        <para>
	  Le caractère point, souvent, offre trop de liberté. Vous pouvez
	  utiliser les crochets (<emphasis>[]</emphasis>) pour spécifier la 
	  liste des caractères qui peuvent être cherchés. Par exemple,
	  l'expression régulière <emphasis>b[aei]g</emphasis> correspond à
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, et
	  <emphasis>big</emphasis>, mais rien d'autre. Vous pouvez chercher tout
	  caractère sauf les caractères d'un ensemble en utilisant les crochets,
	  et en utilisant l'accent circonflexe (<emphasis>^</emphasis>) en
	  premier caractère. Par exemple, <emphasis>b[^aei]g</emphasis>
	  correspond à toute chaîne de 3 caractères qui commence par
	  <emphasis>b</emphasis> et finit par <emphasis>g</emphasis>, sauf
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis>, et
	  <emphasis>big</emphasis>. Il est possible de chercher un intervalle
	  de caractères avec le tiret (<emphasis>-</emphasis>). Par exemple,
	  <emphasis>a[0-9]</emphasis> correspond à a suivi d'un seul caractère
	  numérique. </para>

        <para>
	  Deux caractères spéciaux, l'accent circonflexe
	  (<emphasis>^</emphasis>) et le symbole dollar
	  (<emphasis>$</emphasis>), correspondent respectivement au début et à
	  la fin d'une ligne. C'est très utile pour analyser les fichiers. Par
	  exemple, vous pouvez chercher toutes les lignes qui commencent par un
	  dièse (<emphasis>#</emphasis>) avec l'expression régulière
	  <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Quantification</title>

        <para>
	  Le signe le plus simple de quantification supporté par les
	  expressions régulières traditionnelles est l'astérisque
	  (<emphasis>*</emphasis>). Cela correspond à zéro ou plusieurs
	  instances du caractère précédent. Par exemple,
	  <emphasis>ba*</emphasis> correspond à <emphasis>b</emphasis>,
	  <emphasis>ba</emphasis><emphasis>baa</emphasis>, etc. Vous devez être
	  conscient que qu'un seul caractère suivi d'un astérisque hors contexte
	  correspond à toute chaine de caractères, car <emphasis>c*</emphasis>
	  correspond aussi à une chaîne de caractères qui contient zéro
	  caractère <emphasis>c</emphasis>. </para>

        <para>
	  Des répétitions plus restreintes peuvent être spécifiées à l'aide des
	  accolades préfixées par backslash. <emphasis>\{x,y\}</emphasis>
	  cherche le caractére précédent au moins <emphasis>x</emphasis> fois,
	  mais pas plus de <emphasis>y</emphasis> fois. Donc,
	  <emphasis>ba\{1,3\}</emphasis> correspond à
	  <emphasis>ba</emphasis>, <emphasis>baa</emphasis>, et
	  <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Groupement</title>

        <para>
	  Les parenthèses préfixées de backslash groupent plusieurs caractères
	  ensemble, afin d'ajouter de la quantification ou de l'alternative sur
	  un groupe de caractères. Par exemple,
	  <emphasis>\(ab\)\{1,3\}</emphasis> correspond à
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, et
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternative</title>

        <para>
	  La barre verticale préfixée de bacslash
	  (<emphasis>\|</emphasis>) vous permet de chercher une des 2
	  expressions. Ce n'est pas utile pour des caractères uniques, car
	  <emphasis>a\|b</emphasis> est équivalent à <emphasis>[ab]</emphasis>,
	  cependant c'est très utile combiné avec le groupement. Supposez que
	  vous voulez qu'une expression cherche <emphasis>apple</emphasis> et
	  <emphasis>pear</emphasis>, mais rien d'autre. Cela se fait facilement
	  avec la barre verticale :
	  <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>Expressions régulières étendues POSIX</title>

	<para>
	  Les expressions régulières étendues POSIX sont construites sur les
	  expressions régulières traditionnelles, plus quelques autres
	  primitives utiles. Une autre différence confortable est que les
	  parenthèses de groupement, les accolades de quantification, et le
	  signe d'alternative (<emphasis>|</emphasis>) ne sont pas backslashées.
	  S'ils sont backslashés, il correspondront plutôt aux caractères
	  litéraux, comportement opposé aux expressions régulières
	  traditionnelles. La plupart des gens trouvent les expressions
	  régulières étendues POSIX beaucoup plus confortables, faisant de
	  celles-ci les plus utilisées.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	  <title>Correspondance de caractères</title>

	  <para>
	    La correspondance des caractères normaux n'a pas changé comparé aux
	    expressions régulières traditionnelles décrites en <xref
	    linkend="chap-textproc-regexps-traditional-characters" />
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Quantification</title>

	  <para>
	    En plus de l'astérisque (<emphasis>*</emphasis>), qui correspond au
	    caractère ou groupe précédent zéro ou plusieurs fois, les
	    expresssions régulières étentues POSIX ajoutent 2 nouvelles
	    primitives simples de quantification. Le signe plus
	    (<emphasis>+</emphasis>) correspond au caractère ou groupe précédent
	    une ou plusieurs fois. Par exemple, <emphasis>a+</emphasis>,
	    correspond à <emphasis>a</emphasis> (ou toute chaîne de caractères
	    avec d'autres <emphasis>a</emphasis> consécutifs), mais ne
	    correspond pas à zéro <emphasis>a</emphasis>. Le caractère point
	    d'interrogation (<emphasis>?</emphasis>) correspond au caractère
	    précédent zéro ou une fois. Donc, <emphasis>ba?d</emphasis>
	    correspond à <emphasis>bd</emphasis> et <emphasis>bad</emphasis>,
	    mais pas <emphasis>baad</emphasis> ou <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Les accolades sont utilisées pour la répétition, comme pour les
	    expressions régulières traditionnelles. Cependant le backslash peut
	    être omis. Pour correspondre à <emphasis>ba</emphasis> et
	    <emphasis>baa</emphasis>, on doit utiliser
	    <emphasis>ba{1,2}</emphasis> plutôt que
	    <emphasis>ba\{1,2\}</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Groupement</title>

	  <para>
	    Le groupement se fait de la même manière que les expressions
	    régulières traditionnelles, sans les backslashes avant les
	    parenthèses. Par exemple, <emphasis>(ab){1,3}</emphasis> correspond
	    à <emphasis>ab</emphasis>, <emphasis>abab</emphasis>, et
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	  <title>Alternative</title>

	  <para>
	    L'alternative se fait de la même manière que les expressions
	    régulières traditionnelles,  sans les backslashes avant la barre
	    verticale. Donc, <emphasis>(apple)|(pear)</emphasis> correspond à
	    <emphasis>apple</emphasis> et <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

      <!--      
      <sect2 xml:id="chap-textproc-regexps-perl"> <title>Perl</title>
      </sect2>
    -->

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>

    <!-- XXX - document -c, -l, -x, -n, -q parameters -->

    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Utilisation de base de grep</title>

      <para>
	Nous sommes maintenant arrivés à un des outils les plus importants du
	système UNIX, et c'est la première occasion d'essayer et utiliser les
	expressions régulières. La commande <command>grep</command> est utilisée
	pour chercher un motif dans un flux de texte ou dans un fichier. Ce
	motif est une expression régulière, et peut être soit une expression
	régulière basique soit une expression régulière étendue POSIX (quand le
	paramètre <parameter class="command">-E</parameter> est utilisé). Par
	défaut, <command>grep</command> va écrire les lignes qui correspondent
	sur la sortie standard. Dans la syntaxe sous forme la plus basique, vous
	pouvez spécifier une expression régulière en argument, et
	<command>grep</command> va chercher les correspondances dans le texte
	de l'entrée standard. C'est une bonne manière de s'exercer un peu avec
	les expressions régulières.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	L'exemple ci-dessus montre une utlisation de base des expressions
	régulières en action, qui cherchent une ligne contenant uniquement 2 ou
	3 fois la chaîne <emphasis>ab</emphasis>. Vous pouvez faire la même
	chose avec les expressions régulières POSIX, en ajoutant le paramètre
	<parameter class="command">-E</parameter> (comme Etendu) :
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Puisque le comportement par défaut de <command>grep</command> est de
	lire depuis l'entrée standard, vous pouvez l'ajouter dans un pipeline
	pour obtenir les parties intéreressantes de la sortie de la commande
	précédente dans le pipeline. Par exemple, si vous désirez chercher une
	chaîne <emphasis>2006</emphasis> dans la troisième colonne d'un fichier,
	vous pouvez combiner les commandes <command>cut</command> et
	<command>grep</command> :
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>grep sur fichiers</title>

      <para>
	Naturellement, <command>grep</command> peut aussi lire directement un
	fichier, plutôt que l'entrée standard. Comme d'habitude, cela se fait en
	ajoutant les fichiers à lire en tant que derniers arguments. L'exemple
	suivant va afficher toutes les lignes du fichier
	<filename>/etc/passwd</filename> qui commencent par la chaîne
	<emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <!-- XXX - filename notation when multiple files are specified -->

      <para>
        Avec l'option <parameter class="command">-r</parameter>,
	<command>grep</command> va parcourir récursivement une arborescence de
	répertoires, essayant de trouver des correspondances dans chaque fichier
	rencontré durant le parcours.
	Cela dit, il est préférable de combiner <command>grep</command> avec
	<command>find</command> et l'opérande <emphasis>-exec</emphasis>
	dans les scripts qui doivent être portables.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	est l'équivalent fonctionnel non portable de
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Comportement des motifs</title>

      <para>
	<command>grep</command> peut aussi afficher toutes les lignes qui ne
	correspondent pas au motif utilisé. Cela se fait en ajoutant le
	paramètre <parameter class="command">-v</parameter> :
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	Si vous voulez utiliser le motif de façon insensible à la casse des
	caractères, vous pouvez ajouter le paramètre
	<parameter class="command">-i</parameter>. Par exemple :
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	Vous pouvez aussi chercher une chaîne de manière littérale avec le
	paramètre <parameter class="command">-F</parameter> :
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Utiliser plusieurs motifs</title>

      <para>
	Comme nous l'avons vu, vous pouvez utiliser le caractère d'alternative
	(<emphasis>|</emphasis>) pour chercher 2 ou plus sous-motifs. Si 2
	motifs que vous voulez trouver sont très différents, il est souvent plus
	confortable d'utiliser 2 motifs séparés. <command>grep</command> permet
	d'utiliser plus d'un motif en les séparant par un caractère de fin de
	ligne. Donc, par exemple, si vous désirez afficher les lignes qui
	correspondent soit au motif <emphasis>a</emphasis> ou au motif
	<emphasis>b</emphasis>, cela se fait aisément en démarrant par un
	caractère de fin de ligne :
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	Ca fonctionne, car des cotes sont utilisées, et le shell passe les
	paramètres les paramètres entre cotes littéralement. Cela dit, il faut
	admettre que ce n'est pas très élégant. <command>grep</command> accepte
	1 ou plusieurs paramètres
	<parameter class="command">-e motif</parameter>, permettant de spécifier
	plus d'un paramètre sur la même ligne. L'invocation de
	<command>grep</command> dans l'exemple précédent peut être réécrit :
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
