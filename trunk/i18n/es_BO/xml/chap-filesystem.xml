<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xl="http://www.w3.org/1999/xlink"
	 xml:lang="es"
	 xml:id="chap-filesystem">
  <title>Archivos y directorios</title>

  <sect1 xml:id="chap-filesystem-introduction">
    <title>Algo de teoría</title>

    <para>
      Antes de comenzar a ver las operaciones prácticas en el sistema
      de archivos, vamos a dar un vistazo a cómo funcionan los
      sistemas de archivos en sistemas UNIX-like.  Slackware Linux
      soporta diferentes sistemas de archivos, pero todos ellos
      utilizan esencialmente las mismas semánticas. Estas semánticas
      son proveídas a través de la capa de <emphasis>Sistema de
      Archivos Virtual</emphasis> (VFS, de sus siglas en inglés), que
      brinda una capa genérica para sistemas de archivos en disco o
      red.
    </para>

    <sect2 xml:id="chap-filesystem-introduction-atoms">
      <title>inodes, directorios y datos</title>

      <para>
	El sistema de archivos consiste en dos tipos de elementos:
	datos y metadatos. Los metadatos los bloques de datos que
	están en el disco. La mayoría de los sistemas de ficheros
	utilizan nodos de información (inodes, de sus palabras en
	inglés) para almacenar metadatos. Y generalmente almacenan los
	siguientes datos en sus inodes:
      </para>

      <table xml:id="chap-filesystem-introduction-atoms-inodes">
        <title>Campos comunes en inodes</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Campo</entry>
              <entry>Descripción</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>mode</entry>
              <entry>Permisos del archivo.</entry>
            </row>
            <row>
              <entry>uid</entry>
              <entry>ID de usuario del propietario del archivo.</entry>
            </row>
            <row>
              <entry>gid</entry>
              <entry>ID del grupo del archivo.</entry>
            </row>
            <row>
              <entry>size</entry>
              <entry>Tamaño en bytes del archivo.</entry>
            </row>
            <row>
              <entry>ctime</entry>
              <entry>Fecha de creación del archivo.</entry>
            </row>
            <row>
              <entry>mtime</entry>
              <entry>Fecha de la última modificación del archivo.</entry>
            </row>
            <row>
              <entry>links_count</entry>
              <entry>Número de enlaces apuntando a este inode.</entry>
            </row>
            <row>
              <entry>i_block</entry>
              <entry>Punteros a los bloques de datos.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Si no eres un aficionado UNIX o Linux, estos nombres deben
	estar sonando un poco extraños para ti, pero los
	esclareceremos en las secciones posteriores. En cualquier
	caso, ya puede deducir la relación entre inodes y datos a
	través de esta tabla, y específicamante el campo
	<emphasis>i_block</emphasis>: cada inode tiene punteros hacia
	los bloques de datos sobre los cuales el inode provee
	información. Juntos, el inode y los bloques de datos son el
	archivo en el sistema de archivos.
      </para>

      <para>
	Ahora tal vez quieras saber donde residen los nombres de
	archivos (y directorios), ya que no existe un campo 'nombre'
	en el inode. Actualmente, los nombres de archivo están
	separados del inode y los bloques de datos, esto te permite
	hacer groovy stuff, como dar a un mismo archivo más de un
	nombre. Los nombres de archivo son almacenados en algo
	denominado entradas de directorio. Estas entradas especifican
	el nombre y el inode del archivo. Debido a que los directorios
	también se representan a través de inodes, su estructura puede
	ser construída de esta forma.
      </para>

      <para>
	Podemos mostrar simplemente como todo esto trabaja ilustrando
	qué es lo que hace el kernel cuando ejecutamo el comando
	<command>cat /home/daniel/note.txt</command>
      </para>

      <orderedlist>
        <listitem>
	  <para>
	    El sistema lee el inodo del directorio
	    <filename>/</filename>, verifica si el usuario tiene
	    permitido acceder a este inodo y lee el bloque de datos
	    para hallar el número de inodo del directorio
	    <filename>home</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    El sistema lee el inodo del directorio
	    <filename>home</filename>, verifica si el usuario tiene
	    acceso a este inodo y lee el bloque de datos para hallar
	    el número de inodo del directorio
	    <filename>daniel</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    El sistema lee el inodo del directorio
	    <filename>daniel</filename>, verifica si el usuario tiene
	    acceso a este inodo y lee el bloque de datos para hallar
	    el número de inodo del archivo
	    <filename>note.txt</filename>.
	  </para>
        </listitem>
        <listitem>
          <para>
	    El sistema lee el inodo del archivo
	    <filename>note.txt</filename>, verifica si el usuario
	    tiene acceso a este inodo y retorna el bloque de datos a
	    <command>cat</command> a través de la llamada del sistema
	    <emphasis>read()</emphasis>.
	  </para>
        </listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="chap-filesystem-introduction-permissions">
      <title>Permisos de archivo</title>

      <para>
	Como hemos descrito previamente, Linux es un sistema
	multi-usuario. Esto significa que cada usuario tiene sus
	propios archivos (que estan usualmente localizados en el
	directorio home). Además, esos usuarios pueden ser miembros de
	un grupo, el cual puede dar al usuario privilegios
	adicionales.
      </para>

      <para>
	Como ha visto en la tabla de campos del inodo, cada archivo
	tiene un propietario y un grupo. El control de acceso
	tradicional en UNIX provee permisos de lectura, escritura, o
	ejecución al dueño del archivo, grupo del archivo y a otros
	usuarios. Estos permisos se almacenan en el campo
	<emphasis>mode</emphasis> de un inodo. El campo mode
	representa los permisos del archivo a un número octal de
	cuatro dígitos. El primer dígito representa algunas opciones
	especiales, el segundo dígito almacena los permisos del
	propietario, el tercero los permisos del grupo y el cuarto los
	permisos para otros usuarios. Los permisos se establecen por
	dígito usando o agregando uno de los números en <xref
	linkend="chap-filesystem-permissions-numbers"/>
      </para>

      <table xml:id="chap-filesystem-permissions-numbers">
        <title>Significado de los números en el octeto mode</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Número</entry>
              <entry>Significado</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>Ejecutar (x)</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>Escribir (w)</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>Leer (r)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Ahora, suponga que un archivo tiene el mode
	<emphasis>0644</emphasis>, esto significa que el archivo es
	leíble y escribible por el propietario
	(<emphasis>6</emphasis>) y leíble por el grupo del archivo
	(<emphasis>4</emphasis>) y otros
	(<emphasis>4</emphasis>). </para>

      <para>
	La mayoría de los usuarios no quieren tratar con números
	octales, por eso muchas utilidades también pueden usar una
	representación alfabética de los permisos de archivo. Las
	letras listadas entre parénteis en <xref
	linkend="chap-filesystem-permissions-numbers"/> son usadas en
	esta notación. En el siguiente ejemplo, se imprime la
	información sobre un archivo con permisos
	<emphasis>0644</emphasis>. Los números son reemplazados por
	tres tripletas rwx (el primer caracter lista opciones mode
	especiales).
      </para>

      <screen>
$ <userinput>ls -l note.txt</userinput>
-rw-r--r--  1 daniel daniel 5 Aug 28 19:39 note.txt
      </screen>

      <para>
	A través de los años, esto permisos UNIX tradicionales han
	probado no ser suficientes en algunos casos. La especificación
	POSIX 1003.1e tenía como objetivo extender el control de
	acceso UNIX con <emphasis>Listas de Control de
	Acceso</emphasis> (ACLs, Access Control
	Lists). Desafortunadamente este esfuerzo se estancó, sin
	embargo, algunos sistemas (como GNU/Linux) implementaron
	ACLs<footnote> <para>Al momento de esta redacción, ACLs son
	soportadas en sistemas de archivos ext2, ext3 y XFS</para>
	</footnote>. Las listas de control de acceso siguen la misma
	semántica de los permisos de archivo, pero dan la oportunidad
	de agregar tripletas <emphasis>rwx</emphasis> para usuarios y
	grupos adicionales.
      </para>

      <para>
	El siguiente ejemplo muestra las listas de control de acceso
	de un archivo. Como puede ver, los permisos se ven como
	permisos UNIX normales (los derechos de acceso para el
	usuario, grupo y otros estan especificados). Pero también hay
	una entrada adicional para el usuario
	<emphasis>joe</emphasis>.
      </para>

      <programlisting>
user::rwx
user:joe:r--
group::---
mask::r--
other::---
      </programlisting>

      <para>
	Para hacer las cosas aún mas complejas (y sofisticadas),
	algunos sistemas GNU/Linux agregan mas control de acceso
	refinado a través de Frameworks Obligatorios de Control de
	Acceso (Mandatory Access Control Frameworks, MAC) como SELinux
	y AppArmor.  Pero estos frameworks de control de acceso estan
	mas alla del alcance de este libro.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystems-introduction-links">
      <title>Enlaces</title>

      <para>
	Una entrada de directorio que apunta a un inodo es denominada
	<emphasis>enlace duro</emphasis>. La mayoría de los archivos
	son enlazados solamente una vez, pero nada le detiene de
	enlazar un archivo dos veces. Esto incrementará el campo
	<emphasis>links_count (contador de enlaces)</emphasis> del
	inodo.  Esta es una buena forma para el sistema de archivos de
	ver cuáles inodos y bloques de datos estan libres para su
	uso. Si link_count tiene el valor cero, el inodo ya no es
	referenciado y puede ser reclamado.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-hardlink">
        <title>Estructura de un enlace duro</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/hardlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/hardlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
	Los enlaces duros tienen dos limitantes. Primero, los enlaces
	duros no pueden enlazar entre sistemas de archivos, ya que
	ellos apuntan a inodos. Cada sistema de archivos tiene sus
	propios inodos y sus correspondientes números de inodo. Además
	de eso, la mayoría de los sistemas de archivos no le permiten
	crear enlaces duros a directorios. Permitiendo la creación de
	enlaces duros a directorios podría producir ciclos de
	directorios, encaminando a potenciales deadlocks e
	incosistencias en el sistema de archivos. En adición a eso, la
	mayoría de las implementaciones de <command>rm</command> y
	<command>rmdir</command> no saben como tratar con tales
	enlaces duros de directorio extras.
      </para>

      <para>
	Los <emphasis>enlaces simbólicos (Symbolic links)</emphasis>
	no tienen esas limitaciones, porque ellos apuntan a nombres de
	archivos en vez de inodos. Cuando un enlace simbólico es
	usado, el sistema operativo seguirá la ruta a ese enlace. Los
	enlaces simbólicos también pueden referirse a un archivo que
	no existe, ya que solamente contiene un nombre. Tales enlaces
	son llamados enlaces colgados.
      </para>

      <figure xml:id="chap-filesystems-introduction-links-symlink">
        <title>Estructura de un enlace simbólico</title>

        <mediaobject>
          <imageobject>
            <imagedata format="PNG" fileref="../../images/symlink.png"/>
          </imageobject>
          <imageobject>
            <imagedata format="SVG" fileref="../../images/symlink.svg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <note>
        <para>
	  Si alguna vez se interna en la administración del sistema,
	  es recomendable estar consciente de las implicaciones de
	  seguridad de los enlaces duros. Si el directorio
	  <filename>/home</filename> esta en el mismo sistema de
	  archivos que los binarios del sistema, un usuario será capaz
	  de crear enlaces duros a binarios. En el caso de que un
	  programa vulnerable es actualizado, el enlace en el
	  directorio home del usuario seguirá enlazando al viejo
	  binario del programa, dando efectivamente al usuario acceso
	  a un binario vulnerable.
	</para>

        <para>
	  Por esta razón es recomendable colocar cualquier directorio
	  en el que los usuarios puedan escribir en un sistema de
	  archivos diferente. En la práctica, esto significa que es
	  recomendable colocar al menos <filename>/home</filename> y
	  <filename>/tmp</filename> en sistemas de archivos separados.
        </para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystems-analyzing">
    <title>Analizando archivos</title>

    <para>
      Antes de entrar en lugares aventureros, empezaremos con el uso
      básico de archivos y directorios.
    </para>

    <sect2 xml:id="chap-filesystems-analyzing-listing">
      <title>Listando archivos</title>

      <para>
	Una de las cosas mas comunes que querrá hacer es listar
	ciertos archivos. El comando <command>ls</command> sirve muy
	bien a este propósito. Usando <command>ls</command> sin
	argumentos mostrará el contenido del directorio actual:
      </para>

      <screen>
$ <userinput>ls</userinput>
dns.txt  network-hosts.txt  papers
      </screen>

      <para>
	Si usa una distribución GNU/Linux, también podría querer ver
	una salida coloreada según el tipo de archivo. La salida
	estándar es útil para echar un vistazo al contenido del
	directorio, pero si quiere mas información, puede usar el
	parámetro <parameter class="command">-l</parameter>. Esto
	provee un denominado listado largo para cada archivo:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Esto brinda mucha mas información sobre las entradas del
	directorio que encontramos con <command>ls</command>. La
	primera columna muestra los permisos de archivo. La línea que
	muestra la entrada <filename>papers</filename> empieza con un
	<quote>d</quote>, esto significa que esta entrada representa
	un directorio. La segunda columna muestra el número de enlaces
	duros apuntando al inodo del directorio.  Si es mayor a 1, hay
	algún otro archivo para el mismo archivo.  Las entradas de
	directorio usualmente tienen al menos dos enlaces duros, el
	enlace al directorio padre y el enlace al mismo directorio
	(cada directorio tiene una entrada <filename>.</filename>, que
	se refiere al mismo directorio).  Las columnas tercera y
	cuarta listan el propietario del archivo y su grupo
	respectivamente. La quinta columna contiene el tamaño del
	archivo en bytes. La sexta columna contiene la última fecha de
	modificación del archivo. Y finalmente, la última columna
	muestra el nombre de la entrada.
      </para>

      <para>
	Los archivos que empiezan con un punto (.) no serán mostrado
	por la mayoría de las aplicaciones, incluída
	<command>ls</command>.  Puede listar estos archivos agregando
	la opción <parameter class="command">-a</parameter> a
	<command>ls</command>:
      </para>

      <screen>
$ <userinput>ls -la</userinput>
total 60
drwxrwxr-x   3 daniel daniel  4096 Sep 11 10:01 .
drwx------  88 daniel daniel  4096 Sep 11 10:01 ..
-rw-rw-r--   1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--   1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x   2 daniel daniel  4096 Sep  4 15:55 papers
-rw-rw-r--   1 daniel daniel     5 Sep 11 10:01 .settings
      </screen>

      <para>
	Como puede ver, tres entradas mas aparecieron. Antes que nada,
	el archivo <filename>.settings</filename> es mostrado ahora.
	Además de que ahora tiene dos entradas de directorio
	adicionales, <filename>.</filename> y
	<filename>..</filename>. Estas representan al directorio
	actual y al directorio padre respectivamente.
      </para>

      <para>
	Previamente en este capítulo (<xref
	linkend="chap-filesystem-introduction-atoms"/>) hablamos sobre
	inodos.  El número de inodo a la que una entrada de directorio
	apunta puede ser mostrada con el parámetro <parameter
	class="command">-i</parameter>. Sunponga que he creado un
	enlace duro al inodo que apunta al mismo inodo que
	<filename>dns.txt</filename>, ellos deberían tener el mismo
	número de inodo. La siguiente salida de <command>ls</command>
	muestra si esto es cierto:
      </para>

      <screen>
$ <userinput>ls -i dns*</userinput>
3162388 dns-newhardlink.txt
3162388 dns.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-file">
      <title>Determinando el tipo de archivo</title>

      <para>
	Algunas veces necesitará algo de ayuda para determinar el tipo
	de un archivo. Aquí es donde la utilidad
	<command>file</command> se vuelve útil. Suponga que he
	encontrado un archivo nombrado
	<filename>HelloWorld.class</filename> en algún lugar de mi
	disco.  Yo supongo que es un archivo que contiene bytecode
	Java, pero podemos usar <command>file</command> para verificar
	esto:
      </para>

      <screen>
$ <userinput>file HelloWorld.class</userinput>
HelloWorld.class: compiled Java class data, version 49.0
      </screen>

      <para>
	Es definitivamente bytecode Java. <command>file</command> es
	bastante inteligente y maneja la mayoría de las cosas que
	usted le da. Por ejemplo, podría pedirle proveer información
	sobre un nodo dispositivo:
      </para>

      <screen>
$ <userinput>file /dev/zero</userinput>
/dev/zero: character special (1/5)
      </screen>

      <para>
	O un enlace simbólico:
      </para>

      <screen>
$ <userinput>file /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: symbolic link to `Xorg'
      </screen>

      <para>
	Si usted esta interesado en el archivo que
	<filename>/usr/X11R6/bin/X</filename> enlaza, puede usar la
	opción <parameter class="command">-L</parameter> de
	<command>file</command>:
      </para>

      <screen>
$ <userinput>file -L /usr/X11R6/bin/X</userinput>
/usr/X11R6/bin/X: setuid writable, executable, regular file, no read permission
      </screen>

      <para>
	Usted podría preguntarse por qué <command>file</command> puede
	determinar el tipo de archivo relativamente fácilmente. La
	mayoría de los archivos empiezan con un denominado
	<emphasis>número mágico</emphasis>, este es un número único
	que le dice al programa que lo lee que tipo de archivo es. El
	programa <command>file</command> usa un archivo que describe
	muchos tipos de archivo y sus números mágicos. Por ejemplo, el
	archivo mágico en mi sistema de archivos contiene las
	siguientes líneas de una clase compilada Java:
      </para>

      <programlisting>
# Java ByteCode
# From Larry Schwimmer (schwim@cs.stanford.edu)
0       belong          0xcafebabe      compiled Java class data,
>6      beshort x       version %d.
>4      beshort x       \b%d
      </programlisting>

      <para>
	Esta entrada dice que si un archivo empieza con un
	númeromágico hexadecimal long (32-bit)
	<emphasis>0xcafebabe</emphasis><footnote> <para>Si, tambien
	puede ser creativo con números mágicos también!</para>
	</footnote>, es un archivo que contiene <quote>compiled Java
	class data</quote>.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-integrity">
      <title>Integridad de archivos</title>

      <para>
	Veremos verificación de integridad de archivos avanzada mas
	tarde, <!-- XXX xref --> mientras tanto tendremos un corto
	vistazo a la utilidad <command>cksum</command>.
	<command>cksum</command> puede calcular la verificación de
	redundancia cíclica (cyclic redundancy check,CRC) para un
	archivo de entrada. Este es un método pseudo-matemático para
	el cálculo de un número único para un archivo. Puede usar este
	número para verificar si un archivo fué modificado (por
	ejemplo, después de descargarlo desde un servidor web).  Puede
	especificar el archivo para el cual calcular el CRC como
	parámetro para <command>cksum</command>, y
	<command>cksum</command> imprimirá el CRC, el tamaño de
	archivo en bytes y el nombre del archivo.
      </para>

      <screen>
$ <userinput>cksum myfile</userinput>
1817811752 22638 myfile
      </screen>

      <para>
	Slackware Linux también provee utilidades para calcular sumas
	de verificación (checksums) basados en hashes de un sentido
	(por ejemplo MD5 o SHA-1).
	<!-- XXX - elaborate -->
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-viewing">
      <title>Visualización de archivos</title>

      <para>
	Ya que la mayoría de los sistemas UNIX son usualmente archivos
	de texto, ellos son fáciles de visualizar desde una terminal o
	emulador de terminal basado en caracteres.  La forma mas
	primitiva de ver el contenido de un archivo es usando
	<command>cat</command>. <command>cat</command> lee archivos
	que fueron especificados como parámetro línea por línea, y
	escribirá las líneas a la salida estándar. Entonces, puede
	escribir el contenido del archivo
	<filename>note.txt</filename> a la terminal con <command>cat
	note.txt</command>. Mientras algunos sistemas y la mayoría de
	los emuladores de terminales proveen soporte de
	desplazamiento, esta no es una forma práctica de ver archivos
	largos. Puede entubar la salida de <command>cat</command> al
	paginador <command>less</command>:
      </para>

      <screen>
$ <userinput>cat note.txt | less</userinput>
      </screen>

      <para>
	o deje <command>less</command> leer el archivo directamente:
      </para>

      <screen>
$ <userinput>less note.txt</userinput>
      </screen>

      <para>
	El paginador <command>less</command> le deja desplazarse hacia
	adelante o atrás a través de un archivo. <xref
	linkend="chap-filesystem-analyzing-viewing-less-keys"/> provee
	un resumen de las teclas mas importantes que son usadas para
	controlar <command>less</command>
      </para>

      <table xml:id="chap-filesystem-analyzing-viewing-less-keys">
        <title>teclas comando en less</title>

        <tgroup cols="2" colsep="1" rowsep="1">
          <thead>
            <row>
              <entry>Tecla</entry>
              <entry>Descripción</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>j</entry>
              <entry>Desplaza hacia adelante una línea.</entry>
            </row>
            <row>
              <entry>k</entry>
              <entry>Desplaza hacia atrás una linea.</entry>
            </row>
            <row>
              <entry>f</entry>
              <entry>Desplaza hacia adelante una pantalla de texto.</entry>
            </row>
            <row>
              <entry>b</entry>
              <entry>Desplaza hacia atrás una pantalla de texto.</entry>
            </row>
            <row>
              <entry>q</entry>
              <entry>Salir de less.</entry>
            </row>
            <row>
              <entry>g</entry>
              <entry>Saltar al inicio del archivo.</entry>
            </row>
            <row>
              <entry>G</entry>
              <entry>Saltar al final del archivo.</entry>
            </row>
            <row>
              <entry>/<emphasis>pattern</emphasis></entry>
              <entry>Busca el <emphasis>patrón</emphasis> de una <link
              xl:href="#chap-textproc-regexps">expresión
              regular</link>. </entry>
            </row>
            <row>
              <entry>n</entry>
              <entry>Busca la siguiente coincidencia la expresión
              regular previamente especificada.
              </entry>
            </row>
            <row>
              <entry>m<emphasis>letter</emphasis></entry>
              <entry>Marca la posición actual en el archivo con la
              <emphasis>letra</emphasis> especificada.
              </entry>
            </row>
            <row>
              <entry>'<emphasis>letter</emphasis></entry>
              <entry>Salta a la marca
              <emphasis>letra</emphasis></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>
	Las teclas comando que pueden ser cuantificados pueden ser
	prefijados por un número. Por ejemplo <emphasis>11j</emphasis>
	desplaza hacia adelante once líneas, y <emphasis>3n</emphasis>
	busca la tercera ocurrencia de la expresión regular
	previamente especificada.
      </para>

      <para>
	Slackware Linux también provee una alternativa a
	<command>less</command>, el viejo comando
	<command>more</command>.  No tocaremos <command>more</command>
	aquí, <command>less</command> es mas cómodo y también mas
	popular estos días.
      </para>

    </sect2>

    <sect2 xml:id="chap-filesystem-analyzing-filesize">
      <title>Tamaños de archivos y directorios</title>

      <para>
	La salida <command>ls -l</command> que hemos visto previamente
	provee información acerca del tamaño de un archivo. Mientras
	esto usualmente provee información suficiente sobre el tamaño
	de los archivos, usted podría querer reunir información sobre
	las colecciones de archivos y directorios.  Aquí es donde el
	comando <command>du</command> entra. Por defecto,
	<command>du</command> imprime el tamaño de archivos por
	directorio.  Por ejemplo:
      </para>

      <screen>
$ <userinput>du ~/qconcord</userinput>
72      /home/daniel/qconcord/src
24      /home/daniel/qconcord/ui
132     /home/daniel/qconcord
      </screen>

      <para>
	Por defecto, <command>du</command> representa el tamaño en
	unidades de 1024 bytes. Usted puede especificar que
	<command>du</command> debería usar unidades de 1024 bytes
	agregando la bandera <parameter class="command"
	>-k</parameter>. Esto es útil para scripts, porque algunos
	otros sistemas usan bloques de 512 bytes por defecto. Por
	ejemplo:
      </para>

      <screen>
$ <userinput>du -k ~/qconcord</userinput>
72	/home/daniel/qconcord/src
24	/home/daniel/qconcord/ui
132	/home/daniel/qconcord
      </screen>

      <para>
	Si también quisiera ver el uso de disco por archivo, puede
	agregar la bandera <parameter class="command">-a</parameter>:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord</userinput>
8       /home/daniel/qconcord/ChangeLog
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
12      /home/daniel/qconcord/Makefile
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
8       /home/daniel/qconcord/qconcord.pro
132     /home/daniel/qconcord
      </screen>

      <para>
	También puede usar el nombre de un archivo o un comodín como
	parámetro. Pero esto no imprimirá los tamaños de los archivos
	en sub-directorios, a menos que se use <parameter
	class="command">-a</parameter>:
      </para>

      <screen>
$ <userinput>du -k -a ~/qconcord/*</userinput>
8       /home/daniel/qconcord/ChangeLog
12      /home/daniel/qconcord/Makefile
8       /home/daniel/qconcord/qconcord.pro
8       /home/daniel/qconcord/src/concordanceform.h
8       /home/daniel/qconcord/src/textfile.cpp
12      /home/daniel/qconcord/src/concordancemainwindow.cpp
12      /home/daniel/qconcord/src/concordanceform.cpp
8       /home/daniel/qconcord/src/concordancemainwindow.h
8       /home/daniel/qconcord/src/main.cpp
8       /home/daniel/qconcord/src/textfile.h
72      /home/daniel/qconcord/src
16      /home/daniel/qconcord/ui/concordanceformbase.ui
24      /home/daniel/qconcord/ui
      </screen>

      <para>
	Si quiere ver el total de la suma del uso de disco de los
	archivos y sub-directorios que un directorio contiene, use la
	bandera <parameter class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>du -k -s ~/qconcord</userinput>
132     /home/daniel/qconcord
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-directories">
    <title>Trabajando con directorios</title>

    <para>
      Después de haber dado un vistazo de águila a los directorios en
      <xref linkend="chap-filesystem-introduction-atoms"/>, daremos un
      vistazo a algunos comandos relacionados a directorios.
    </para>

    <sect2 xml:id="chap-filesystem-directories-listing">
      <title>Listando directorios</title>

      <para>
	El comando <command>ls</command> que hemos visto en <xref
	linkend="chap-filesystems-analyzing-listing"/> también puede
	ser usado para listar directorios en diferentes formas.  Como
	hemos visto, la salida de <command>ls</command> por defecto
	incluye directorios, y los directorios pueden ser
	identificados usando la primera columna de un listado largo:
      </para>

      <screen>
$ <userinput>ls -l</userinput>
total 36
-rw-rw-r--  1 daniel daniel 12235 Sep  4 15:56 dns.txt
-rw-rw-r--  1 daniel daniel  7295 Sep  4 15:56 network-hosts.txt
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	Si se especifica un nombre de directorio, o comodines,
	<command>ls</command> listará el contenido del directorio, o
	los directorios que concuerden con el comodín. Por ejemplo, si
	hay un directorio <filename>papers</filename>, <command>ls
	paper*</command>. Esto es a veces molesto si solamente quiere
	ver las concordancias, y no el contenido de los directorios
	concordantes. <parameter class="command">-d</parameter> evita
	que esta recursión ocurra:
      </para>

      <screen>
$ <userinput>ls -ld paper*</userinput>
drwxrwxr-x  2 daniel daniel  4096 Sep  4 15:55 papers
      </screen>

      <para>
	También puede listar recursivamente el contenido de un
	directorio, y sus sub-directorios con el parámetro <parameter
	class="command">-R</parameter>:
      </para>

      <screen>
$ <userinput>ls -R</userinput>
.:
dns.txt  network-hosts.txt  papers

./papers:
cs  phil

./papers/cs:
entr.pdf

./papers/phil:
logics.pdf
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-directories-management">
      <title>Creando y removiendo directorios</title>

      <para>
	UNIX provee el comando <command>mkdir</command> para crear
	directorios. Si se especifica una ruta relativa, el directorio
	es creado en el directorio activo actual. La sintaxi básica es
	muy simple: <emphasis>mkdir &lt;name&gt;</emphasis>, por
	ejemplo:
      </para>

      <screen>
$ <userinput>mkdir mydir</userinput>
      </screen>

      <para>
	Por defecto, <command>mkdir</command> solamente crea un nivel
	de directorio. Entonces, si usa <command>mkdir</command> para
	crear <filename>mydir/mysubdir</filename>,
	<command>mkdir</command> fallará si <filename>mydir</filename>
	no existe previamente.  Si quisiera crear ambos directorios al
	mismo tiempo, use el parámetro <parameter
	class="command">-p</parameter>:
      </para>

      <screen>
$ <userinput>mkdir -p mydir/mysubdir</userinput>
      </screen>

      <para>
	<command>rmdir</command> remueve un directorio. Su
	comportamiento es comparable a
	<command>mkdir</command>. <command>rmdir
	mydir/mysubdir</command> remueve
	<filename>mydir/subdir</filename>, mientras que <command>rmdir
	-p mydir/mysubdir</command> remueve
	<filename>mydir/mysubdir</filename> y después
	<filename>mydir</filename>.
      </para>

      <para>
	Si un sub-directorio que queremos remover contiene entradas,
	<command>rmdir</command> fallará. Si quisiera remover un
	directorio, incluyendo todo su contenido, use el comando
	<command>rm</command>. <!-- XXX - xref -->
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-managing">
    <title>Administrando archivos y directorios</title>

    <sect2 xml:id="chap-filesystem-managing-copying">
      <title>Copiando</title>

      <para>
	Los archivos y directorios pueden ser copiados con el comando
	<command>cp</command>. En su sintaxis mas básica, los archivos
	origen y destino son especificados. El siguiente ejemplo
	copiará <filename>file1</filename> con el nombre
	<filename>file2</filename>:
      </para>

      <screen>
$ <userinput>cp file1 file2</userinput>
      </screen>

      <para>
	No es sorprendente que rutas relativas y absolutas también
	funcionan:
      </para>

      <screen>
$ <userinput>cp file1 somedir/file2</userinput>
$ <userinput>cp file1 /home/joe/design_documents/file2</userinput>
      </screen>

      <para>
	También puede especificar un directorio como segundo
	parámetro.  Si este es el caso, <command>cp</command> copiará
	el archivo en ese directorio, dándole el mismo nombre que el
	archivo original. Si hay mas de un parámetro, el último
	parámetro será usado como el directorio destino. Por ejemplo
      </para>

      <screen>
$ <userinput>cp file1 file2 somedir</userinput>
      </screen>

      <para>
	copiará <filename>file1</filename> y
	<filename>file2</filename> al directorio
	<filename>somedir</filename>. No es posible copiar múltiples
	archivos a un archivo. Para eso tendría que usar
	<command>cat</command>: <!-- XXX href -->
      </para>

      <screen>
$ <userinput>cat file1 file2 > combined_file</userinput>
      </screen>

      <para>
	También puede usar <command>cp</command> para copiar
	directorios, agregando el parámetro <parameter
	class="command">-R</parameter>.  Esto copiará recursivamente
	un directorio y todos sus sub-directorios. Si el directorio
	destino existe, el directorio o directorios origen serán
	copiados bajo el directorio destino.  Si el directorio destino
	no existe, será creado si solamente hay un solo directorio
	origen.
      </para>

      <screen>
$ <userinput>cp -r mytree tree_copy</userinput>
$ <userinput>mkdir trees</userinput>
$ <userinput>cp -r mytree trees</userinput>
      </screen>

      <para>
	Después de ejecutar estos comando, hay dos copias del
	directorio <filename>mytree</filename>,
	<filename>tree_copy</filename> y
	<filename>trees/mytree</filename>. Tratar de copiar estos
	directorios a un directorio destino inexistente fallará:
      </para>

      <screen>
$ <userinput>cp -R mytree mytree2 newdir</userinput>
usage: cp [-R [-H | -L | -P]] [-f | -i] [-pv] src target
       cp [-R [-H | -L | -P]] [-f | -i] [-pv] src1 ... srcN directory
      </screen>

      <note>
	<para>
	  Tradicionalmente, el parámetro <parameter
	  class="command">-r</parameter> a estado disponible en muchos
	  sistemas UNIX para copiar directorios recursivamente.  Sin
	  embargo, el comportamiento de este parámetro puede ser
	  dependiente de implementación, y el estándar Single UNIX
	  Specification version 3 indica que debería ser removido en
	  versiones futuras del estándar:
	</para>
      </note>

      <para>
	Cuando esta copiando archivos recursivamente, es recomendable
	especificar el comportamiento de qué <command>cp</command>
	debería hacer cuando se encuentra un enlace simbólico
	explícitamente, si quiere usar el comando
	<command>cp</command> en scripts portables. El estándar Single
	UNIX Specification version 3 no especifica cómo deberían ser
	manejados por defecto. Si <parameter
	class="command">-P</parameter> es usado, los enlaces
	simbólicos especificados como parámetro para
	<command>cp</command> pueden ser seguidos, dependiendo del
	tipo y contenido del archivo. Si <parameter
	class="command">-L</parameter> es usado, los enlaces
	simbólicos especificados como parámetro para
	<command>cp</command> y los enlaces simbólicos encontrados
	durante la copia recursiva podrían ser seguidos,
	dependendiendo del contenido del archivo.
      </para>

      <para>
	Si quiere preservar la propiedad, bit SGID/SUID y las fechas
	de modificación y acceso de un archivo, puede usar la bandera
	<parameter>-p</parameter>. Esto preservará estas propiedades
	en el archivo o directorio copiado.  Buenas implementaciones
	de <command>cp</command> también proveen protección adicional
	- si el archivo destino ya existe, puede que no sea
	sobreescrito si los metadatos relevantes no pueden ser
	preservados.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-moving">
      <title>Moviendo archivos y directorios</title>

      <para>
	El comando UNIX para mover archivos, <command>mv</command>,
	puede mover o renombrar archivos o directorios. Lo que
	realmente pasa depende de la ubicación de los archivos o
	directorios. Si los archivos de origen y destino están en el
	mismo sistema de archivos, <command>mv</command> usualmente
	crea nuevos enlaces duros, renombrando efectivamente los
	archivos y directorios. Si ambos se encuentran en sistemas de
	archivos diferentes, los archivos son copiados, y los archivos
	o directorios fuente se desenlazan.
      </para>

      <para>
	La sintaxis de <command>mv</command> es comparable a
	<command>cp</command>. La sintaxis mas básica renombra
	<filename>file1</filename> como <filename>file2</filename>:
      </para>

      <screen>
$ <userinput>mv file1 file2</userinput>
      </screen>

      <para>
	La misma sintaxis también puede ser usada para dos directorios
	de la misma forma, la cual renombrará el directorio dado como
	primer parámetro con el nombre dado como segundo parámetro.
      </para>

      <para>
	Cuando el último parámetro es un directorio existente, el
	archivo o directorio especificado como primer parámetro es
	copiado a ese directorio. En este caso puede especificar
	múltiples archivos o directorios de la misma forma. Por
	ejemplo:
      </para>

      <screen>
$ <userinput>mkdir targetdir</userinput>
$ <userinput>mv file1 directory1 targetdir</userinput>
      </screen>

      <para> This creates the directory <filename>targetdir</filename>, and moves
        <filename>file1</filename> and <filename>directory1</filename> to this directory. </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-managing-removing">
      <title>Eliminando archivos y directorios</title>

      <para>
	Los archivos y directorios pueden ser removidos con el comando
	<citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry>. Este comando
          desenlaza archivos y directorios. Si no existen mas enlaces
          a un archivo, su inodo y bloques de dico pueden ser
          reclamados para archivos nuevo. Los archivos pueden ser
          removidos al proveer los archivos como parámetro para
	<citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry>. Si el archivo no es escribible, <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> pedirá una confirmación. Por ejemplo, para remover
        <filename>file1</filename> y <filename>file2</filename>, puede ejecutar: 
      </para>

      <screen>
$ <userinput>rm file1 file2</userinput>
      </screen>

      <para>
	If you have to remove a large number of files that require a confirmation before they
        can be deleted, or if you want to use <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> to remove files
          from a script that will not be run on a terminal, add the
          <parameter class="command">-f</parameter> parameter to
          override the use of prompts. Files that are not writable,
          are deleted with the <filename>-f</filename> flag if the
          file ownership allows this. This parameter will also
          suppress printing of errors to <emphasis>stderr</emphasis>
          if a file that should be removed was not found. </para>

      <para> Directories can be removed recursively as well with the <parameter class="command"
        >-r</parameter> parameter. <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> will traverse the
          directory structure, unlinking and removing directories as
          they are encountered. The same semantics are used as when
          normal files are removed, as far as the <parameter
          class="command">-f</parameter> flag is concerned. To give a
          short example, you can recursively remove all files and
          directories in the <filename>notes</filename> directory
          with: </para>

      <screen>
$ <userinput>rm -r notes</userinput>
      </screen>

      <!-- XXX - describe -i flag? -->

      <para> 
	Ya que el comando <citerefentry>
          <refentrytitle>rm</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> usa la función <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum> </citerefentry> , los bloques de
          datos no son reescritos a un estado no inicializado. La
          información en los bloques de datos solamente se
          sobreescribe cuando son relocalizados y usados en un momento
          futuro. Para eliminar de forma segura archivos incluyendo
          sus bloques de datos, algunos sistemas proveen un comando
	<citerefentry>
          <refentrytitle>shred</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> que sobreescribe
          los bloques de datos con información aleatoria. Pero esto no
          es efectivo en muchos sistemas de archivos modernos
          (journaling), porque ellos no escriben datos en el lugar.
      </para>

      <para> 
	Los comandos <citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> proveen una
          implementación uno a uno de la función
	<citerefentry>
          <refentrytitle>unlink</refentrytitle>
          <manvolnum>2</manvolnum> </citerefentry>. Es de
          relativamente poco uso, porque no puede eliminar
          directorios. 
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-permissions">
    <title>Permisos</title>

    <para> 
      Tocamos el tema de permisos de archivos y directorios en <xref
      linkend="chap-filesystem-introduction-permissions"/>. En esta
      sección, daremos un vistazo a los comandos <citerefentry>
      <refentrytitle>chown</refentrytitle> <manvolnum>1</manvolnum>
      </citerefentry> and <citerefentry>
      <refentrytitle>chmod</refentrytitle> <manvolnum>1</manvolnum>
      </citerefentry>, que son usados para asignar la propiedad y
      permisos de archivos respectivamente.  Después de eso, vamos a
      ver una moderna extensión de permisos denominada Lista de
      Control de Acceso (Access Control Lists, ACLs).
    </para>

    <sect2 xml:id="chap-filesystem-permissions-ownership">
      <title>Cambiando la propiedad de un archivo</title>

      <para> 
	Como vimos previamente, cada archivo tiene un ID (usuario) e ID de grupo propietario almacenado 
	en el inodo. El comando <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> puede ser usado
          para asignar estos campos. Esto puede realizarse con IDs
          numéricos, o sus nombres. Por ejemplo, Para cambiar el
          propietario del archivo <filename>note.txt</filename> a
          <emphasis>john</emphasis>, y su grupo a
          <emphasis>staff</emphasis>, se usa el siguiente comando:
      </para>

      <screen>
$ <userinput>chown john:staff note.txt</userinput>
      </screen>

      <para> 
	También puede omitir uno de los componentes, para asignar
	solamente uno de los campos. Si quiere asignar el nombre de
	usuario, también puede omitir los puntos dobles. Entonces, el
	comando anterior puede ser separado en dos pasos:
      </para>

      <screen>
$ <userinput>chown john note.txt</userinput>
$ <userinput>chown :staff note.txt</userinput>
      </screen>

      <para> 
	Si quiere cambiar el propietario de un directorio, y de 
	todos los archivos y directorios que contiene, 
	puede agregar el parámetro <parameter class="command">-R</parameter> 
	a <citerefentry> <refentrytitle>chown</refentrytitle>
        <manvolnum>1</manvolnum> </citerefentry>:
      </para>

      <screen>
$ <userinput>chown -R john:staff notes</userinput>
      </screen>

      <para> 
	Si los nombres de usuario y grupo fueron especificados, en vez de los IDs, los nombres son 
	convertidos por <citerefentry>
          <refentrytitle>chown</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry>. Esta conversión
          usualmente recae en la amplia base de datos de contraseñas
          del sistema. Si esta operando en un sistema de archivos que
          usa otra base de datos de contraseñas (e.g. si monta un
          sistema de archivos de otro sistema para recuperación), a
          veces es útil cambiar la propiedad de un archivo por el ID
          de usuario o grupo. Entonces, el cambio de la propiedad de
          <filename>note</filename> a UID 1000 y GUID 1000 se realiza
          de la siguiente forma (predecible):
      </para>

      <screen>
$ <userinput>chown 1000:1000 note.txt</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-permbits">
      <title>Cambiando los bits de permisos de archivo</title>

      <para> 
	Después de leer la introducción a permisos de archivos en 
	<xref
          linkend="chap-filesystem-introduction-permissions"/>, cambiar los 
	bits de permisos de archivos almacenados en el inodo es realmente 
	fácil con el comando <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> command. <citerefentry>
          <refentrytitle>chmod</refentrytitle>
          <manvolnum>1</manvolnum> </citerefentry> acepta
          representaciones numéricas y simbólicas de permisos.
          Representar permisos de un archivo numéricamente es muy
          útil, porque permite la asignación efectiva de todos los
          permisos relevantes. Por ejemplo:
      </para>

      <screen>
$ <userinput>chmod 0644 note.txt</userinput>
      </screen>

      <para> 
	Hace a <filename>note.txt</filename> leíble y escribible para
	los dueños del archivo, y escribible para el grupo del archivo
	y otros.
      </para>

      <para> Symbolic permissions work with addition or subtraction of rights, and allow for
        relative changes of file permissions. The syntax for symbolic permissions is: </para>

      <screen>
[ugo][-+][rwxst]
      </screen>

      <para> 
	El primer componente específica las clases de usuario para los
	cuales el cambio de permiso aplica (usuario, grupos y
	otros). Se pueden combinar múltiples caracteres de este
	componente. El segundo componente quita
	(<emphasis>-</emphasis>), o agrega (<emphasis>+</emphasis>)
	permisos. El tercer componente es el especificador de acceso
	(lectura, escritura, ejecución, UID/GID de ejecución, pegajoso). También
	se pueden especificar múltiples componentes para este
	componente. Veámos algunos ejemplos para clarificar esto:
      </para>

      <screen>
ug+rw        # Give read/write rights to the file user and group
chmod go-x   # Take away execute rights from the file group and others.
chmod ugo-wx # Disallow all user classes to write to the file and to
             # execute the file.
      </screen>

      <para> Estos comandos pueden ser usados de la siguiente forma
      con chmod: </para>

      <screen>
$ <userinput>chmod ug+rw note.txt</userinput>
$ <userinput>chmod go-x script1.sh</userinput>
$ <userinput>chmod ugo-x script2.sh</userinput>
      </screen>

      <para> Permissions of files and directories can be changed recursively with the <parameter
          class="command">-R</parameter>. The following command makes the directory
        <filename>notes</filename> world-readable, including its contents: </para>

      <screen>
$ <userinput>chmod -R ugo+r notes</userinput>
      </screen>

      <para> 
	Se debe tener cuidado extra con directorios, porque la bandera
	<emphasis>x</emphasis> tiene un significado especial en un
	contexto de directorio. Lo usuarios que tienen permisos de
	ejecución en directorios pueden acceder un
	directorio. Usuarios que no tienen permisos de ejecución en un
	directorio no. Debido a su comportamiento particular, a veces
	es mas sencillo cambiar los permisos de una estructura de
	directorio y sus archivos con la ayuda del comando
	<citerefentry>
          <refentrytitle>find</refentrytitle>
          <manvolnum>1</manvolnum>
        </citerefentry> command <!-- XXX xref -->. 
      </para>

      <para> 
	Hay algunos bits extra de permisos que pueden ser asignados
	que tiene un significado especial.  Los SUID y SGID son los
	bits mas interesantes de estos bits extra. Estos bits cambian
	el ID del grupo o usuario activo con el propietaro o grupo del
	archivo cuando el archivo es ejecutado. El comando
	<command>su(1)</command> es un buen ejemplo de un archivo que
	usualmente tiene el bit SUID asignado:
      </para>

      <screen>
$ <userinput>ls -l /bin/su</userinput>
-rwsr-xr-x  1 root root 60772 Aug 13 12:26 /bin/su
      </screen>

      <para> 
	Esto significa que el comando<command>su</command> se ejecuta
	como el usuario <emphasis>root</emphasis> cuando es
	ejecutado. El bit SUID puede ser asignado con el modificador
	<emphasis>s</emphasis>. Por ejemplo, si el bit SUID no fué
	asignado en <filename>/bin/su</filename>, esto puede hacerse
	con:
      </para>

      <screen>
$ <userinput>chmod u+s /bin/su</userinput>
      </screen>

      <note>
        <para> 
	Por favor sea consciente de que los bits SUID y SGID tienen
	implicaciones de seguridad. Si un programa con estos bits
	asignados contienen un bug, puede ser explotado para obtener
	los privilegios del propietario o grupo del archivo. Por esta
	razón, es recomendable mantener el número de archivos con los
	bits SUID y SGID asignados a un mínimo absoluto.
	</para>
      </note>

      <para> 
	El bit pegajoso (sticky) es también interesante cuando se
	refiere a un directorio. Le prohíbe a los usuarios renombrar o
	desenlazar archivos que lo les pertenecen, en directorios en
	los que tienen permiso de escritura. Esto es usualmente usado
	en directorios globalmente escribibles, como el directorio
	temporal (<filename>/tmp</filename>) en muchos sistemas
	UNIX. El tag sticky puede asignarse con el modificador
	<emphasis>t</emphasis>:
      </para>

      <screen>
$ <userinput>chmod g+t /tmp</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-umask">
      <title>Máscara de creación de archivo</title>

      <para>
	La pregunta que queda pendiente es qué permisos iniciales son
	usados cuando un archivo es creado. Esto depende de dos
	factores: la flag mode (mode) que fué pasada a la llamada del
	sistema <emphasis>open(2)</emphasis>, que es usada para crear
	un archivo y la máscara de creación de archivo. La máscara de
	creación de archivo puede ser representada como un número
	octal. Los permisos efectivos para crear el archivo son
	determinados como <emphasis>mode &amp; ~mask</emphasis>. Ó, si
	esta representado en una forma octal, puede sustraer los
	dígitos de la máscara desde el mode. Por ejemplo, si un
	archivo es creado con los permisos <emphasis>0666</emphasis>
	(leíble y escribible por el usuario del archivo, grupo de
	archivo y otros), y la máscara efectiva de creación de archivo
	es <emphasis>0022</emphasis>, los permisos efectivos del
	archivo serán <emphasis>0644</emphasis>.  Veámos un
	ejemplo. Suponga que los archivos aún son creados con los
	permisos <emphasis>0666</emphasis>, que usted es un paranoico,
	y que quiere quitar todos los permisos de lectura y escritura
	para el grupo y para otros. Esto significa que debe asignar la
	máscara de creación de archivo a <emphasis>0066</emphasis>,
	porque sustrayendo <emphasis>0066</emphasis> desde
	<emphasis>0666</emphasis> produce <emphasis>0600</emphasis>.
      </para>
      
      <para>
	La máscara efectiva de creación de archivo puede ser
	consultada y configurada con el comando
	<command>umask</command>, que es normalmente un comando
	incluído con el sistema. La máscara efectiva puede imprimirse
	ejecutando <command>umask</command> sin parámetros:
      </para>
      
      <screen>
$ <userinput>umask</userinput>
0002
      </screen>
      
      <para>
	La máscara puede ser configurada dando el número de máscara
	octal como parámetro. Por ejemplo:
      </para>
      
      <screen>
$ <userinput>umask 0066</userinput>
      </screen>
      
      <para>
	Podemos verificar que esto funciona creando un archivo vacio:
      </para>
      
      <screen>
$ <userinput>touch test</userinput>
$ <userinput>ls -l test</userinput>
-rw-------  1 daniel daniel 0 Oct 24 00:10 test2
      </screen>
      
    </sect2>

    <sect2 xml:id="chap-filesystem-permissions-acl">
      <title>Listas de Control de Acceso</title>

      <para>
	Las Listas de Control de Acceso (<acronym>ACL</acronym>s) son
	una extensión de los permisos tradicionales UNIX, que permiten
	un control de acceso refinado. La mayoría de los sistemas que
	soportan ACLs en el sistema de archivos las implementan como
	están descritas en las especificaciones de borrador POSIX.1e y
	POSIX.2c. Sisteman UNIX notables que implementan ACLs de
	acuerdo a este borrador son FreeBSD, Solaris y Linux.
      </para>

      <para>
	Como vimos en <xref
	linkend="chap-filesystem-introduction-permissions" />, las
	listas de control de acceso le permiten usar tripletas de
	lectura, escritura y ejecución para grupos y usuarios
	adicionales. En contraste con los permisos tradicionales, las
	listas de control adicionales no se almacenan directamente en
	el nodo, sino en atributos extendidos que son asociados con
	archivos. Dos cosas que se deben tener en cuenta cuando use
	listas de control de acceso, no todos los sistemas las
	soportan, y no todos los programas las soportan.
      </para>

      <sect3 xml:id="chap-filesystem-permissions-acl-reading">
	<title>Leyendo listas de control de acceso</title>

	<para>
	  En la mayoría de los sistemas que soportan ACLs,
	  <command>ls</command> usa un indicador virtual para mostrar
	  que hay ACLs asociadas con un archivo. Por ejemplo:
	</para>

	<screen>
$ <userinput>ls -l index.html</userinput>
-rw-r-----+ 1 daniel daniel 3254 2006-10-31 17:11 index.html
	</screen>

	<para>
	  Como puede ver, la columna de permisos muestra un signo más
	  (<emphasis>+</emphasis>) adicional. Los bits de permisos no
	  actúan exactamente como uno esperaría. Veremos eso en un
	  minuto.
	</para>

	<para>
	  Las ACLs para un archivo pueden ser consultadas con el
	  comando <command>getfacl</command>:
	</para>

	<screen>
$ <userinput>getfacl index.html</userinput>
# file: index.html
# owner: daniel
# group: daniel
user::rw-
group::---
group:www-data:r--
mask::r--
other::---
	</screen>

	<para>
	  La mayoría de las línes pueden ser interpretadas de forma
	  sencilla: el usuario del archivo tiene permisos de
	  lectura/escritura, el grupo del archivo no tiene permisos,
	  usuarios del grupo <emphasis>www-data</emphasis> tienen
	  permisos de lectura y otros usuarios no tienen permisos en
	  absoluto. Pero, por qué la entrada del grupo no lista
	  permisos para grupo del archivo, mientras
	  <command>ls</command> lo hace?. El secreto es que si hay una
	  entrada <emphasis>máscara (mask)</emphasis>,
	  <command>ls</command> muestra el valor de la máscara, en vez
	  de los permisos del grupo del archivo.
	</para>

	<para>
	  La entrada <emphasis>mask</emphasis> es usada para
	  restringir todas las entradas de lista con la excepción de
	  las entradas del usuario del archivo, y las de otros
	  usuarios. Lo mejor es memorizar las siguientes reglas para
	  interpretar ACLs:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Los permisos de la entrada <emphasis>user::</emphasis>
	      corresponden a los permisos del dueño del archivo.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Los permisos de la entrada <emphasis>group::</emphasis>
	      corresponden a los permisos del grupo del archivo, a
	      menos que haya una entrada <emphasis>mask::</emphasis>.
	      Si hay una entrada <emphasis>mask::</emphasis>, los
	      permisos del grupo corresponden a la entrada del grupo
	      con la entrada máscara como el máximo de permisos
	      permitidos (significando que las restricciones del grupo
	      pueden ser más estrictas, pero no más permisivas).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Los permisos de otros usuarios y grupos corresponden a
	      sus entradas <emphasis>user:</emphasis> y
	      <emphasis>group:</emphasis>, con el valor de
	      <emphasis>mask::</emphasis> como sus permisos máximos.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Las reglas segunda y tercera pueden ser claramente
	  observadas si hay un usuario o grupo que tiene mas permisos
	  que la máscara para el archivo:
	</para>

	<screen>
$ <userinput>getfacl links.html</userinput>
# file: links.html
# owner: daniel
# group: daniel
user::rw-
group::rw-                      #effective:r--
group:www-data:rw-              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Aunque los permisos de lectura y escritura estan
	  especificados para los grupos del archivo y
	  <emphasis>www-data</emphasis>, ambos grupos solamente
	  tendrán permisos efectivos de lectura, porque este es el
	  máximo de permisos que la máscara permite.
	</para>

	<para>
	  Otro aspecto a prestar atención es el manejo de ACLs en
	  directorios.  Las listas de control de accesso pueden ser
	  agregadas a los directorios para gobernar el acceso, pero
	  los directorios también tienen <emphasis>ACLs por
	  defecto</emphasis>, las cuales especifican las ACLs
	  iniciales para archivos y directorios creados bajo ese
	  directorio.
	</para>

	<para>
	  Suponga que el directorio <filename>reports</filename> tiene
	  la siguiente ACL:
	</para>

	<screen>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
group:www-data:r-x
mask::r-x
other::---
default:user::rwx
default:group::r-x
default:group:www-data:r-x
default:mask::r-x
default:other::---
	</screen>

	<para>
	  Los archivos nuevos que son creados en el directorio
	  <filename>reports</filename>, obtienen una ACL basada en las
	  entradas que tienen <emphasis>default:</emphasis> como
	  prefijo. Por ejemplo:
	</para>

	<screen>
$ touch reports/test
$ getfacl reports/test
# file: reports/test
# owner: daniel
# group: daniel
user::rw-
group::r-x                      #effective:r--
group:www-data:r-x              #effective:r--
mask::r--
other::---
	</screen>

	<para>
	  Como puede ver, la ACL por defecto fué copiada. El bit de
	  ejecución es removido de la máscara, porque el nuevo archivo
	  no fué creado con permisos de ejecución.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-permissions-acl-setting">
	<title> Creando listas de control de acceso</title>

	<para>
	  La ACL para un archivo o directorio puede ser cambiada con
	  el programa <command>setfacl</command>. Desafortunadamente,
	  el uso de este programa estrictamente depende del sistema
	  donde este siendo usado. Para aumentar la confusión, al
	  menos una bandera importante (<parameter
	  class="command">-d</parameter>) tiene significados
	  diferentes en sistemas diferentes. Uno solamente puede tener
	  esperanza de que este comando sea estandarizado.
	</para>

	<table xml:id="chap-filesystem-permissions-acl-setting-flags">
	  <title>Banderas específicas del sistema <command>setfacl</command></title>
	  
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Operación</entry>
		<entry>Linux</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Asignar entradas, removiendo todas las entradas
		antiguas</entry>
		<entry><parameter class="command">--set</parameter></entry>
	      </row>
	      <row>
		<entry>Modificar entradas</entry>
		<entry><parameter class="command">-m</parameter></entry>
	      </row>
	      <row>
		<entry>Modificar entradas ACL por defecto</entry>
		<entry><parameter class="command">-d</parameter></entry>
	      </row>
	      <row>
		<entry>Eliminar entrada</entry>
		<entry><parameter class="command">-x</parameter></entry>
	      </row>
	      <row>
		<entry>
		  Remover todas las entradas ACL (exceptuando las tres
		  entradas requeridas).
		</entry>
		<entry><parameter class="command">-b</parameter></entry>
	      </row>
	      <row>
		<entry>Recalcular la máscara</entry>
		<entry>
		  Se recalcula siempre, a menos que se use el
		  parámetro <parameter class="command">-n</parameter>,
		  o una entrada de máscara explícitamente
		  especificada.
		</entry>
	      </row>
	      <row>
		<entry>Usar una especificación ACL desde un
		archivo</entry>
		<entry>
		  <parameter class="command">-M</parameter>
		  (modificar), <parameter
		  class="command">-X</parameter> (eliminar), o
		  <parameter class="command">--restore</parameter> (restaurar)
		</entry>
	      </row>
	      <row>
		<entry>Eliminación recursiva de ACLs</entry>
		<entry><parameter class="command">-R</parameter></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Como vimos en la sección previa, las entradas pueden ser
	  especificadas para usuarios y grupos, usando la siguiente
	  sintaxis: <emphasis>user/group:name:permissions</emphasis>.
	  Los permisos puede ser especificados como una tripleta
	  usando las letras <emphasis>r</emphasis> (lectura),
	  <emphasis>w</emphasis> (escritura), o <emphasis>x</emphasis>
	  (ejecución). Se debería usar un guión
	  (<emphasis>-</emphasis>) para permisos que no se quieren dar
	  al usuario o grupo, ya que Solaris requiere esto. Si quiere
	  prohibir el acceso completamente, puede usar la tripleta
	  <emphasis>---</emphasis>.
	</para>

	<para>
	  La especificación para otros usuarios y la máscara siguen
	  este formato : <emphasis>other:r-x</emphasis>. El siguiente
	  formato ligeramente predecible también puede ser usado:
	  <emphasis>other::r-x</emphasis>.
	</para>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-modify">
	  <title>Modificando entradas ACL</title>

	  <para>
	    La operación mas simple es modificar una entrada ACL. Esto
	    creará una nueva entrada si la entrada no existe aún. Las
	    entrada pueden ser modificadas con <parameter
	    class="command">-m</parameter>. Por ejemplo, suponga que
	    quiere dar al grupo <emphasis>friend</emphasis> acceso de
	    lectura y escritura al archivo
	    <filename>report.txt</filename>. Esto puede hacerse con:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw- report.txt</userinput>
	  </screen>

	  <para>
	    La entrada máscara será recalculada, configurándola a la
	    unión de todas las entradas de grupo y entradas
	    adicionales de grupo:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt</userinput>
# file: report.txt
# owner: daniel
# group: daniel
user::rw-
group::r--
group:friends:rw-
mask::rw-
other::r--
	  </screen>

	  <para>
	    Puede combinar múltiples entradas ACL separándolas con
	    comas. Por ejemplo:
	  </para>

	  <screen>
$ <userinput>setfacl -m group:friends:rw-,group:foes:--- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-removing">
	  <title>Removiendo entradas ACL</title>

	  <para>
	    Una entrada puede ser removida con la opción <parameter
	    class="command">-x</parameter>:
	  </para>

	  <screen>
$ <userinput>setfacl -x group:friends: report.txt</userinput>
	  </screen>

	  <para>
	    El punto doble al final es opcional y puede ser omitido.
	  </para>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-new">
	  <title>Creando un ACL nuevo</title>

	  <para>
	    La opción <parameter class="command">--set</parameter> es
	    proveída para crear una nueva lista de control de acceso
	    para un archivo, eliminando todas las entradas existentes,
	    a excepción de las tres entradas requeridas. Es requerido
	    que el usuario de archivo, grupo y otras entradas también
	    sean especificadas. Por ejemplo:
	  </para>

	  <screen>
$ <userinput>setfacl --set user::rw-,group::r--,other:---,group:friends:rwx report.txt</userinput>
	  </screen>

	  <para>
	    Si no quiere eliminar los permisos de usuario, grupo y
	    otros, pero quiere eliminar todas las demas entradas ACL,
	    puede usar la opción <parameter
	    class="command">-b</parameter>. El siguiente ejemplo usa
	    esta combinación con la opción <parameter
	    class="command">-m</parameter> para eliminar todas las
	    entradas ACL (excepto las de usuario, grupo y otros), y
	    puede agregar una entrada para el grupo
	    <emphasis>friends</emphasis>:
	  </para>

	  <screen>
$ <userinput>setfacl -b -m group:friends:rw- report.txt</userinput>
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-default">
	  <title>Asignando una ACL por defecto</title>

	  <para>
	    Como vimos en <xref
	    linkend="chap-filesystem-permissions-acl" />, los
	    directorios pueden tener entradas ACL por defecto que
	    especifican qué permisos deberían ser usados para archivos
	    y directorios que son creados bajo ese directorio. La
	    opción <parameter class="command">-d</parameter> es usada
	    para operar en entradas por defecto:
	  </para>

	  <screen>
$ <userinput>setfacl -d -m group:friends:rwx reports</userinput>
$ <userinput>getfacl reports</userinput>
# file: reports
# owner: daniel
# group: daniel
user::rwx
group::r-x
other::r-x
default:user::rwx
default:group::r-x
default:group:friends:rwx
default:mask::rwx
default:other::r-x
	  </screen>
	</sect4>

	<sect4 xml:id="chap-filesystem-permissions-acl-setting-filesource">
	  <title>Usando una ACL desde un archivo de referencia</title>

	  <para>
	    También puede usar una especificación ACL desde un
	    archivo, en vez de especificarlo en la línea de
	    comandos. Un archivo de entrada sigue la siguiente
	    sintaxis para especificar entradas como parámetro para
	    <command>setfacl</command>, pero las entradas son
	    separadas por líneas nuevas en vez de comas.  Esto es muy
	    útil, porque puede usar la ACL de un archivo existente
	    como referencia:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt > ref</userinput>
	  </screen>

	  <para>
	    La opción <parameter class="command">-M</parameter> es
	    proveída para modificar la ACL para una archivo, leyendo
	    las entradas desde un archivo. Entonces, si tiene un
	    archivo nombrado <filename>report2.txt</filename>, podemos
	    modificar la ACL para este archivo con las entradas desde
	    <filename>ref</filename> con:
	  </para>

	  <screen>
$ <userinput>setfacl -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Si quisiera empezar con una ACL limpia y agregar las
	    entradas desde <filename>ref</filename>, puede agregar la
	    bandera <parameter class="command">-b</parameter> que
	    encontramos previamente:
	  </para>

	  <screen>
$ <userinput>setfacl -b -M ref report2.txt</userinput>
	  </screen>

	  <para>
	    Por supuesto, no es necesario usar este archivo
	    provisional. Podemos entubar directamente la salida de
	    <command>getfacl</command> hacia
	    <command>setfacl</command>, usando el nombre simbólico de
	    la entrada estándar (<emphasis>-</emphasis>), en vez del
	    nombre de un archivo:
	  </para>

	  <screen>
$ <userinput>getfacl report.txt | setfacl -b -M - report2.txt</userinput>
	  </screen>

	  <para>
	    El parámetro <parameter class="command">-X</parameter>
	    remueve las entradas ACL definidas en una archivo. Esto
	    sigue la misma sintaxis de la bandera <parameter
	    class="command">-x</parameter>, con comas reemplazadas por
	    nuevas líneas.
	  </para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-filesystem-finding">
    <title>Encontrando archivos</title>

    <sect2 xml:id="chap-filesystem-finding-find">
      <title>find</title>

      <para>
	El comando <command>find</command> e sin duda la utilidad mas
	comprensiva para encontrar archivos en sistemas UNIX.  Además
	que trabaja en una forma simple y predecible:
	<command>find</command> navegará a través del arbol o árboles
	de directorios que son especificados como parámetro para
	<command>find</command>. Además de eso, un usuario puede
	especificar una expresión que será evaluada para cada archivo
	y directorio. El nombre de un archivo o directorio será
	impreso si la expresión evalúa con resultado
	<emphasis>true</emphasis>.  El primer argumento que empieza
	con un guión (<emphasis>-</emphasis>), un símbolo de
	exclamación (<emphasis>!</emphasis>), o un paréntesis de
	apertura (<emphasis>(</emphasis>), indica el inicio de la
	expresión. La expresión puede consistir en varios operandos.
	Para envolverlos, la sintaxis de <command>find</command> es:
	<emphasis>find paths expression</emphasis>.
      </para>

      <para>
	El uso mas simple de <command>find</command> es no usar
	expresiones.  Ya que esto iguala cada entrada de directorio y
	sub-directorio, todos lo archivo y directorios serán
	impresos. Por ejemplo:
      </para>

      <screen>
$ <userinput>find .</userinput>
.
./economic
./economic/report.txt
./economic/report2.txt
./technical
./technical/report2.txt
./technical/report.txt
      </screen>

      <para>
	También puede especificar múltiples directorios:
      </para>

      <screen>
$ <userinput>find economic technical</userinput>
economic
economic/report.txt
economic/report2.txt
technical
technical/report2.txt
technical/report.txt
      </screen>

      <sect3 xml:id="chap-filesystem-finding-find-nametype">
	<title>Operandos que limitan por nombre o tipo de objeto</title>

	<para>
	  Un escenario común para encontrar archivos o directorios es
	  buscarlos por nombre. El operando <emphasis>-name</emphasis>
	  puede ser usado para igualar objetos que tienen cierto
	  nombre, o igualan un comodín en particular. Por ejemplo,
	  usar el operando <emphasis>-name 'report.txt'</emphasis>
	  solamente será verdadero para archivos y directorios con el
	  nombre <filename>report.txt</filename>. Por ejemplo:
	</para>

	<screen>
$ <userinput>find economic technical -name 'report.txt'</userinput>
economic/report.txt
technical/report.txt
	</screen>

	<para>
	  Lo mismo aplica para comodines:
	</para>

	<screen>
$ <userinput>find economic technical -name '*2.txt'</userinput>
economic/report2.txt
technical/report2.txt
	</screen>

	<note>
	  <para>
	    Cuando este usando <command>find</command>, querrá pasar
	    los comodines al comando <command>find</command>, en vez
	    de dejar que la consola lo expanda. Entonces, asegúrese
	    que los patrones esten entre comillas, o que los comodines
	    esten acompañados de caracteres de escape.
	  </para>
	</note>

	<para>
	  También es posible evaluar el tipo de objeto con el operando
	  <emphasis>-type c</emphasis>, donde <emphasis>c</emphasis>
	  especifica el tipo a ser igualado.  <xref
	  linkend="chap-filesystem-finding-find-nametype-type-params"
	  /> lista los varios tipos de objeto que pueden ser usados.
	</para>

	<table xml:id="chap-filesystem-finding-find-nametype-type-params">
	  <title>Parámetros para el operando '-type'</title>

	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Parámetro</entry><entry>Significado</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>b</entry><entry>Archivo de dispositivo de bloque</entry>
	      </row>
	      <row>
		<entry>c</entry><entry>Archivo de dispositivo de caracter</entry>
	      </row>
	      <row>
		<entry>d</entry><entry>Directorio</entry>
	      </row>
	      <row>
		<entry>f</entry><entry>Archivo regular</entry>
	      </row>
	      <row>
		<entry>l</entry><entry>Enlace simbólico</entry>
	      </row>
	      <row>
		<entry>p</entry><entry>FIFO</entry>
	      </row>
	      <row>
		<entry>s</entry><entry>Socket</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>
	  Entonces, por ejemplo, si quisiera igualar directorios,
	  podría usar el parámetro <emphasis>d</emphasis> para el
	  operando <emphasis>-type</emphasis>:
	</para>

	<screen>
$ <userinput>find . -type d</userinput>
.
./economic
./technical
	</screen>

	<para>
	  Veremos la formación de expresiones complejas para
	  <command>find</command> al final de esta sección, pero en
	  este momento es útil saber que usted puede usar expresiones
	  boleanas 'and' para especificar múltiples operandos. Por
	  ejemplo <emphasis>operand1 operand2</emphasis> es verdadero
	  para <emphasis>operand1</emphasis> y
	  <emphasis>operand2</emphasis>, esto quiere decir que
	  solamente es verdadero cuando ambas condiciones son
	  evaluadas correctamente.  Entonces usted puede combinar los
	  operandos <emphasis>-name</emphasis> y
	  <emphasis>-type</emphasis> para hallar todos los directorios
	  que empiezan con <emphasis>eco</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name 'eco*' -type d</userinput>
./economic
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-perms">
	<title>Operandos que limitan por propiedad o permisos de objeto</title>

	<para>
	  Además de igualar nombres por su nombre o tipo, también
	  puede igualarlos por sus permisos activos o por la propiedad
	  del objeto.  A veces esto es útil para encontrar archivos
	  que tienen propiedad o permisos incorrectos.
	</para>

	<para>
	  El propietario (usuario) o grupo de un objeto puede ser
	  igualado con las variantes <emphasis>-user
	  username</emphasis> y <emphasis>-group groupname</emphasis>
	  respectivamente.  El nombre de un usuario o grupo será
	  interpretado como el ID de usuario o ID de grupo si el
	  nombre es decimal y no pudo ser hallado en el sistema con
	  <citerefentry><refentrytitle>getpwnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>
	  o
	  <citerefentry><refentrytitle>getgrnam</refentrytitle><manvolnum>3</manvolnum></citerefentry>. Entonces,
	  si quisiera igualar todos los objetos donde
	  <emphasis>joe</emphasis> es el dueño, puede usar
	  <emphasis>-user joe</emphasis> como operando:
	</para>

	<screen>
$ <userinput>find . -user joe</userinput>
./secret/report.txt
	</screen>

	<para>
	  O para encontrar a todos los objetos con
	  <emphasis>friend</emphasis> cmo grupo de archivo:
	</para>

	<screen>
$ <userinput>find . -group friends</userinput>
./secret/report.txt
	</screen>

	<para>
	  El operando para verificar permisos de archivos
	  <emphasis>-perm</emphasis> es menos trivial. Como el comando
	  <command>chmod</command>, este operador puede trabajar
	  notaciones de permisos octales y simbólicas. Empezaremos
	  viendo la notación octal. Si un número octal es especificado
	  como parámetro para el operando <emphasis>-perm</emphasis>,
	  igualará todos los objetos que tienen exactamente esos
	  permisos.  Por ejemplo, <emphasis>-perm 0600</emphasis>
	  igualará todos los objetos que solamente son leíbles y
	  escribibles por el usuario, y no tienen banderas adicionales
	  asignadas:
	</para>

	<screen>
$ <userinput>find . -perm 0600</userinput>
./secret/report.txt
	</screen>

	<para>
	  Si se agrega un guión como prefijo a un número, igualará
	  cada objeto que tiene asignados al menos los bits
	  especificados en el número octal. Un ejemplo útil es
	  encontrar todos los archivos que tienen al menos los bits
	  escribibles asignados para <emphasis>otros</emphasis>
	  usuarios con <emphasis>-perm -0002</emphasis>. Esto puede
	  ayudarle a encontrar los nodos de dispositivo u otros
	  objetos con permisos inseguros.
	</para>

	<screen>
$ <userinput>find /dev -perm -0002</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>

	<note>
	  <para>
	    Algunos nodos de dispositivo tienen que ser escribibles
	    globalmente para que un sistema UNIX funcione
	    correctamente.  Por ejemplo, el dispositivo
	    <filename>/dev/null</filename> es siempre escribible.
	  </para>
	</note>

	<para>
	  La notación simbólica de los parámetros
	  <emphasis>-perm</emphasis> usan la misma notación que el
	  comando <command>chmod</command>.  Los permisos simbólicos
	  se construyen con un mode de archivo donde todos los bits
	  son limpiados, entonces no es necesario usar un guión para
	  quitar permisos. Esto también previene la ambigüedad que
	  puede generarse con el prefijo guión.  Como la sintaxis
	  octal, prefijar los permisos con un guión igualará objetos
	  que tengan al menos los bits de permisos asignados. El uso
	  de nombres simbólicos es bastante predecible - los
	  siguientes comandos repiten los ejemplos previos con
	  permisos simbólicos:
	</para>

	<screen>
$ <userinput>find . -perm u+rw</userinput>
./secret/report.txt
	</screen>

	<screen>
$ <userinput>find /dev -perm -o+w</userinput>
/dev/null
/dev/zero
/dev/ctty
/dev/random
/dev/fd/0
/dev/fd/1
/dev/fd/2
/dev/psm0
/dev/bpsm0
/dev/ptyp0
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-time">
	<title>Operandos que limitan los objetos por fecha de creación</title>

	<para>
	  Hay tres operandos que operan en intervalos de tiempo.  La
	  sintaxis del operando es <emphasis>operando n</emphasis>,
	  donde <emphasis>n</emphasis> es el tiempo en días.  Los tres
	  operadores calculan una diferencia de tiempo en segundos,
	  que es dividida por el número de segundos en un día (86400),
	  descartando el restante. Entonces, si la diferencia es de un
	  día, <emphasis>operando 1</emphasis> igualará el objeto. Los
	  tres operandos son:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>-atime n</emphasis> - este operando evalúa
	      a verdadero si el tiempo de inicialización de
	      <command>find</command> menos la última fecha de acceso
	      al objeto es igual a <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-ctime n</emphasis> - este operando evalúa a
	      verdadero si el tiempo de inicialización de
	      <command>find</command> menos la fecha de la última
	      modificación del archivo en la información de estado del
	      archivo es igual a <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>-mtime n</emphasis> - este operando evalúa a
	      verdadero si el tiempo de inicialización de
	      <command>find</command> menos la última fecha de
	      modificación específica del archivo es igual a
	      <emphasis>n</emphasis>.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Entonces, estos operandos igualan si la última fecha de
	  acceso, modificación o modificación específica
	  respectivamente sucedió hace <emphasis>n</emphasis>
	  días. Para dar un ejemplo, el siguiente comando muestra
	  todos los objetos en <filename>/etc</filename> que fueron
	  modificados hace un día:
	</para>

	<screen>
$ <userinput>find /etc -mtime 1</userinput>
/etc
/etc/group
/etc/master.passwd
/etc/spwd.db
/etc/passwd
/etc/pwd.db
	</screen>

	<para>
	  Los signos de suma o resta pueden ser usados como
	  modificadores para el significado de
	  <emphasis>n</emphasis>. <emphasis>+n</emphasis> significa
	  más de <emphasis>n</emphasis> días, <emphasis>-n</emphasis>
	  significa menos de <emphasis>n</emphasis> días. Entonces,
	  para encontrar todos los archivos en
	  <filename>/etc</filename> que fueron modificados hasta hace
	  dos días, podría ejecutar:
	</para>

	<screen>
$ <userinput>find /etc -mtime -2</userinput>
/etc
/etc/network/run
/etc/network/run/ifstate
/etc/resolv.conf
/etc/default
/etc/default/locale
[...]
	</screen>

	<para>
	  Otro operando útil de tiempo es <emphasis>-newer
	  reffile</emphasis>. Esto iguala todos los archivos que
	  fueron modificados después del archivo con el nombre
	  <filename>reffile</filename>. El siguiente ejemplo muestra
	  cómo puede usar esto para listar todos los archivos que
	  tienen una fecha de modificación posterior a la del archivo
	  <filename>economic/report2.txt</filename>:
	</para>

	<screen>
$ <userinput>find . -newer economic/report2.txt</userinput>
.
./technical
./technical/report2.txt
./technical/report.txt
./secret
./secret/report.txt
	</screen>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-depth">
	<title>Operandos que afectan la navegación del árbol</title>

	<para>
	  Algunos operandos afectan la forma en que el comando
	  <command>find</command> navega a través del árbol. El
	  primero de estos operandos es
	  <emphasis>-xdev</emphasis>. <emphasis>-xdev</emphasis>
	  previene que <command>find</command> descienda en
	  directorios que tienen un diferente ID de dispositivo,
	  evitando efectivamente la navegación hacia otros sistemas de
	  archivos. Se imprime el directorio donde el sistema de
	  archivos está montado, porque este operando siempre retorna
	  <emphasis>true</emphasis>.  Un buen ejemplo es un sistema
	  donde <filename>/usr</filename> esta montado en un sistema
	  de archivos diferente al de <filename>/</filename>. Por
	  ejemplo, si buscamos directorios con el nombre
	  <emphasis>bin</emphasis>, obtendremos el siguiente resultado
	  de esta forma:
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d</userinput>
/usr/bin
/bin
	</screen>

	<para>
	  But if we add <emphasis>-xdev</emphasis>
	  <filename>/usr/bin</filename> is not found, because it is on
	  a different filesystem (and device):
	</para>

	<screen>
$ <userinput>find / -name 'bin' -type d -xdev</userinput>
/bin
	</screen>

	<para>
	  El operando <emphasis>-depth</emphasis> modifica el orden en
	  que los directorios son evaluados. Con
	  <emphasis>-depth</emphasis> el contenido de un directorio es
	  evaluado primero, y luego el directorio mismo. Esto puede
	  ser atestiguado en el siguiente ejemplo:
	</para>

	<screen>
$ <userinput>find . -depth</userinput>
./economic/report.txt
./economic/report2.txt
./economic
./technical/report2.txt
./technical/report.txt
./technical
.
	</screen>

	<para>
	  Como puede ver en la salida, los archivos en el directorio
	  <emphasis>./economic</emphasis> son evaluados antes que
	  <filename>.</filename>, y
	  <filename>./economic/report.txt</filename> antes que
	  <filename>./economic</filename>. <emphasis>-depth</emphasis>
	  siempre evalúa a <emphasis>verdadero</emphasis>.
	</para>

	<para>
	  Finalmente, el operando <emphasis>-prune</emphasis> causa
	  que <command>find</command> no descienda en un directorio
	  que esta siendo evaluado. <emphasis>-prune</emphasis> es
	  descartado si el operando <emphasis>-depth</emphasis> es
	  también usado. <emphasis>-depth</emphasis> siempre evalúa a
	  <emphasis>verdadero</emphasis>.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-exec">
	<title>Operandos que ejecutan utilidades externas</title>

	<para>
	  <command>find</command> se vuelve una herramienta muy
	  poderosa cuando es combinada con utilidades externas. Esto
	  puede hacerso con el operando
	  <emphasis>-exec</emphasis>. Hay dos sintaxis para el
	  operando <emphasis>-exec</emphasis>. La primer sintaxis es
	  <emphasis>-exec utility arguments ;</emphasis>. El comando
	  <emphasis>utility</emphasis> será ejecutado con los
	  argumentos que fueron especificados para cada objeto que
	  está siendo evaluado. Si alguno de los argumentos es
	  <emphasis>{}</emphasis>, estas llaves serán reemplazadas por
	  el archivo que está siendo evaluado.  Esto es muy útil,
	  especialmente cuando consideramos eso, si no utilizamos
	  sintaxis de expresión adicional, los operandos serán
	  evaluados de izquierda a derecha.  Veámos un ejemplo:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} \;</userinput>
	</screen>

	<para>
	 El primer operando retorna verdadero para los archivos que
	 tienen sus permisos asignados a <emphasis>0666</emphasis>.
	 El segundo operando ejecuta <emphasis>chmod 0644
	 filename</emphasis> para cada archivo que está siendo
	 evaluado. Si se esta preguntando por qué este comando no es
	 ejecutado para cada archivo, esa es una buena pregunta.  Como
	 muchos otros intérpretes de expresiones,
	 <command>find</command> usa <quote>short-circuiting</quote>.
	 Porque ningún otro operador fué especificado, el operador
	 lógico <emphasis>and</emphasis> es automáticamente asumido
	 entre ambos operandos. Si el primer operando evalúa a
	 <emphasis>falso (false)</emphasis>, no tiene sentido evaluar
	 los siguientes operandos , porque la expresión completa
	 siempre evaluará a <emphasis>falso
	 (false)</emphasis>. Entonces, el operando
	 <emphasis>-exec</emphasis> solamente será evaluado si el
	 primer operando es verdadero. Otra particularidad es que el
	 semi-colon que cierra <emphasis>-exec</emphasis> esta
	 acompañado de caracteres de escape, para prevenir que la
	 consola los parsee.
	</para>

	<para>
	  Algo bueno sobre el operador <emphasis>-exec</emphasis> es
	  que evalúa a <emphasis>verdadero</emphasis> si el
	  comando finaliza exitosamente. Entonces, también puede usar
	  el comando <emphasis>-exec</emphasis> para agregar
	  condiciones adicionales que no estan representadas por los
	  operandos de <command>find</command>.  Por ejemplo, el
	  siguiente comando imprime todos los objetos que terminan en
	  <emphasis>.txt</emphasis> que contienen la cadena
	  <emphasis>gross income</emphasis>:
	</para>

	<screen>
$ <userinput>find . -name '*.txt' -exec grep -q 'gross income' {} \; -print</userinput>
./economic/report2.txt
	</screen>

	<para>
	  El comando <command>grep</command> será cubierto mas tarde.
	  <!-- XXX - xref --> Pero por el momento, esto es suficiente
	  para saber que puede ser usado para igualar patrones de
	  texto. El operando <emphasis>-print</emphasis> imprime la
	  ubicación del objeto actual. Es siempre usado
	  implícitamente, excepto cuando los operandos
	  <emphasis>-exec</emphasis> o <emphasis>-ok</emphasis> son
	  usados. <!-- XXX - move to introduction? -->
	</para>

	<para>
	  La segunda sintaxis del operando <emphasis>-exec</emphasis>
	  es <emphasis>-exec utility arguments {} +</emphasis>. Esto
	  reúne un conjunto de todos los objetos igualados para los
	  que la expresión es verdadera, y provee este conjunto de
	  archivos como argumento para la utilidad que fué
	  especificada. El primer ejemplo del operando
	  <emphasis>-exec</emphasis> también puede ser escrito como:
	</para>

	<screen>
$ <userinput>find . -perm 0666 -exec chmod 0644 {} +</userinput>
	</screen>

	<para>
	  Esto ejecutará el comando <command>chmod</command> solamente
	  una vez, con todos los archivos para los que la expresión es
	  verdadera como sus argumentos. Este operando siempre retorna
	  <emphasis>verdadero</emphasis>.
	</para>

	<para>
	  Si un comando ejecutado por <command>find</command> retorna
	  un valor diferente a cero (indicando que la ejecución del
	  comando no fué exitosa), <command>find</command> también
	  debería retornar un valor diferente a cero.
	</para>
      </sect3>

      <sect3 xml:id="chap-filesystem-finding-find-operators">
	<title>Operadores para construir expresiones complejas</title>

	<para>
	  <command>find</command> provee algunos operadores que pueden
	  ser combinados para construir expresiones más complejas:
	</para>

	<variablelist>
	  <title>Operadores</title>

	  <varlistentry>
	    <term>( expr )</term>
	    <listitem>
	      <para>
		Evalúa a <emphasis>verdadero</emphasis> si
		<emphasis>expr</emphasis> evalúa a <emphasis>verdadero</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 [-a] expr2</term>
	    <listitem>
	      <para>
		Evalúa a <emphasis>verdadero</emphasis> si
		ambos <emphasis>expr1</emphasis> y
		<emphasis>expr2</emphasis> son verdaderos. Si
		<emphasis>-a</emphasis> es omitido, este operador es
		asumido implícitamente.
	      </para>

	      <para>
		<command>find</command> usará un corto circuito cuando
		este operador es evaluado: <emphasis>expr2</emphasis>
		no será evaluado cuando <emphasis>expr1</emphasis>
		evalúa a <emphasis>falso</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>expr1 -o expr2</term>
	    <listitem>
	      <para>
		Evalúa a <emphasis>verdader</emphasis> si uno o ambos
		<emphasis>expr1</emphasis> y
		<emphasis>expr2</emphasis> son verdaderos.
	      </para>

	      <para>
		<command>find</command> usará un corto circuito cuando
		este operador es evaluado: <emphasis>expr2</emphasis>
		no será evaluado cuando <emphasis>expr1</emphasis>
		evalúa a <emphasis>verdadero</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>! expr</term>
	    <listitem>
	      <para>
		Niega <emphasis>expr</emphasis>. Entonces, si
		<emphasis>expr</emphasis> evalúa a verdadero, esta
		expresión evaluará a <emphasis>falso</emphasis> y
		viceversa.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>
	  Ya que los paréntesis y símbolos de exclamación son
	  interpretados por la mayoría de las consolas, usualmente
	  deberían estar acompañadas de caracteres de escape.
	</para>

	<para>
	  El siguiente ejemplo muestra algunos operadores en acción.
	  Este comando ejecuta <command>chmod</command> para todos los
	  archivos que tienen sus permisos asignados a
	  <emphasis>0666</emphasis> o <emphasis>0664</emphasis>.
	</para>

	<screen>
$ <userinput>find . \( -perm 0666 -o -perm 0664 \) -exec chmod 0644 {} \;</userinput>
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-which">
      <title>which</title>

      <para>
	El comando <command>which</command> no es parte del estándar
	Single UNIX Specification version 3, pero es proveído por la
	mayoría de los sistemas. <command>which</command> localiza un
	comando que se encuentra en el path del usuario (como está
	configurado en la variable PATH del sistema), imprimiendo su
	ubicación completa. Proveer el nombre de un comando como
	parámetro mostrará la ubicación completa:
      </para>

      <screen>
$ <userinput>which ls</userinput>
/bin/ls
      </screen>

      <para>
	También puede consultar las ubicaciones de múltiples comandos:
      </para>

      <screen>
$ <userinput>which ls cat</userinput>
/bin/ls
/bin/cat
      </screen>

      <para>
	<command>which</command> retorna un valor diferente a cero si
	el comando no pudo ser encontrado.
      </para>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-whereis">
      <title>whereis</title>

      <para>
	El comando <command>whereis</command> busca binarios, páginas
	manual y fuentes de un comando en algunos lugares
	predefinidos. Por ejemplo, el siguiente comando muestra la
	ubicación de <command>ls</command> y la página manual
	<citerefentry><refentrytitle>ls</refentrytitle>
	<manvolnum>1</manvolnum></citerefentry>:
      </para>

      <screen>
$ <userinput>whereis ls</userinput>
ls: /bin/ls /usr/share/man/man1/ls.1.gz
      </screen>
    </sect2>

    <sect2 xml:id="chap-filesystem-finding-locate">
      <title>locate</title>

      <para>
	Slackware Linux también provee el comando
	<command>locate</command> que busca a través de una base de
	datos de archivos que puede ser generada periódicamente con el
	comando <command>updatedb</command>. Como utiliza una base de
	datos pre-construida del sistema de archivos, es mucho mas
	rápida que <command>which</command>, especialmente cuando la
	entrada de información de directorio aún no ha sido
	registrada.  Sin embargo, la combinación
	<command>locate</command>/<command>updatedb</command> tiene
	algunos altibajos:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Los archivos nuevos no son parte de la base de datos hasta
	    la próxima invocación de <command>updatedb</command>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <command>locate</command> no tiene una concepción de
	    permisos, entonces usuarios podrían localizar archivos que
	    normalmente están ocultos para ellos.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Una implementación mas nueva, llamada
	    <emphasis>slocate</emphasis> procesa permisos, pero
	    requiere elevados privilegios. Esta es la variante de
	    <command>locate</command> incluída en Slackware Linux.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	Con los sistemas de archivos volviéndose mas rápidos, y
	aplicando el sentido común cuando se formulan consultas
	<command>find</command>, el uso <command>locate</command> no
	parece valer la pena. Por supuesto, su kilometraje puede
	variar. Dicho esto, el uso básico de <command>locate</command>
	es <emphasis>locate filename</emphasis>. Por ejemplo:
      </para>

      <screen>
$ <userinput>locate locate</userinput>
/usr/bin/locate
/usr/lib/locate
/usr/lib/locate/bigram
/usr/lib/locate/code
/usr/lib/locate/frcode
[...]
      </screen>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-archives">
    <title>Paquetes de archivos</title>

    <sect2 xml:id="basics-filesystem-archives-introduction">
      <title>Introducción</title>

      <para>
	Tarde o temprano un usuario GNU/Linux se encontrará con
	paquetes <acronym>tar</acronym>, tar es el formato de
	empaquetación de archivos estándar en GNU/Linux. Normalmente es
	usado en combinación con <command>gzip</command> o
	<command>bzip2</command>. Ambos comandos pueden comprimir
	paquetes. <xref linkend="archive-extentions" /> lista
	extensiones de paquetes frecuentemente usados y lo que
	significan.
      </para>

      <table xml:id="archive-extentions">
	<title>Extensiones de paquetes</title>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Extension</entry>
	      <entry>Significado</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>.tar</entry>
	      <entry>Un paquete de archivos sin comprimir</entry>
	    </row>
	    <row>
	      <entry>.tar.gz</entry>
	      <entry>Un paquete tar comprimido con gzip</entry>
	    </row>
	    <row>
	      <entry>.tgz</entry>
	      <entry>Un paquete tar comprimido con gzip</entry>
	    </row>
	    <row>
	      <entry>.tar.bz2</entry>
	      <entry>Un paquete tar comprimido con bzip2</entry>
	    </row>
	    <row>
	      <entry>.tbz</entry>
	      <entry>Un paquete tar comprimido con bzip2</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	La diferencia entre <command>bzip2</command> y
	<command>gzip</command> es que <command>bzip2</command> puede
	encontrar información repetida en bloques mas largos,
	generando una mejor compresión. Pero <command>bzip2</command>
	es también mucho mas lento, porque realiza mas análisis de
	datos.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-extracting">
      <title>Extrayendo paquetes</title>

      <para>
	Ya que mucho software e información en GNU/Linux esta
	empaquetada con <command>tar</command>, es importante
	acostumbrarse a extraer paquetes tar. La primera cosa que
	usted querrá a veces cuando recibe un paquete tar es listar su
	contenido. Esto puede lograrse usando el parámetro <parameter
	class="command">t</parameter>. Sin embargo, si solamente
	ejecutamos <command>tar</command> con este perámetro, y el
	nombre del paquete, se quedará esperando hasta que usted
	ingrese algo a la entrada estándar:
      </para>

      <screen>
$ <userinput>tar t test.tar</userinput>
      </screen>

      <para>
	Esto sucede porque <command>tar</command> lee datos desde su
	entrada estándar. Si usted olvida cómo funciona la
	redirección, es recomendable releer <xref
	linkend="chap-shell-inout" />.  Veámos qué pasa si redirigimos
	nuestro paquete tar al comando tar:
      </para>

      <screen>
$ <userinput>tar t &lt; test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Esto luce mas como la salida que usted probablemente esperaba.
	Este paquete parece contener un directorio
	<filename>test</filename>, el cual contiene los archivos
	<filename>test2</filename> y
	<filename>test1</filename>. También es posible especificar el
	nombre de archivo del paquete como parámetro a
	<command>tar</command>, usando el parámetro <parameter
	class="command">f</parameter>:
      </para>

      <screen>
$ <userinput>tar tf test.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Este se ve como un paquete que contiene archivos útiles
	;). Ahora podemos seguir adelante y extraer este paquete
	usando el parámetro <parameter class="command">x</parameter>:
      </para>

      <screen>
$ <userinput>tar xf test.tar</userinput>
      </screen>

      <para>
	Ahora podemos verificar que <command>tar</command> realmente
	extrajo el paquete al listar el contenido del directorio con
	<command>ls</command>:
      </para>

      <screen>
$ <userinput>ls test/</userinput>
test1  test2
      </screen>

      <para>
	Extraer o listar archivos de un paquete gzip o bzip no es mas
	complejo. Esto puede realizarse agregando una letra <parameter
	class="command">z</parameter> o <parameter
	class="command">j</parameter> para los paquetes comprimidos
	respectivamente con <command>gzip</command> o
	<command>bzip2</command>. Por ejemplo, podemos listar el
	contenido de un paquete gzip con:
      </para>

      <screen>
$ <userinput>tar ztf archive2.tar.gz</userinput>
      </screen>

      <para>
	Y un paquete bzip puede ser extraído con:
      </para>

      <screen>
$ <userinput>tar jxf archive3.tar.bz2</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="basics-filesystem-archives-creating">
      <title>Creando paquetes</title>

      <para>
	Puede crear paquetes con el parámetro <parameter
	class="command">c</parameter>. Suponga que tenemos el
	directorio <filename>test</filename> usado en el ejemplo
	previo. Podemos hacer un paquete con el directorio
	<filename>test</filename> y sus archivos con:
      </para>

      <screen>
$ <userinput>tar cf important-files.tar test</userinput>
      </screen>

      <para>
	Esto creará el paquete
	<filename>important-files.tar</filename> (el cual es
	especificado con el parámetro <parameter
	class="command">f</parameter>). Ahora podemos verificar el
	paquete:
      </para>

      <screen>
$ <userinput>tar tf important-files.tar</userinput>
test/
test/test2
test/test1
      </screen>

      <para>
	Crear un paquete gzip o bzip va incluído en la misma línea que
	extrae paquetes comprimidos: agregue una <parameter
	class="command">z</parameter> para comprimir un paquete con
	gzip, o <parameter class="command">b</parameter> para
	comprimirlo con bzip. Suponga que queremos crear una version
	del paquete creado previamente comprimida con
	<command>gzip</command>. Podemos hacerlo con esto:
      </para>

      <screen>
<userinput>tar zcf important-files.tar.gz test</userinput>
      </screen>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-filesystem-mounting">
    <title>Montando sistemas de archivos</title>

    <sect2 xml:id="basics-filesystem-mounting-introduction">
      <title>Introducción</title>

      <para>
	Como en la mayoría de los sistemas Unix, Linux usa una técnica
	denominada <quote>montar</quote> para acceder sistemas de
	archivos. Montar significa que un sistema de archivos es
	conectado a un directorio en el sistema de archivos root. Uno
	podría, por ejemplo, montar un dispositivo CD-ROM al
	directorio <filename>/mnt/cdrom</filename>. Linux soporta
	muchos tipos de sistemas de archivos, como Ext2, Ext3,
	ReiserFS, JFS, XFS, ISO9660 (usado para CD-ROMs), UDF (usado
	en algunos DVDs) y sistemas de archivos DOS/Windows, como FAT,
	FAT32 y NTFS. Estos sistemas de archivos pueden residir en
	muchos tipos de medio, por ejemplo discos duros, CD-ROMs y
	dispositivos Flash. Esta sección explica cómo los sistemas de
	archivos pueden ser montados o desmontados.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-mount">
      <title>mount</title>

      <para>
	El comando <command>mount</command> es usado para montar
	sistemas de archivos. La sintaxis básica es: <quote>mount
	/dev/nombre_dispositivo /punto_montaje</quote>. El nombre de
	dispositivo puede ser cualquier dispositivo de bloque, como
	discos duros o CD-ROMs. El punto de montaje puede ser un punto
	arbitrario en el sistema de archivos root. Veámos un ejemplo:
      </para>

      <screen>
# <userinput>mount /dev/cdrom /mnt/cdrom</userinput>
      </screen>

      <para>
	Esto monta el dispositivo <filename>/dev/cdrom</filename> en
	el punto de montaj e. El nombre de dispositivo
	<filename>/dev/cdrom</filename> es normalmente un enlace para
	el nombre real del dispositivo CD-ROM (por ejemplo,
	<filename>/dev/hdc</filename>). Como puede ver, el concepto es
	muy simple, solamente toma algun tiempo aprender los nombres
	de dispositivos ;). Algunas veces es necesario especificar qué
	tipo de sistema de archivos esta tratando de montar.  El tipo
	de sistema de archivos puede ser especificado agregando el
	parámetro <parameter class="command">-t</parameter>:
      </para>

      <screen>
# <userinput>mount -t vfat /dev/sda1 /mnt/flash</userinput>
      </screen>

      <para>
	Esto monta el sistema de archivos vfat
	<filename>/dev/sda1</filename> en
	<filename>/mnt/flash</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-umount">
      <title>umount</title>

      <para>
	El comando <command>umount</command> es usado para desmontar
	sistemas de archivos, <command>umount</command> acepta dos
	tipos de parámetros, puntos de montaje y dispositivos. Por
	ejemplo:
      </para>

      <screen>
# <userinput>umount /mnt/cdrom</userinput>
# <userinput>umount /dev/sda1</userinput>
      </screen>

      <para>
	El primer comando desmonta el sistema de archivos que fué
	montado en <filename>/mnt/cdrom</filename>, el segundo comando
	desmonta el sistema de archivos en
	<filename>/dev/sda1</filename>.
      </para>
    </sect2>

    <sect2 xml:id="basics-filesystem-mounting-fstab">
      <title>El archivo fstab</title>

      <para>
	El sistema GNU/Linux tiene un archivo especial,
	<filename>/etc/fstab</filename>, que especifica cuáles
	sistemas de archivos deberían ser montados durante el arranque
	del sistema. Veámos un ejemplo:
      </para>

      <screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
      </screen>

      <para>
	Como pueden ver, cada entrada en el archivo
	<filename>fstab</filename> tiene cinco columnas: fs_spec,
	fs_file, fs_vfstype, fs_mntops, fs_freq, y fs_passno. Ahora
	vamos a ver cada entrada.
      </para>

      <sect3>
	<title>fs_spec</title>

	<para>
	  La opción fs_spec especifica el dispositivo de bloque, o un
	  sistema de archivos remoto que debería ser montado. Como
	  puede ver en el ejemplo, varias particiones /dev/hda son
	  especificadas, así también los dispositivos de CD-ROM o
	  disquete. Cuando volúmenes NFS son montados una dirección IP
	  y un directorio pueden ser especificados, por ejemplo:
	  <filename>192.168.1.10:/exports/data</filename>.
	</para>
      </sect3>

      <sect3>
	<title>fs_file</title>

	<para>
	  fs_file especifica el punto de montaje. Puede ser un
	  directorio arbitrario en el sistema de archivos.
	</para>
      </sect3>

      <sect3>
	<title>fs_vfstype</title>

	<para>
	  Esta opción especifica qué tipo de sistema de archivos es
	  representado por la entrada. Por ejemplo, puede tener los
	  valores: ext2, ext3, reiserfs, xfs, nfs, vfat, o ntfs.
	</para>
      </sect3>

      <sect3>
	<title>fs_mntops</title>

	<para>
	  La opción fs_mntops especifica qué parametros deberían ser
	  usados para montar el sistema de archivos. La página manual
	  de <command>mount</command> tiene una descripción extensa de
	  las opciones disponibles. Estas son las opciones mas
	  interesantes:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>noauto</emphasis>: sistemas de archivos que
	      son listados en <filename>/etc/fstab</filename> son
	      normalmente montados automáticamente. Cuando la opción
	      <quote>noauto</quote> es especificada, el sistema de
	      archivos no será montado durante el arranque del
	      sistema, sino cuando el comando <command>mount</command>
	      sea usado para montar dicho dispositivo. Cuando el
	      sistema de archivos este siendo montando, solamente se
	      debe especificar el punto de montaje o el nombre del
	      dispositivo, por ejemplo: <command>mount
	      /mnt/cdrom</command>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>user</emphasis>: agregando la opción
	      <quote>user</quote> permitirá a usuarios normales montar
	      el sistema de archivos (normalmente solamente el super
	      usuario puede montar sistemas de archivos).
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>owner</emphasis>: la opción
	      <quote>owner</quote> le permite al propietario del
	      dispositivo especificado montar el mismo. Puede ver el
	      propietario de un dispositivo usando
	      <command>ls</command>, e.g.  <command>ls -l
	      /dev/cdrom</command>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>noexec</emphasis>: esta opción habilita el
	      bloqueo de ejecución de archivos del sistema de archivos
	      montado a los usuarios. Esto puede ser usado para
	      proveer mas seguridad.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>nosuid</emphasis>: esta opción es comparable a
	      la opción <quote>noexec</quote>. Con
	      <quote>nosuid</quote> habilitado, los bits SUID en los
	      archivos del sistema de archivos montado no serán
	      permitidos. SUID es usado para ciertos binarios para
	      proveer a usuarios normales hacer algo que requiera
	      privilegios. Esto es seguramente una medida de
	      seguridad, entonces esta opción debería ser usada para
	      medios removibles, etc. Un montaje hecho por un usuario
	      normal forzará la opción nosuid, pero un montaje del
	      super-usuario no lo hará!
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis>unhide</emphasis>: esta opción solamente es
	      relevante para CD-ROMs normales con el sistema de
	      archivos ISO9660. Si <quote>unhide</quote> es
	      especificado, los archivos ocultos también serán
	      visibles.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>fs_freq</title>

	<para>
	  Si <quote>fs_freq</quote> es asignada a 1 o un número mayor,
	  especifica cada cuantos días se debería realizar un respaldo
	  (dump) del sistema de archivos. Esta opción es solamente
	  usada cuando <ulink
	  url="http://dump.sourceforge.net/">dump</ulink> esta
	  instalada y correctamente configurada para manejar esto.
	</para>
      </sect3>

      <sect3>
	<title>fs_passno</title>

	<para>
	  Este campo es usado por <command>fsck</command> para
	  determinar el orden en el que los sistemas de archivos son
	  verificados durante el arranque del sistema.
	</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 xml:id="basics-filesystem-gnupg">
    <title>Encriptando y firmando archivos</title>

    <sect2>
      <title>Introducción</title>

      <para>
	There are two security mechanisms for securing files: signing
	files and encrypting files. Signing a file means that a
	special digital signature is generated for a file. You, or
	other persons can use the signature to verify the integrity of
	the file. File encryption encodes a file in a way that only a
	person for which the file was intended to read can read the
	file.
      </para>

      <para>
	This system relies on two keys: the private and the public
	key. Public keys are used to encrypt files, and files can only
	be decrypted with the private key. This means that one can
	sent his public key out to other persons. Others can use this
	key to send encrypted files, that only the person with the
	private key can decode. Of course, this means that the
	security of this system depends on how well the private is
	kept secret.
      </para>

      <para>
	Slackware Linux provides an excellent tool for signing and
	encrypting files, named GnuPG. GnuPG can be installed from the
	<quote>n</quote> disk set.
      </para>
    </sect2>

    <sect2>
      <title>Generating your private and public keys</title>

      <para>
	Generating public and private keys is a bit complicated,
	because GnuPG uses DSA keys by default. DSA is an encryption
	algorithm, the problem is that the maximum key length of DSA
	is 1024 bits, this is considered too short for the longer
	term. That is why it is a good idea to use 2048 bit RSA
	keys. This section describers how this can be done.
      </para>

      <note>
	<para>
	  1024-bit keys were believed to be secure for a long
	  time. But Bernstein's paper <emphasis>Circuits for Integer
	  Factorization: a Proposal</emphasis> contests this, the
	  bottom line is that it is quite feasible for national
	  security agencies to produce hardware that can break keys in
	  a relatively short amount of time.  Besides that it has be
	  shown that 512-bit RSA keys can be broken in a relatively
	  short time using common hardware. More information about
	  these issues can by found in this e-mail to the cypherpunks
	  list:
	<ulink url="http://tin.le.org/vault/security/encryption/rsa1024.html" />
	</para>
      </note>

      <para>
	We can generate a key by executing:
      </para>

      <screen>
$ <userinput>gpg --gen-key</userinput>
      </screen>

      <para>
	The first question is what kind of key you would like to
	make. We will choose <emphasis>(4) RSA (sign only)</emphasis>:
      </para>

      <screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <userinput>4</userinput>
      </screen>

      <para>
	You will then be asked what the size of the key you want to
	generate has to be. Type in <emphasis>2048</emphasis> to
	generate a 2048 bit key, and press enter to continue.
      </para>

      <screen>
What keysize do you want? (1024) <userinput>2048</userinput>
      </screen>

      <para>
	The next question is simple to answer, just choose what you
	like. Generally speaking it is not a bad idea to let the key
	be valid infinitely. You can always deactivate the key with a
	special revocation certificate.
      </para>

      <screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	GnuPG will then ask for confirmation. After confirming your
	name and e-mail address will be requested. GnuPG will also ask
	for a comment, you can leave this blank, or you could fill in
	something like <quote>Work</quote> or <quote>Private</quote>,
	to indicate what the key is used for. For example:
      </para>

      <screen>
Real name: <userinput>John Doe</userinput>
Email address: <userinput>john@doe.com</userinput>
Comment: <userinput>Work</userinput>              
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	GnuPG will the ask you to confirm your user ID. After
	confirming it GnuPG will ask you to enter a password. Be sure
	to use a good password:
      </para>

      <screen>
You need a Passphrase to protect your secret key.    

Enter passphrase:
      </screen>

      <para>
	After entering the password twice GnuPG will generate the
	keys. But we are not done yet. GnuPG has only generated a key
	for signing information, not for encryption of information. To
	continue, have a look at the output, and look for the key
	ID. In the information about the key you will see
	<emphasis>pub 2048R/</emphasis>. The key ID is printed after
	this fragment.  In this example:
      </para>

      <screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
      </screen>

      <para>
	the key ID is <emphasis>8D080768</emphasis>. If you lost the
	output of the key generation you can still find the key ID in
	the output of the <command>gpg --list-keys</command>
	command. Use the key ID to tell GnuPG that you want to edit
	your key:
      </para>

      <screen>
$ <userinput>gpg --edit-key &lt;Key ID&gt;</userinput>
      </screen>

      <para>
	With the example key above the command would be:
      </para>

      <screen>
$ <userinput>gpg --edit-key 8D080768</userinput>
      </screen>

      <para>
	GnuPG will now display a command prompt. Execute the
	<command>addkey</command> command on this command prompt:
      </para>

      <screen>
Command&gt; <userinput>addkey</userinput>
      </screen>

      <para>
	GnuPG will now ask the password you used for your key:
      </para>

      <screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	After entering the password GnuPG will ask you what kind of
	key you would like to create. Choose <emphasis>RSA (encrypt
	only)</emphasis>, and fill in the information like you did
	earlier (be sure to use a 2048 bit key).  For example:
      </para>

      <screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <userinput>5</userinput>
What keysize do you want? (1024) <userinput>2048</userinput>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <userinput>0</userinput>
      </screen>

      <para>
	And confirm that the information is correct. After the key is
	generated you can leave the GnuPG command prompt, and save the
	new key with the <command>save</command> command:
      </para>

      <screen>
Command&gt; <userinput>save</userinput>
      </screen>

      <para>
	Congratulations! You have now generated the necessary keys to
	encrypt and decrypt e-mails and files. You can now configure
	your e-mail client to use GnuPG. It is a good idea to store
	the contents of the <filename>.gnupg</filename> directory on
	some reliable medium, and store that in a safe place! If your
	private key is lost you can't decrypt files and messages that
	were encrypted with your public key. If the private key, and
	your password are stolen, the security of this system is
	completely compromised.
      </para>
    </sect2>

    <sect2>
      <title>Exporting your public key</title>

      <para>
	To make GnuPG useful, you have to give your public key to
	people who send you files or e-mails. They can use your public
	key to encrypt files, or use it to verify whether a file has a
	correct signature or not. The key can be exported using the
	<parameter class="command">--export</parameter> parameter. It
	is also a good idea to specify the <parameter
	class="command">--output</parameter> parameter, this will save
	the key in a file. The following command would save the public
	key of <emphasis>John Doe</emphasis>, used in earlier
	examples, to the file <filename>key.gpg</filename>:
      </para>

      <screen>
$ <userinput>gpg --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	This saves the key in binary format. Often it is more
	convenient to use the so-called <quote>ASCII armored
	output</quote>, which fits better for adding the key to
	e-mails, or websites. You export an ASCII armored version of
	the key by adding the <parameter
	class="command">--armor</parameter> parameter:
      </para>

      <screen>
$ <userinput>gpg --armor --output key.gpg --export john@doe.com</userinput>
      </screen>

      <para>
	If you look at the <filename>key.gpg</filename> file you will
	notice that the ASCII armored key is a much more comfortable
	format.
      </para>
    </sect2>

    <sect2>
      <title>Signatures</title>

      <para>
	With GPG you can make a signature for a file. This signature
	is unique, because your signature can only be made with your
	private key. This means that other people can check whether
	the file was really sent by you, and whether it was in any way
	altered or not. Files can be signed with the <parameter
	class="command">--detach-sign</parameter> parameter. Let us
	look at an example. This command will make a signature for the
	<filename>memo.txt</filename> file. The signature will be
	stored in <filename>memo.txt.sig</filename>.
      </para>

      <screen>
$ <userinput>gpg --output memo.txt.sig --detach-sign memo.txt</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
      </screen>

      <para>
	As you can see, GnuPG will ask you to enter the password for
	your private key. After you have entered the right password the
	signature file (<filename>memo.txt.sig</filename>) will be
	created.
      </para>

      <para>
	You can verify a file with its signature using the <parameter
	class="command">--verify</parameter> parameter. Specify the
	signature file as a parameter to the <parameter
	class="command">--verify</parameter> parameter. The file that
	needs to be verified can be specified as the final parameter:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	This will confirm that the file was indeed signed by
	<emphasis>John Doe (Work) &lt;john@doe.com&gt;</emphasis>,
	with the key <emphasis>8D080768</emphasis>, and that the file
	is unchanged. Suppose the file was changed, GnuPG would have
	complained about it loudly:
      </para>

      <screen>
$ <userinput>gpg --verify memo.txt.sig memo.txt</userinput>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>
    </sect2>

    <sect2>
      <title>Encryption</title>

      <para>
	One of the main features of GnuPG is encryption. Due to its
	use of asymmetric cryptography, the person who encrypts a file
	and the person who decrypts a file do not need to share a
	key. You can encrypt a file with the public key of another
	person, and that other person can decrypt it with his or her
	private key. You can encrypt files with the <parameter
	class="command">--encrypt</parameter>. If you do not specify a
	user ID for which the file should be encrypted, GnuPG will
	prompt for the user ID. You can specify the user ID with the
	<parameter class="command">-r</parameter> parameter. In the
	following example, the file <filename>secret.txt</filename>
	will be encrypted for another person named <emphasis>John
	Doe</emphasis>:
      </para>

      <screen>
$ <userinput>gpg --encrypt -r "John Doe" secret.txt</userinput>
      </screen>

      <para>
	The user ID is quoted with double quotes for making sure that
	the ID is interpreted as a single program argument. After the
	encryption is completed, the encrypted version of the file
	will be available as <filename>secret.txt.gpg</filename>.
      </para>

      <para>
	The user who receives the file can decrypt it with the
	<parameter class="command">--decrypt</parameter> parameter of
	the <command>gpg</command> command:
      </para>

      <screen>
$ <userinput>gpg --output secret.txt --decrypt secret.txt.gpg</userinput>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16 (main key ID EC3ED1AB)

Enter passphrase:

gpg: encrypted with 2048-bit RSA key, ID 8D080768, created 2004-07-16
      "John Doe (Work) &lt;john@doe.com&gt;"
      </screen>

      <para>
	In this example the <parameter
	class="command">--output</parameter> parameter is used store
	the decrypted content in <filename>secret.txt</filename>.
      </para>
    </sect2>
  </sect1>
</chapter>
