<!-- $Id: concepts.xml 333 2007-10-21 17:20:54Z danieldk $ -->

<chapter id="concepts"> <?dbhtml filename="concepts.html"?>
  <title>Conceptos generales</title>

  <para>
    Este capítulo brinda una introducción a algunos conceptos
    generales sobre UNIX y GNU/Linux. Es importante leer este capítulo
    extensivamente si no tiene ninguna experiencia en UNIX ó
    GNU/Linux. Muchos conceptos cubiertos en este capítulo son usados
    en este libro y en GNU/Linux.
  </para>

  <sect1 id="concepts-multitasking">
    <title>Multitarea</title>

    <sect2 id="concepts-multitasking-intro">
      <title>Introducción</title>

      <para>
	Una de las fortalezas tradicionales de UNIX es ser multitarea.
	Multitarea quiere decir que múltiples programas pueden ser
	ejecutados al mismo tiempo. Usted podría preguntarse por qué
	esto es importante, ya que la mayoría de las personas utilizan
	solamente una aplicación a la vez. El ser multitarea es una
	necesidad vital para sistemas del tipo UNIX. Aún si no ha
	iniciado aplicación alguna, existen programas ejecutándose en
	segundo plano. Por ejemplo, algunos programas servicios de
	red, mientras otros muestran un mensaje de inicio de sesión y
	esperan hasta que el usuario inicie sesión en una terminal
	virtual.  Los programas que se ejecutan en segundo plano son
	comúnmente denominados <emphasis>daemon processes</emphasis>.
        <footnote>
          <para>
            La palabra <emphasis>daemon</emphasis> no debería ser 
	    confundida con la palabra <emphasis>demon</emphasis>, 
	    la palabra <emphasis>daemon</emphasis> se refiere a 
	    seres sobrenaturales de la mitología griega.
          </para>
        </footnote>.
      </para>
    </sect2>

    <sect2 id="concepts-multitasking-procsthreads">
      <title>Procesos e hilos</title>

      <para>
	Después de que un programa es cargado desde un medio de
	almacenamiento, una instancia del mismo es iniciada. Esta
	instancia es llamada <emphasis>proceso</emphasis>. Un proceso
	tiene su propia memoria protegida, denominada el
	<emphasis>espacio de direccionamiento de
	memoria</emphasis>. El espacion de direccionamiento de memoria
	tiene dos áreas importantes: el área de
	<emphasis>texto</emphasis> y el área de
	<emphasis>datos</emphasis>. El área de
	<emphasis>texto</emphasis> es el código actual del programa;
	es usado para decirle al sistema qué hacer. El área de
	<emphasis>datos</emphasis> es usada para almacenar constantes
	y datos de ejecución. El sistema operativo entrega a cada
	proceso un tiempo de ejecución. En sistemas de un solo
	procesador los procesos en realidad no se ejecutan
	simultáneamente. En realidad un programador en el kernel
	divide el tiempo de CPU entre los procesos, dando la sensación
	de que los procesos se ejecutan simultáneamente.  Este proceso
	es llamado <emphasis>time-sharing</emphasis>. En sistemas con
	más de un CPU, más de un proceso puede ejecutarse
	simultáneamente, pero time-sharing se utiliza todavía para
	dividir el CPU disponible entre los procesos.
      </para>

      <para>
	Nuevos procesos son creados duplicando un proceso en ejecución
	con la llamada del sistem <command>fork</command>. <xref
	linkend="fork" /> muestra una llamada fork(bifurcar)
	esquemáticamente.  El proceso padre ejecuta una llamada
	fork(). El kernel responderá a esta llamada duplicando el
	proceso, nombrando a uno de los procesos como
	<emphasis>padre</emphasis> y al otro
	<emphasis>hijo</emphasis>.
      </para>

      <figure id="fork">
        <title>Duplicando(bifurcando) un proceso</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../../images/fork.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
	La duplicación puede ser usada por un programa para crear dos
	procesos que pueden ejecutarse simultáneamente en máquinas
	multi-proceso. Sin embargo, esto no es siempre ideal, porque
	ambos procesos tendrán su propio espacio de direccionamiento
	de memoria. La duplicación inicial de la memoria del proceso
	toma relativamente mucho tiempo, y es difícil compartir datos
	entre dos procesos. Este problema es resuelto por un concepto
	denominado <emphasis>multithreading</emphasis>. Multithreading
	significa que múltiples instancias del área de texto pueden
	ejecutarse al mismo tiempo, compartiendo el área de
	datos. Estas instancias, denominadas threads(hilos) pueden ser
	ejecutadas en paralelo en múltiples CPUs.
      </para>
    </sect2>
  </sect1>

  <sect1 id="concepts-fshierarchy">
    <title>Jerarquía del sistema de archivos</title>

    <sect2 id="concepts-fshierarchy-structure">
      <title>Estructura</title>

      <para>
	Los sistemas operativos almacenan datos en sistemas de
	archivos.  Un sistema de archivos es basicamente una
	estructura tipo-árbol de directorios que contienen archivos,
	como el sistema operativo, los programas de usuario y los
	datos de usuario. La mayoría de los sistemas de archivos
	pueden tambien almacenar metadatos sobre los archivos y
	directorios, por ejemplo fechas de acceso y modificación. En
	GNU/Linux hay una sola jerarquía del sistema de archivos, esto
	quiere decir que GNU/Linux no tiene letras de dispositivos
	(e.g. A:, C:, D:) para diferentes sistemas de archivos como
	DOS y Windows. El sistema de archivos se parece a un árbol,
	con un directorio raíz (que no tiene directorio padre),
	ramificaciones y hojas (directorios sin sub-directorios). El
	directorio raíz es siempre denotado con una barra
	(<quote>/</quote>). Los directorios se separan por el mismo
	caracter.
      </para>

      <figure id="filesystem-structure">
        <title>La estructura del sistema de archivos</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../../images/fs-structure.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        <xref linkend="filesystem-structure"/> shows the structure of
        a filesystem.  You can see that the root directory
        <filename>/</filename> has two child directories:
        <filename>bin</filename> and <filename>home</filename>. The
        <filename>home</filename> directory has two child directories,
        <filename>joe</filename> and <filename>jack</filename>. The
        diagram shows the full pathname of each directory.  The same
        notation is used for files. Suppose that there is a file named
        <filename>memo.txt</filename> in the
        <filename>/home/jack</filename> directory, the full path of
        the file is <filename>/home/jack/memo.txt</filename>.
      </para>

      <para>
        Each directory has two special entries,
        <quote><filename>.</filename></quote>, and
        <quote><filename>..</filename></quote>.  The first refers to
        the directory itself, the second to the parent
        directory. These entries can be used for making relative
        paths. If you are working in the <filename>jack</filename>
        directory, you can refer to the the
        <filename>/home/joe</filename> directory with
        <filename>../joe</filename>.
      </para>
    </sect2>

    <sect2 id="concepts-fshierarchy-mounting">
      <title>Mounting</title>

      <para>
        You might wonder how it is possible to access other devices
        or partitions than the hard disk partition which holds the
        root filesystem. Linux uses the same approach as UNIX for
        accessing other filesystems. Linux allows the system
        administrator to connect a device to any directory in the
        filesystem structure. This process is named
        <emphasis>mounting</emphasis>.  For example, one could mount
        the CD-ROM drive to the <filename>/cdrom</filename>
        directory. If the mount is correct, the files on the CD-ROM
        can be accessed through this directory. The mounting process
        is described in detail in <xref
        linkend="basics-filesystem-mounting"/>.
      </para>
    </sect2>

    <sect2 id="concepts-fshierarchy-commondirs">
      <title>Common directories</title>

      <para>
        The Filesystem Hierarchy Standard Group has attempted to
        create a standard that describes which directories should
        be available on a GNU/Linux system. Currently, most major
        distributions use the Filesystem Hierarchy Standard (FHS)
        as a guideline. This section describes some mandatory
        directories on GNU/Linux systems.
      </para>

      <para>
        Please note that GNU/Linux does not have a separate directory
        for each application (like Windows). Instead, files are ordered by
        function and type. For example, the binaries for most
        common user programs are stored in
        <filename>/usr/bin</filename>, and their libraries in
        <filename>/usr/lib</filename>. This is a short overview of
        the important directories on a Slackware Linux system:
      </para>


      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">/bin</emphasis>: essential
            user binaries that should still be available in case the 
            <filename>/usr</filename> is not mounted.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/dev</emphasis>: device files.
            These are special files used to access certain devices.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/etc</emphasis>: the
            <filename>/etc</filename> directory contains all important
            configuration files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/home</emphasis>: contains home
            directories for individual users.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/lib</emphasis>: essential system
            libraries (like glibc),
            and kernel modules.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/root</emphasis>: home directory for the 
            <emphasis>root</emphasis> user.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/sbin</emphasis>: essential binaries
            that are used for system administration.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/tmp</emphasis>: a world-writable
            directory for temporary files.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/bin</emphasis>: stores the majority
            of the user binaries.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/lib</emphasis>: libraries that are
            not essential for the system to boot.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/usr/sbin</emphasis>: nonessential
            system administration binaries.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">/var</emphasis>: variable data files,
            like logs.
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="concepts-devices">
    <title>Devices</title>

    <sect2 id="concepts-devices-intro">
      <title>Introduction</title>

      <para>
        In GNU/Linux virtually everything is represented as a file, including
        devices. Every GNU/Linux system has a directory with special files, named
        <filename>/dev</filename>. Each file in the <filename>/dev</filename>
        directory represents a device or pseudo-device. A device file
        has two special numbers associated with it, the
        <emphasis>major</emphasis> and the <emphasis>minor</emphasis>
        device number. The kernel knows which device a device
        file represents by these device numbers. The following example shows
        the device numbers for the <filename>/dev/zero</filename> device file:
      </para>

      <screen>
$ <command>file /dev/zero</command>
/dev/zero: character special (1/5)
      </screen>

      <para>
        The <command>file</command> command can be used to determine the
        type of a file. This particular file is recognized as a device file
        that has <emphasis>1</emphasis> as the major device number,
        and <emphasis>5</emphasis> as the minor device number.
      </para>

      <para>
        If you have installed the kernel source package, you can find
        a comprehensive list of all major devices with their minor and
        major numbers in
        <filename>/usr/src/linux/Documentation/devices.txt</filename>. An
        up-to-date list is also available on-line through the Linux
        Kernel Archives<footnote>
          <para>
            <ulink url="ftp://ftp.kernel.org/pub/linux/docs/device-list/" />
          </para>
        </footnote>.
      </para>

      <para>
        The Linux kernel handles two types of devices:
        <emphasis>character</emphasis> and <emphasis>block</emphasis>
        devices. Character devices can be read byte by byte,
        block devices can not. Block devices are read per block (for example
        4096 bytes at a time). Whether a device is a character or block device
        is determined by the nature of the device. For example, most storage
        media are block devices, and most input devices are character devices.
        Block devices have one distinctive advantage, namely that they can be
        cached. This means that commonly read or written blocks are stored in
        a special area of the system memory, named the cache. Memory is much
        faster than most storage media, so much performance can be gained
        by performing common block read and write operations in memory.
        Of course, eventually changes have to be written to the storage
        media to reflect the changes that were made in the cache.
      </para>
    </sect2>

    <sect2 id="concepts-devices-atascsi">
      <title>ATA and SCSI devices</title>

      <para>
        There are two kinds of block devices that we are going to look into
        in detail, because understanding the naming of these devices is
        crucial for  partitioning a hard disk and mounting. Almost all modern
        computers with an x86 architecture use ATA hard disks and CD-ROMs.
        Under Linux these devices are named in the following manner:
      </para>

      <screen>
/dev/hda - master device on the first ATA channel
/dev/hdb - slave device on the first ATA channel
/dev/hdc - master device on the second ATA channel
/dev/hdd - slave device on the second ATA channel
      </screen>

      <para>
        On most computers with a single hard disk, the hard disk is the master
        device on the first ATA channel (<filename>/dev/hda</filename>), and
        the CD-ROM is the master device on the second ATA channel. Hard disk
        partitions are named after the disk that holds them plus a number.
        For example, <filename>/dev/hda1</filename> is the first partition
        of the disk represented by the <filename>/dev/hda</filename>
        device file.
      </para>

      <para>
        SCSI hard disks and CD-ROM drives follow an other naming convention.
        SCSI is not commonly used in most low-end machines, but USB drives
        and Serial ATA (SATA) drives are also represented as SCSI disks. The
        following device notation is used for SCSI drives:
      </para>

      <screen>
/dev/sda - First SCSI disk
/dev/sdb - Second SCSI disk
/dev/sdc - Third SCSI disk
/dev/scd0 - First CD-ROM
/dev/scd1 - Second CD-ROM
/dev/scd2 - Third CD-ROM
      </screen>

      <para>
        Partitions names are constructed in the same way as ATA disks;
        <filename>/dev/sda1</filename> is the first partition on the first
        SCSI disk.
      </para>

      <para>
        If you use the software RAID implementation of the Linux kernel, RAID
        volumes are available as <filename>/dev/mdn</filename>, in which
        <emphasis>n</emphasis> is the volume number starting at 0.
      </para>
    </sect2>
  </sect1>
</chapter>
