<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
  xmlns:xl="http://www.w3.org/1999/xlink" xml:lang="es"
  xml:id="chap-textproc">
  <title>Procesamiento de texto</title>

  <para>
    La manipulación de texto en una de las cosas en las que UNIX es
    excelente, porque conforma el corazón de la filosofía UNIX, como
    ya fué descrito en <xref linkend="chap-intro-unix" />. La mayoría
    de los comandos UNIX son programas simples que leen datos de una
    entrada estándar, realizan operaciones sobre los datos y envían el
    resultado a la salida estándar del programa. Estos programas
    actúan básicamente como filtros, que pueden ser conectados como
    una tubería. Esto permite que el usuario use las herramientas UNIX
    en formas en que sus desarrolladores nunca pensaron. En capítulos
    posteriores veremos como construir filtros simples por nuestra
    cuenta. <!-- XXX - xref -->
  </para>

  <para>
    Este capítulo describe algunos comandos UNIX simples pero
    importantes que pueden ser usados para manipular texto. Después de
    eso, indagaremos en las expresiones regulares, un sub-lenguaje que
    puede ser usado para igualar patrones de texto.
  </para>
 
  <sect1 xml:id="chap-textproc-simple">
    <title>Manipulación simple de texto</title>

    <sect2 xml:id="chap-textproc-simple-cat">
      <title>Repitiendo lo que esta dicho</title>

      <para>
	El filtro de texto mas simple es <command>cat</command>, no
	hace mas que enviar la información desde stdin a stdout:
      </para>

      <screen>
$ <userinput>echo "hello world" | cat</userinput>
hello world
      </screen>

      <para>
	Otra característica útil es que puede enviar el contenido de
	un archivo a la salida estándar:
      </para>

      <screen>
$ <userinput>cat file.txt</userinput>
Hello, this is the content of file.txt
      </screen>

      <para>
	<command>cat</command> realmente esta a la altura de su nombre
	cuando múltiples archivos son agregados como argumentos. Esto
	concatenará los archivos, de forma que enviará el contenido de
	todos los archivos a la salida estándar, en el mismo orden en
	que fueron especificados como argumentos. La siguiente
	pantalla demuestra esto:
      </para>

      <screen>
$ <userinput>cat file.txt file1.txt file2.txt</userinput>
Hello, this is the content of file.txt
Hello, this is the content of file1.txt
Hello, this is the content of file2.txt
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-wc">
      <title>Estadísticas de texto</title>

      <para>
	El comando <command>wc</command> provee estadísticas sobre un
	archivo o flujo de texto. Sin parámetro alguno, imprimirá el
	número de líneas, el número de palabras y el número de bytes
	respectivamente. Una palabra es delimitada por un caracter de
	espacio, o una secuencia de caracteres en de espacio.
      </para>

      <para>
	El siguiente ejemplo muestra el número de líneas, palabras y
	bytes en la cadena <quote>Hello world!</quote> de ejemplo:
      </para>

      <screen>
$ <userinput>echo "Hello world!" | wc</userinput> 
       1       2      13
      </screen>

      <para>
	Si solamente quisiera imprimir uno de estos componentes, puede
	usar uno de los parámetros <parameter
	class="command">-l</parameter> (líneas), <parameter
	class="command">-w</parameter> (palabras), o <parameter
	class="command">-c</parameter> (bytes). Por ejemplo,
	agregando el parámetro <parameter
	class="command">-l</parameter> mostrará el número de líneas en
	un archivo:
      </para>

      <screen>
$ <command>wc -l /usr/share/dict/words</command> 
  235882 /usr/share/dict/words
      </screen>

      <para>
	O también puede imprimir campos adicionales agregando un
	parámetro:
      </para>

      <screen>
$ <userinput>wc -lc /usr/share/dict/words</userinput>
 235882 2493082 /usr/share/dict/words
      </screen>

      <para>
	Por favor nótese que, sin importar el orden en que las opciones
	fueron especificadas, el orden de salida siempre será el mismo
	(líneas, palabras, bytes).
      </para>

      <para>
	Ya que <parameter class="command">-c</parameter> imprime el
	número de bytes, este parámetro podría no representar el
	número de caracteres contenidos en un texto, porque el
	conjunto de caracteres en uso puede ser mas amplio que un
	byte.  Para este fin, el parámetro <parameter
	class="command">-m</parameter> fué agregado para imprimir el
	número de caracteres en el texto, independientemente del
	conjunto de caracteres. <parameter
	class="command">-c</parameter> y <parameter
	class="command">-m</parameter> son sustitutos y nunca pueden
	ser usados al mismo tiempo.
      </para>

      <para>
	Las estadísticas que <command>wc</command> provee son mas 
	útiles de lo que parecen en la superficie. Por ejemplo, el 
	parámetro <parameter class="command">-l</parameter> es a veces 
	usado como un contador para la salida de un comando. 
	Esto es conveniente, porque muchos comandos separan unidades 
	lógicas usando una línea nueva. Suponga que quisiera contar el 
	número de archivos en su directorio home cuyo nombre termine con 
	<filename>.txt</filename>. Puede hacer esto combinando 
	<command>find</command> para hallar los archivos relevantes 
	y <command>wc</command> para contar el número de ocurrencias:
      </para>

      <screen>
$ <userinput>find ~ -name '*.txt' -type f | wc -l</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-tr">
      <title>Manipulando caracteres</title>

      <para>
	El comando <command>tr</command> puede ser usado para realizar
	tareas comunes de caracteres, como intercambiar, borrar o
	recortar secuencias de caracteres. Dependiendo de la operación,
	uno o dos conjuntos de caracteres deberían ser especificados.
	además de los caracteres normales, existen algunas secuencias
	de caracteres especiales que pueden ser usadas:
      </para>

      <variablelist>
	<varlistentry>
	  <term>\character</term>
	  <listitem>
	    <para>
	      Esta notación es usada para especificar caracteres de
	      escape, más notablemente <emphasis>\n</emphasis> (línea
	      nueva), <emphasis>\t</emphasis> (tabulación horizontal)
	      y <emphasis>\\</emphasis> (barra invertida).
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>character1-character2</term>
	  <listitem>
	    <para>
	      Inserta implícitamente todos los caracteres desde
	      <emphasis>character1</emphasis> a
	      <emphasis>character2</emphasis>. Esta notación debería
	      ser usada con cuidado, porque no siempre brinda el
	      resultado esperado. Por ejemplo, la secuencia
	      <emphasis>a-d</emphasis> podría producir
	      <emphasis>abcd</emphasis> para la configuración de
	      lenguaje local POSIX, pero esto puede no ser cierto para
	      otras configuraciones.
	      <!-- XXX - locale footnote -->
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[:class:]</term>
	  <listitem>
	    <para>
	      Iguala una predefinida clase de caracteres. Todas las
	      clases se muestran en <xref
	      linkend="chap-textproc-simple-tr-charclasses" />.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*]</term>
	  <listitem>
	    <para>
	      Repite el <emphasis>character</emphasis> hasta que el
	      segundo conjunto de caractere sea tan largo como el
	      primero. Esta notación solamente puede ser usada en el
	      segundo conjunto.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>[character*n]</term>
	  <listitem>
	    <para>
	      Repite el <emphasis>character</emphasis>
	      <emphasis>n</emphasis> veces.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <table xml:id="chap-textproc-simple-tr-charclasses">
	<title>Classes de caracteres tr</title>

	<tgroup cols="2">
	  <thead>
	    <row><entry>Clase</entry><entry>Significando</entry></row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>[:alnum:]</entry>
	      <entry>Todas las letras y números.</entry>
	    </row>
	    <row>
	      <entry>[:alpha:]</entry>
	      <entry>Letras.</entry>
	    </row>
	    <row>
	      <entry>[:blank:]</entry>
	      <entry>Espacios horizontales (e.g. espacios y
	      tabulaciones).</entry>
	    </row>
	    <row>
	      <entry>[:cntrl:]</entry>
	      <entry>Caracteres de control.</entry>
	    </row>
	    <row>
	      <entry>[:digit:]</entry>
	      <entry>Todos los dígitos (0-9).</entry>
	    </row>
	    <row>
	      <entry>[:graph:]</entry>
	      <entry>Todos los caracteres imprimibles, exceptos
	      espacios en blanco.</entry>
	    </row>
	    <row>
	      <entry>[:lower:]</entry>
	      <entry>Letras minúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:print:]</entry>
	      <entry>Todos los caracteres imprimibles, incluyendo
	      espacios horizontaltes, pero excluyendo espacios
	      verticales.</entry>
	    </row>
	    <row>
	      <entry>[:punct:]</entry>
	      <entry>Caracteres de puntuación.</entry>
	    </row>
	    <row>
	      <entry>[:space:]</entry>
	      <entry>Todos los espacios.</entry>
	    </row>
	    <row>
	      <entry>[:upper:]</entry>
	      <entry>Letras mayúsculas.</entry>
	    </row>
	    <row>
	      <entry>[:xdigit:]</entry>
	      <entry>Dígitos hexadecimales (0-9, a-f).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="chap-textproc-simple-tr-swapping">
	<title>Intercambio de caracteres</title>

	<para>
	  La operación por defecto de <command>tr</command> es
	  intercambiar (traducir) caracteres. Esto quiere decir que el
	  e<emphasis>n</emphasis>ésimo caracter en el primer conjunto
	  es reemplazado con el e<emphasis>n</emphasis>ésimo del
	  segundo conjunto. Por ejemplo, puede reemplazar todas las
	  <emphasis>e</emphasis>'s con <emphasis>i</emphasis>'s y
	  <emphasis>o</emphasis>'s con <emphasis>a</emphasis>'s con
	  una sola operación <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eo' 'ia'</userinput>
Hilla warld!
	</screen>

	<para>
	  Cuando el segundo conjunto no es tan largo como el primero,
	  el último caracter en el segundo conjunto será repetido. Sin
	  embargo, esto no aplica necesariamente a otros sistemas
	  UNIX. Entonces, si quiere usar <command>tr</command> de una
	  forma independiente del sistema, defina explícitamente qué
	  caracter debería ser repetido. Por ejemplo:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr 'eaiou' '[@*]'</userinput>
H@ll@ w@rld!
	</screen>

	<para>
	  Otra particularidad es el uso de la sintaxis de repetición
	  en el medio del conjunto. Suponga que el conjunto 1 es
	  <emphasis>abcdef</emphasis> y el conjunto 2
	  <emphasis>@[-*]!</emphasis>. <command>tr</command>
	  reemplazará <emphasis>a</emphasis> con
	  <emphasis>@</emphasis>, <emphasis>b</emphasis>,
	  <emphasis>c</emphasis>, <emphasis>d</emphasis> y
	  <emphasis>e</emphasis> con <emphasis>-</emphasis> y
	  <emphasis>f</emphasis> con <emphasis>!</emphasis>. Aunque
	  algunos otros sistemas UNIX reemplazan
	  <emphasis>a</emphasis> con <emphasis>@</emphasis> y el resto
	  de los caracteres con <emphasis>-</emphasis>. Entonces, una
	  notación mas correcta debería ser mas explícita
	  <emphasis>@[-*4]!</emphasis>, la cual entrega los mismos
	  resultados en virtualmente todos los sistemas UNIX:
	</para>

	<screen>
$ <userinput>echo 'abcdef' | tr 'abcdef' '@[-*4]!'</userinput>
@----!
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-squeezing">
	<title>Recortando secuencias de caracteres</title>

	<para>
	  Cuando el parámetro <parameter
	  class="command">-s</parameter> es usado,
	  <command>tr</command> recortará todos los caracteres en el
	  segundo conjunto. Esto significa que una secuencia de
	  caracteres repetidos será reducida a un caracter. Recortemos
	  el caracter &quot;<emphasis>e</emphasis>&quot;:
	</para>

	<screen>
$ <userinput>echo "Let's squeeze this." | tr -s 'e'</userinput>
Let's squeze this.
	</screen>

	<para>
	  Podemos combinar esto con la sustitución para mostrar un
	  ejemplo útil de <command>tr</command> en acción. Suponga
	  que quisiera marcar todas las vocales con el símbolo
	  <emphasis>arroba</emphasis> (<emphasis>@</emphasis>), con
	  las vocales consecutivas representadas por un signo
	  <emphasis>at</emphasis>. Esto puede hacerse fácilmente
	  entubando dos comandos <command>tr</command>:
	</para>

	<screen>
$ <userinput>echo "eenie meenie minie moe" | tr 'aeiou' '[@*]' | tr -s '@'</userinput>
@n@ m@n@ m@n@ m@
	</screen>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-tr-deleting">
	<title>Borrando caracteres</title>

	<para>
	  Finalmente, <command>tr</command> puede ser usado para
	  borrar caracteres. Si el parámetro <parameter
	  class="command">-d</parameter> es usado, todos los
	  caracteres del primer conjunto serán removidos:
	</para>

	<screen>
$ <userinput>echo 'Hello world!' | tr -d 'lr'</userinput>
Heo wod!
	</screen>
      </sect3>
    </sect2>

    <sect2 xml:id="chap-textproc-cutpaste">
      <title>Cortando y pegando columnas de texto</title>

      <para>
	El comando <command>cut</command> es proveído por sistemas
	UNIX para <quote>cortar</quote> una o más columnas de un
	archivo o flujo, imprimiéndolas en la salida estándar. A veces
	es útil seleccionar alguna información de un
	texto. <command>cut</command> provee tres formas de cortar
	información desde archivos:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Por byte.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Por caracter, lo cual no es lo mismo que cortar por byte
	    en sistemas que usan un conjunto de caracteres que usa mas
	    de ocho bits.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Por campo, el cual es delimitado por un caracter.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	En las tres aproximaciones, puede especificar el elemento a
	elegir por su número iniciando en <emphasis>1</emphasis>.
	Puede especificar un rango usango un guión
	(<emphasis>-</emphasis>). Entonces, <emphasis>M-N</emphasis>
	significa desde el eMésimo elemento al eNésimo elemento.
	Dejando M fuera (<emphasis>-N</emphasis>) selecciona todos los
	elementos del primer elemento hasta el eNésimo
	elemento. Dejando N fuera (<emphasis>M-</emphasis>) selecciona
	el eMésimo elemento hasta el último elemento. Múltiples
	elementos o rangos pueden ser combinados separándolos por
	comas (<emphasis>,</emphasis>). Entonces, por ejemplo,
	<emphasis>1,3-</emphasis> selecciona el primer y el tercer
	elementos hasta el último elemento.
      </para>

      <para>
	La información puede ser cortada por campo con el parámetro
	<parameter class="command">-f fields</parameter>. Por defecto,
	la tabulación horizontal es usada como separador. Demos un
	vistazo a <command>cut</command> en acción con un pequeño
	diccionario holandés-inglés:
      </para>

      <screen>
$ <userinput>cat dictionary</userinput>
appel   apple
banaan  banana
peer    pear
      </screen>

      <para>
	Podemos obtener todas las palabras en inglés seleccionando el
	primer campo:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary</userinput>
apple
banana
pear
      </screen>

      <para>
	Eso fue bastante sencillo. Ahora vamos a hacer lo mismo con un
	archivo que tiene puntos dobles como separador de
	campo. Fácilmente podemos intentar esto convirtiendo el
	diccionario con el comando <command>tr</command> que vimos
	previamente, reemplazando todas las tabulaciones con puntos
	dobles:
      </para>

      <screen>
$ <userinput>tr '\t' ':' &lt; dictionary &gt; dictionary-new</userinput>
$ <userinput>cat dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Si usamos el mismo comando como en el ejemplo previo, no
	obtendremos la salida correcta:
      </para>

      <screen>
$ <userinput>cut -f 2 dictionary-new</userinput>
appel:apple
banaan:banana
peer:pear
      </screen>

      <para>
	Lo que pasa es que el delimitador no pudo ser hallado. Si una
	línea no contiene el delimitador que esta siendo usado, el
	comportamiento por defecto de <command>cut</command> es
	imprimir la línea completa. Puede prevenir esto con el
	parámetro <parameter class="command">-s</parameter>.
      </para>

      <para>
	Para usar un delimitador diferente a la tabulación
	horizontal, agregue el parámetro <parameter
	class="command">-d delimter_char</parameter> para configurar
	el caracter delimitador. Entonces, en este caso de nuestro
	archivo <filename>dictionary-new</filename>, le pediremos a
	<command>cut</command> usar los puntos dobles como
	delimitador:
      </para>

      <screen>
$ <userinput>cut -d ':' -f 2 dictionary-new</userinput>
apple
banana
pear
      </screen>

      <para>
	Si un campo especificado no existe en una línea, ese campo en
	particular no es impreso.
      </para>

      <para>
	<parameter class="command">-b bytes</parameter> y <parameter
	class="command">-c characters</parameter> respectivamente
	seleccionan los bytes y caracteres del texto. En sistemas
	antiguos un caracter puede tener la longitud de un byte. Pero
	los sistemas actuales pueden proveer conjuntos de caracteres
	cuya longitud es mayor a un byte. Entonces, si quiere estar
	seguro de capturar caracteres completos, use el parámetro
	<parameter class="command">-c</parameter>. Un ejemplo
	entretenido del parámetro <parameter
	class="command">-c</parameter> en acción es encontrar los diez
	conjuntos mas comúnes de los primeros tres caracteres de una
	palabra. La mayoría de los sistemas UNIX proveen una lista de
	palabras que están separadas por una línea nueva. Podemos usar
	<command>cut</command> para obtener los tres primeros
	caracteres de las palabras en la lista, agregue <parameter
	class="command">uniq</parameter> <!-- XXX - where? --> para
	contar secuencias de caracteres idénticas, y use
	<command>sort</command> para ordenarlos de forma númerica
	(<command>sort</command> está descrito en <xref
	linkend="chap-textproc-simple-sort" />). Finalmente, usaremos
	<command>head</command> para obtener las secuencias más
	frecuentes:
      </para>

      <screen>
$ <userinput>cut -c 1-4 /usr/share/dict/words | uniq -c | sort -nr | head</userinput>
    254 inte
    206 comp
    169 cons
    161 cont
    150 over
    125 tran
    111 comm
    100 disc
     99 conf
     96 reco
      </screen>

      <para>
	Habiendo concluído con esos comandos UNIX en acción, nos
	moveremos hacia el comando <command>paste</command>, el cual
	combina archivos en columnas en un solo flujo de texto.
      </para>

      <para>
	El uso de <command>paste</command> es bastante simple,
	combinará todos los archivos dados como argumetos, separados
	por una tabulación. Con la lista de palabras en inglés y
	holandés, podemos generar un pequeño diccionario:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl</userinput>
apple   appel
banana  banaan
pear    peer
      </screen>

      <para>
	También puede combinar mas de dos archivos:
      </para>

      <screen>
$ <userinput>paste dictionary-en dictionary-nl dictionary-de</userinput> 
apple   appel   Apfel
banana  banaan  Banane
pear    peer    Birne
      </screen>

      <para>
	Si uno de los archivos es mas largo, el order de columna se
	mantiene y se usan entradas vacías para llenar las entradas de
	lo archivos mas cortos.
      </para>

      <para>
	Puede usar otro delimitador agregando el parámetro <parameter
	class="command">-d delimiter</parameter>. Por ejemplo, podemos
	crear un diccionario separado por puntos dobles:
      </para>

      <screen>
$ <userinput>paste -d ':' dictionary-en dictionary-nl</userinput>
apple:appel
banana:banaan
pear:peer
      </screen>

      <para>
	Normalmente, <command>paste</command> combina archivos como
	columnas diferentes. También puede dejar a
	<command>paste</command> usar las líneas de cada archivo como
	columnas y colocar las columnas para cada archivo en una línea
	separada. Esto se realiza con el parámetro <parameter
	class="command">-s</parameter>:
      </para>

      <screen>
$ <userinput>paste -s dictionary-en dictionary-nl dictionary-de</userinput>
apple   banana  pear
appel   banaan  peer
Apfel   Banane  Birne
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-simple-sort">
      <title>Ordenando texto</title>

      <para>
	UNIX ofrece el comando <command>sort</command> para ordenar
	texto. <command>sort</command> también puede verificar si un
	archivo está ordenado y combinar dos archivos ordenados.
	<command>sort</command> puede ordenar en base a diccionario y
	numérico. El tipo de ordenamiento por defecto es en base a
	diccionario. Esto significa que las líneas de texto son
	comparadas caracter por caracter, ordenados como esta
	especificado en la secuencia de comparación actual (la cual es
	especificada a través de la variable del sistema
	LC_COLLATE). Esto tiene una particularidad cuando esta
	ordenando números, por ejemplo, si tiene los números del 1 al
	10 en líneas diferentes, la secuencia será 1, 10, 2, 3,
	etc. Esto es causado por la interpretación de caracteres del
	ordenamiento de diccionario. Si quiere ordenar líneas por
	número, use el ordenamiento numérico.
      </para>

      <para>
	Si no se especifican parámetros adicionales,
	<command>sort</command> ordena la líneas de entradas en orden
	de diccionario. Por ejemplo:
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Como puede ver, la entrada esta correctamente
	ordenada. Algunas veces hay dos líneas idénticas. Puede
	combinar líneas idénticas agregando el parámetro <parameter
	class="command">-u</parameter>. Los dos ejemplos listados
	abajo ilustran esto.
      </para>

      <screen>
$ <userinput>cat &lt;&lt; EOF | sort</userinput>
orange
apple
banana
banana
EOF
apple
banana
banana
orange
$ <userinput>cat &lt;&lt; EOF | sort -u</userinput>
orange
apple
banana
banana
EOF
apple
banana
orange
      </screen>

      <para>
	Hay algunos parámetros idénticos que puede ayudar a modificar
	un poco el resultado:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    El parámetro <parameter class="command">-f</parameter>
	    hace que el ordenamiento sea sensible a minúsculas y
	    mayúsculas.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Si se agrega el parámetro <parameter
	    class="command">-d</parameter>, solamente caracteres en
	    blanco y alfanuméricos son usados para determinar el
	    orden.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    El parámetro <parameter class="command">-i</parameter>
	    hace que <command>sort</command> ignore los caracteres no
	    imprimibles.
	  </para>
	</listitem>
      </itemizedlist>


      <para>
	Puede ordenar archivos numéricamente agregando el parámetro
	<parameter class="command">-n</parameter>. Este parámetro
	detiene la lectura de la línea de entrada cuando un caracter
	no numérico es encontrado. Lo signos menos, punto decimal,
	miles de separadores, caracter de radio (que separa un
	exponencial de un número) y espacios en blanco pueden ser
	usados como parte de un número. Estos caracteres son
	interpretados donde sean aplicables.
      </para>

      <para>
	El siguiente ejemplo muestra el ordenamiento numérico en
	acción, entubando la salida de <command>du</command> a
	<command>sort</command>. Esto funciona porque
	<command>du</command> especifica el tamaño de cada archivo
	como el primer campo.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -n</userinput>
0       /bin/kernelversion
0       /bin/ksh
0       /bin/lsmod.modutils
0       /bin/lspci
0       /bin/mt
0       /bin/netcat
[...]
      </screen>

      <para>
	En este caso, la salida es probablemente inútil si quiere leer
	la salida en un paginador, porque los archivos mas pequeños
	son listados primero. Aquí es donde el parámetro <parameter
	class="command">-r</parameter> muestra su utilidad. Revierte
	el criterio de ordenamiento.
      </para>

      <screen>
$ <userinput>du -a /bin | sort -nr</userinput>
4692    /bin
1036    /bin/ksh93
668     /bin/bash
416     /bin/busybox
236     /bin/tar
156     /bin/ip
[...]
      </screen>

      <para>
	El parámetro <parameter class="command">-r</parameter> también
	funciona con ordenamientos de diccionario.
      </para>

      <para>
	Comúnmente, los archivos utilizan una disposición con
	múltiples columnas, y usted podría querer ordenar un archivo
	usando una columna diferente que la del primer archivo. Por
	ejemplo, considere el siguiente archivo de resultado nombrado
	<filename>score.txt</filename>:
      </para>

      <programlisting>
John:US:4
Herman:NL:3
Klaus:DE:5
Heinz:DE:3
      </programlisting>
     
    <para>
      Suponga que quisiera ordenar las entradas en este archivo por
      las dos letras del nombre del país. <command>sort</command> nos
      permite ordenar un archivo por columna con el parámetro
      <parameter class="command">-k col1[,col2]</parameter>. Donde
      desde <emphasis>col1</emphasis> hasta <emphasis>col2</emphasis>
      son columnas usadas como campos para ordenar la entrada. Si
      <emphasis>col2</emphasis> no es especificado, todos los campos
      hasta el final de la línea son usados. Entonces, si quiere usar
      solamente una columna, use <parameter class="command">-k
      col1,col1</parameter>. También puede especificar el caracter de
      inicio de la columna agregando un periodo
      (<emphasis>.</emphasis>) y un índice de caracter. Por ejemplo,
      <parameter class="command">-k 2.3,4.2</parameter> significa la
      segunda columna empezando desde el tercer caracter, la tercera
      columna y la cuarta columna hasta (e incluyendo) el segundo
      caracter.
    </para>

    <!-- XXX - document -b? Mentioned lateron (-k) -->

    <para>
      Aún hay otra particularidad cuando se ordenan columnas: por
      defecto, <command>sort</command> usa un espacio en blanco como
      separador de columna. Si quiere usar un caracter separador
      diferente, deberá usar el parámetro <parameter>-t
      char</parameter>, usado para especificar el campo separador.
    </para>

    <para>
      Con los parámetros <parameter class="command">-t</parameter> y
      <parameter class="command">-k</parameter> combinados, podemos
      ordenar el archivo de resultados por código de país:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 2,2 scores.txt</userinput>
Heinz:DE:3
Klaus:DE:5
Herman:NL:3
John:US:4
    </screen>

    <para>
      Entonces, cómo podemos ordenar el archivo por el resultado?.
      Obviamente debemos pedir a sort que use la tercer columna. Pero
      sort usa por defecto un ordenamiento de diccionario
      <footnote><para>(Por supuesto, eso realmente no importa en este
      caso, porque no usamos números mayores que 9 y virtualmente
      todos los conjuntos de caracteres tienen números en un orden
      numérico).</para></footnote>. Podría usar <parameter
      class="command">-n</parameter>, pero <command>sort</command>
      también permite una aproximación mas sofisticada. Puede
      concatenar uno o más de <emphasis>n</emphasis>,
      <emphasis>r</emphasis>, <emphasis>f</emphasis>,
      <emphasis>d</emphasis>, <emphasis>i</emphasis>, o
      <emphasis>b</emphasis> al especificador de columna. Estas letras
      representan los parámetros de <command>sort</command> con el
      mismo nombre. Si solamente agrega la columna inicial, agréguelo
      a esa columna, de otra forma, agréguelo a la columna final.
    </para>

    <para>
      El siguiente comando ordena el archivo por resultado:
    </para>

    <screen>
$ <userinput>sort -t ':' -k 3n /home/daniel/scores.txt</userinput>
Heinz:DE:3
Herman:NL:3
John:US:4
Klaus:DE:5
    </screen>

    <para>
      Es bueno seguir esta aproximación, en vez de usar variantes de
      parámetros, porque <command>sort</command> le permite usar mas
      de un parámetro <parameter class="command">-k</parameter>. Y
      agregando estas banderas a la especificación de columnas, le
      permitirá ordenar por diferentes columnas en formas diferentes.
      Por ejemplo, usando <command>sort</command> con los parámetros
      <parameter class="command">-k 3,3n -k 2,2</parameter> ordenará
      todas las líneas numéricamente en base a la tercer columna. Si
      algunas líneas tienen números idénticos en la tercer columna,
      puede ser ordenadas mas adelante con un ordenamiento de
      diccionario de la segunda columna.
    </para>

    <para>
      Si quiere verificar si un archivo ya esta ordenado, puede usar
      el parámetro <parameter class="command">-c</parameter>. Si el
      archivo estaba ordenado, sort retornará el valor
      <emphasis>0</emphasis>, de otra forma <emphasis>1</emphasis>.
      Podemos verificar esto imprimiendo (<command>echo</command>) el
      valor de la variable <emphasis>?</emphasis>, la cual contiene el
      valor de retorno del último comando ejecutado.
    </para>

    <screen>
$ <userinput>sort -c scores.txt ; echo $?</userinput>
1
$ <userinput>sort scores.txt | sort -c ; echo $?</userinput>
0
    </screen>

    <para>
      El segundo comando muesta que esto realmente funciona, al
      entubar la salida del ordenamiento de
      <filename>scores.txt</filename> hacia <command>sort</command>.
    </para>

    <para>
      Finalmente, puede combinar dos archivos ordenados con el
      parámetro <parameter class="command">-m</parameter>, manteniendo
      el order correcto. Esto es mas rápido que concatenar y
      reordenar ambos archivos.
    </para>

    <screen>
# <userinput>sort -m scores-sorted.txt scores-sorted2.txt</userinput>
    </screen>
  </sect2>

    <sect2 xml:id="chap-textproc-simple-diff">
      <title>Diferencias entre archivos</title>

      <para>
	Ya que los flujos y archivos de texto son muy importantes en UNIX,
	es a veces útil mostrar las diferencias entre dos archivos de
	texto. Las principales utilidades para trabajar con diferencias
	entre archivos son <command>diff</command> y
	<command>patch</command>. <command>diff</command> muestra las
	diferencias entre archivos. La salida de
	<command>diff</command> puede ser procesada por
	<command>patch</command> para aplicar los cambios entre dos
	archivos a un archivo. Los <quote>diffs</quote> también forman
	la base de lo sistemas control de versiones. <!-- XXX - xref
	to version management chapters --> Las siguientes secciones
	describen <command>diff</command> y <command>patch</command>.
	Para tener algo de material para trabajar, los siguientes
	archivos de código fuente en C son usados para demostrar estos
	comandos. Estos archivos tienen los nombres
	<filename>hello.c</filename> y <filename>hello2.c</filename>
	respectivamente.
      </para>

      <programlisting>
<![CDATA[
#include <stdio.h>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
]]>
      </programlisting>

      <programlisting>
#include &lt;stdio.h&gt;
<emphasis role="bold">#include &lt;time.h&gt;</emphasis>

void usage(char *programName);

int main(int argc, char *argv[]) {
  if (argc == 1) {
    usage(argv[0]);
    return 1;
  }

  printf("Hello %s!\n", argv[1]);

  <emphasis role="bold">time_t curTime = time(NULL);</emphasis>
  <emphasis role="bold">printf("The date is %s\n", asctime(localtime(&amp;curTime)));</emphasis>


  return 0;
}

void usage(char *programName) {
  printf("Usage: %s name\n", programName);
}
      </programlisting>

      <sect3 xml:id="chap-textproc-simple-diff-diff">
	<title>Listando diferencias entre archivos</title>

	<para>
	  Suponga que ha recibido un programa
	  <filename>hello.c</filename> de un amigo y usted lo ha
	  modificado para retornar al usuario la fecha y hora
	  actual. Podría solamente enviar a su amigo el programa
	  actualizado. Pero si un archivo crece mucho, puede volverse
	  incómodo, porque los cambios son difíciles de ubicar.
	  Además de eso, su amigo también puede haber recibido
	  modificaciones de otras personas. Esta es la típica
	  situación donde <command>diff</command> se vuelve
	  útil. <command>diff</command> muestra las diferencias entre
	  dos archivos. Su sintaxis mas básica es <command>diff file
	  file2</command>, la cual muestra las diferencias entre
	  <filename>file</filename> y
	  <filename>file2</filename>. Intentémos esto con nuestros
	  archivos fuente:
	</para>

	<screen>
$ diff hello.c hello2.c
1a2 <co xml:id="co-diff-append" />
> #include &lt;time.h&gt; <co xml:id="co-diff-incoming" />
12a14,17
>   time_t curTime = time(NULL);
>   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
>
	</screen>

	<para>
	  Las adiciones desde <filename>hello2.c</filename> son
	  visibles en esta salida, pero el formato puede verse un poco
	  extraño. Actualmente, estos son comandos que pueden ser
	  interpretados por el editor de línea
	  <command>ed</command>. Veremos una salida con un formato mas
	  cómodo después de tocar la superficie del formato de salida
	  por defecto.
	</para>

	<para>
	  Dos elementos diferentes pueden ser identificados en esta
	  salida:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-append">
	    <para>
	      Este es un comando <application>ed</application> que
	      especifica que el texto debería ser concatenado
	      (<literal>a</literal>) después de la línea
	      <literal>2</literal>.
	    </para>
	  </callout>
	  <callout arearefs="co-diff-incoming">
	    <para>
	      Este es el texto actual a ser concatenado después de la
	      segunda línea. El signo
	      <quote><emphasis>&gt;</emphasis></quote> Es usado para
	      marcar líneas que son agregadas.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Los mismos elementos son usados para agregar el segundo
	  bloque de texto. Qué hay de las líneas que fueron
	  removidas?. Fácilmente podemos ver cómo estan representadas
	  intercambiando los dos parámetros en
	  <command>diff</command>, mostrando las diferencias entre
	  <filename>hello2.c</filename> y
	  <filename>hello.c</filename>:
	</para>

	<screen>
$ <userinput>diff hello2.c hello.c</userinput>
2d1 <co xml:id="co-diff-delete" />
&lt; #include &lt;time.h&gt; <co xml:id="co-diff-outgoing" />
14,16d12
&lt;   time_t curTime = time(NULL);
&lt;   printf("The date is %s\n", asctime(localtime(&amp;curTime)));
&lt;
	</screen>

	<para>
	  Se pueden identificar los siguientes elementos:
	</para>

	<calloutlist>
	  <callout arearefs="co-diff-delete">
	    <para>
	      Este es el comando borrar para
	      <application>ed</application> (<literal>d</literal>),
	      indicando que la línea 2 debería ser borrada. El segundo
	      comando de borrado usa un rango (línea 14 a 17).
	    </para>
	  </callout>
	  <callout arearefs="co-diff-outgoing">
	    <para>
	      El texto que va a ser removido es precedido por el signo
	      <quote>&lt;</quote>.
	    </para>
	  </callout>
	</calloutlist>

	<!-- XXX - Changed lines? -->

	<para>
	  Esto ya es suficiente de la salida
	  <application>ed</application>-style. El programa GNU diff
	  incluído en Slackware Linux soporta las llamadas diffs
	  unificadas. Las diffs unificadas son bastante leíble y
	  proveen un contexto por defecto. <command>diff</command>
	  puede proveer una salida unificada con la bandera <parameter
	  class="command">-u</parameter>:
	</para>

	<screen>
$ diff -u hello.c hello2.c
--- hello.c     2006-11-26 20:28:55.000000000 +0100 <co xml:id="co-udiff-origfile" />
+++ hello2.c    2006-11-26 21:27:52.000000000 +0100 <co xml:id="co-udiff-newfile" />
@@ -1,4 +1,5 @@ <co xml:id="co-udiff-lines" />
 #include &lt;stdio.h&gt; <co xml:id="co-udiff-unmodified" />
+#include &lt;time.h&gt; <co xml:id="co-udiff-add" />

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&amp;curTime)));
+
   return 0;
 }

	</screen>

	<para>
	  Los siguientes elementos pueden ser encontrados en la salida:
	</para>

	<calloutlist>
	  <callout arearefs="co-udiff-origfile">
	    <para>
	      El nombre del archivo original y la fecha de la última
	      modificación.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-newfile">
	    <para>
	      El nombre del archivo cambiando y la fecha de la última
	      modificación.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-lines">
	    <para>
	      Este par de números muestran la ubicación y tamaño del
	      fragmento de texto que afecta al archivo original y al
	      archivo modificado. Entonces, en este caso los números
	      indican que el fragmento afectado en el archivo original
	      empieza en la línea 1 y tiene una longitud de cuatro
	      líneas. En el archivo modificado el fragmento afectado
	      empieza en la línea 1 y tiene una longitud de cinco
	      líneas. Diferentes fragmentos en la salida diff son
	      iniciados por esta cabecera.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-unmodified">
	    <para>
	      Una línea que no es precedidad por un signo menos
	      (<emphasis>-</emphasis>) o mas (<emphasis>+</emphasis>)
	      no tiene cambios. Las líneas sin modificaciones son
	      incluídas porque brindan información contextual y
	      previene la creación de demasiados fragmentos. Si
	      solamente existen algunas pocas líneas modificadas entre
	      los cambios, <command>diff</command> eligirá crear un
	      solo fragmento, en vez de dos.
	    </para>
	  </callout>
	  <callout arearefs="co-udiff-add">
	    <para>
	      Una línea que es precedida por un signo mas
	      (<emphasis>+</emphasis>) es una adición al archivo
	      modificado, comparado con el archivo original.
	    </para>
	  </callout>
	</calloutlist>

	<para>
	  Como en el estilo <command>diff</command> de
	  <application>ed</application>, podemos ver algunas
	  eliminaciones intercambiando los nombres de archivo:
	</para>

	<screen>
$ <userinput>diff -u hello2.c hello.c</userinput>
<![CDATA[
--- hello2.c    2006-11-26 21:27:52.000000000 +0100
+++ hello.c     2006-11-26 20:28:55.000000000 +0100
@@ -1,5 +1,4 @@
 #include <stdio.h>
-#include <time.h>

 void usage(char *programName);

@@ -11,9 +10,6 @@

   printf("Hello %s!\n", argv[1]);

-  time_t curTime = time(NULL);
-  printf("The date is %s\n", asctime(localtime(&curTime)));
-
   return 0;
 }

]]>
	</screen>

	<para>
	  Como puede ver en esta salida, la líneas que fueron removidas
	  del archivo modificado, en contraste al archivo original son
	  precedidas por el signo menos (<emphasis>-</emphasis>).
	</para>

	<para>
	  Cuando esta trabajando con grandes cantidades de archivos, a
	  veces es útil comparar directorios completos. Por ejemplo,
	  si tiene la versión original de las fuentes de un programa
	  en un directorio nombrado <filename>hello.orig</filename> y
	  la versión modificada en un directorio nombrado
	  <filename>hello</filename>, puede usar el parámetro
	  <parameter class="command">-r</parameter> para comparar
	  recursivamente ambos directorios. Por ejemplo:
	</para>

	<screen>
$ diff -ru hello.orig hello
diff -ru hello.orig/hello.c hello/hello.c
<![CDATA[
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

]]>
	</screen>

	<para>
	  Debe notarse qiu esto solamente comparará archivos que estan
	  disponibles en ambos directorios. La versión GNU de diff que
	  es usada en Slackware Linux provee el parámetro <parameter
	  class="command">-N</parameter>. Este parámetro trata a los
	  archivos que existen solamente en uno de los dos directorios
	  como si fuesen archivos vacíos. Entonces, por ejemplo, si
	  hemos agregado un archivo nombrado
	  <filename>Makefile</filename> al directorio
	  <filename>hello</filename>, usando el parámetro <parameter
	  class="command">-N</parameter> dará la siguiente salida:
	</para>

	<screen>
$ <userinput>diff -ruN hello.orig hello</userinput>
<![CDATA[
diff -ruN hello.orig/hello.c hello/hello.c
--- hello.orig/hello.c  2006-12-04 17:37:14.000000000 +0100
+++ hello/hello.c       2006-12-04 17:37:48.000000000 +0100
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <time.h>

 void usage(char *programName);

@@ -10,6 +11,9 @@

   printf("Hello %s!\n", argv[1]);

+  time_t curTime = time(NULL);
+  printf("The date is %s\n", asctime(localtime(&curTime)));
+
   return 0;
 }

diff -ruN hello.orig/Makefile hello/Makefile
--- hello.orig/Makefile 1970-01-01 01:00:00.000000000 +0100
+++ hello/Makefile      2006-12-04 17:39:44.000000000 +0100
@@ -0,0 +1,2 @@
+hello: hello.c
+       gcc -Wall -o $@ $<
]]>
	</screen>

	<para>
	  Como puede ver el fragmento indicador dice que el fragmento
	  en el archivo original empieza en la línea 0 y tiene una
	  longitud de 0 líneas.
	</para>

	<para>
	  Los usuarios UNIX comúnmente intercambian la salida de
	  <command>diff</command>, usualmente llamada
	  <quote>diffs</quote> o <quote>parches (patches)</quote>. La
	  siguiente sección le mostrará cómo puede manejar los
	  diffs. Pero ahora usted ya es capaz de crearlos,
	  redireccionando la salida de diff a un archivo. Por ejemplo:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c > hello_add_date.diff</userinput>
	</screen>

	<para>
	  Si tiene múltiple diff, puede fácilmente combinarlos a un
	  diff concatenando los diffs:
	</para>

	<screen>
$ <userinput>cat diff1 diff2 diff3 > combined_diff</userinput>
	</screen>

	<para>
	  Pero asegúrese de que fueron creados desde el mismo
	  directorio si quiere usar la utilidad
	  <command>patch</command>, cubierta en la siguiente sección.
	</para>
      </sect3>

      <sect3 xml:id="chap-textproc-simple-diff-patch">
	<title>Modificando archivos con la salida de diff</title>

	<para>
	  Suponga que alguien podría enviarle la salida de
	  <command>diff</command> para un archivo que usted ha creado.
	  Sería tedioso incorporar manualmente todos los cambios que
	  fueron hechos. Afortunadamente, el comando
	  <command>patch</command> puede hacer esto por usted.
	  <command>patch</command> acepta diffs en la entrada estándar
	  y tratará de cambiar el archivo original, de acuerdo a las
	  diferencias registradas en el diff. Entonces, por ejemplo,
	  si tenemos el archivo <filename>hello.c</filename> y el
	  parche que producimos previamente, basados en los cambios
	  entre <filename>hello.c</filename> y
	  <filename>hello2.c</filename>, podemos parchar
	  <filename>hello.c</filename> para igualarlo a su
	  contraparte:
	</para>

	<screen>
$ <userinput>patch &lt; hello_add_date.diff</userinput>
patching file hello.c
	</screen>

	<para>
	  Si tiene <filename>hello2.c</filename>, puede verificar se los
	  archivos son idénticos ahora:
	</para>

	<screen>
$ <userinput>diff -u hello.c hello2.c</userinput>
	</screen>

	<para>
	  No hay salida, entonces ese es el caso. Una de las buenas
	  características de <command>patch</command> es que puede
	  revertir los cambios a través de un diff, usando el
	  parámetro <parameter class="command">-R</parameter>:
	</para>

	<screen>
$ <userinput>patch -R &lt; hello_add_date.diff</userinput>
	</screen>

	<para>
	  En estos ejemplos, el archivo original es parchado. Algunas
	  veces usted podría quere aplicar el parche a otro archivo
	  con nombre diferente. Puede hacer esto proveyendo el nombre
	  del archivo como el último argumento:
	</para>

	<screen>
$ <userinput>patch helloworld.c &lt; hello_add_date.diff</userinput>
patching file helloworld.c
	</screen>

	<para>
	  También puede usar el comando <command>patch</command> con
	  los diffs que generamos con el parámetro <parameter
	  class="command">-r</parameter>, pero debe tener algo de
	  cuidado. Suponga que la cabecera de un archivo en particular
	  en el diff es como el siguiente:
	</para>

	<literallayout>
--------------------------
|diff -ruN hello.orig/hello.c hello/hello.c
|--- hello.orig/hello.c 2006-12-04 17:37:14.000000000 +0100
|+++ hello/hello.c      2006-12-04 17:37:48.000000000 +0100
--------------------------
	</literallayout>

	<para>
	  Si procesa este diff con <command>patch</command>, tratará
	  de cambiar <filename>hello.c</filename>. Entonces, el
	  directorio que contiene este archivo tiene que ser el
	  directorio activo. Puede usar la ruta completa del archivo
	  con el parámetro <parameter class="command">-p
	  n</parameter>, donde <emphasis>n</emphasis> es el número de
	  componentes del nombre de la ruta que debería ser
	  separados. Un valor de <emphasis>0</emphasis> usará la ruta
	  como está especificada en el parche, <emphasis>1</emphasis>
	  separará el primer componente de la ruta, etc. En este
	  ejemplo, la separación del primer componente resultará en el
	  parcheo de <filename>hello.c</filename>. De acuerdo al
	  estándar Single UNIX Specification versión 3, la ruta que es
	  precedida por <emphasis>---</emphasis> debería ser usada
	  para construir el archivo a ser parchado. La versión GNU de
	  patch no sigue el estándar aqui. Entonces, es mejor
	  separarlo al punto donde ambos nombres de directorios son
	  iguales (este es usualmente el directorio raíz del árbol
	  siendo cambiado). En la mayoría de los casos donde rutas
	  relativas son usadas, esto puede realizarse usando
	  <emphasis>-p 1</emphasis>. Por ejemplo:
	</para>

	<!-- XXX - add more examples for -p n -->

	<screen>
$ <userinput>cd hello.orig</userinput>
$ <userinput>patch -p 1 &lt; ../hello.diff</userinput>
	</screen>

	<para>
	  O puede usar el parámetro <parameter
	  class="command">-d</parameter> para especificar en qué
	  directorio debe ser aplicado el cambio:
	</para>

	<screen>
$ <userinput>patch -p 1 -d hello.orig &lt; hello.diff</userinput>
patching file hello.c
patching file Makefile
	</screen>

	<para>
	  Si quiere mantener un respaldo cuando esta cambiando un
	  archivo, puede usar el parámetro <parameter
	  class="command">-b</parameter> de
	  <command>patch</command>. Esto creará una copia de cada
	  archivo afectado con el nombre
	  <filename>filename.orig</filename>, antes de cambiar el
	  archivo:
	</para>

	<screen>
$ <userinput>patch -b &lt; hello_add_date.diff</userinput>
$ <userinput>ls -l hello.c*</userinput>
-rw-r--r-- 1 daniel daniel 382 2006-12-04 21:41 hello.c
-rw-r--r-- 1 daniel daniel 272 2006-12-04 21:12 hello.c.orig
	</screen>

	<para>
	  Algunas veces un archivo no puede ser parchado. Por ejemplo,
	  si ya a sido parchado, ha cambiado mucho para aplicar el
	  parche limpiamente, o si el archivo no existe en absoluto.
	  En este caso, los fragmento que no pudieron ser almacenados
	  en un archivo con el nombre
	  <filename>filename.rej</filename>, donde
	  <emphasis>filename</emphasis> es el archivo que
	  <command>patch</command> trató de modificar.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-textproc-regexps">
    <title>Expresiones regulares</title>

    <sect2 xml:id="chap-textproc-regexps-intro">
      <title>Introducción</title>

      <para> 
          En un día normal, usted comunmente querrá igualar algún
	  texto con cierto patrón, en vez de cadenas específicas.
	  Muchas utilidades UNIX implementan un lenguaje para igualar
	  patrones de texto, <emphasis>espresiones regulares (regular
	  expressions, regexps)</emphasis>. A través del tiempo las
	  expresiones regulares crecieron, ahora hay básicamente tres
	  sintaxis de expresiones regulares: 
      </para>

      <itemizedlist>
        <listitem>
          <para> Expresiones regulares UNIX tradicionales. </para>
        </listitem>
        <listitem>
          <para> Expresiones regulares extendidas POSIX. </para>
        </listitem>
        <listitem>
          <para> Expresiones regulares compatibles con Perl
          (Perl-compatible regular expressions, PCRE). </para>
        </listitem>
      </itemizedlist>

      <para>
	Las regexps POSIX son un conjunto agregado de regexps UNIX y
	PCREs son un conjunto agregado de regexps POSIX. La sintaxis
	que una aplicación soporta difiere entre aplicación, pero casi
	todas las aplicaciones soportan al menos regexps POSIX.
      </para>

      <para>
	Cada unidad sintáctica en una regexp expresa una de las
	siguientes cosas:
      </para>

      <itemizedlist>
        <listitem>
          <para>
	    <emphasis role="bold">Un caracter</emphasis>: esta es la
	    base de toda expresión regular, un caracter o un conjunto
	    de caracteres a ser igualados. Por ejemplo, la letra
	    <emphasis>p</emphasis> o el signo
	    <emphasis>,</emphasis>. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Cuantificación</emphasis>: un 
	    cuantificador especificar cuántas veces debería igualarse 
	    el caracter precedente o un conjunto de caracteres.
	    </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Alternación</emphasis>: la
            alternación es usada para igualar <quote>a o b</quote> en
            donde <emphasis>a</emphasis> y <emphasis>b</emphasis>
            pueden ser un caracter o una regexp. </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">Agrupado</emphasis>: esto es usado
            para agrupar sub-expresiones, entonces esa cuantificación
            o alternación puede ser aplicada al grupo. </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="chap-textproc-regexps-traditional">
      <title>Regexps UNIX tradicionales</title>

      <para>
	Esta sección describe regexps tradicionales UNIX. Debido a una
	falta de estandarización, la sintaxis exacta puede diferir un
	poco entre utilidades. Usualmente, la página manual de un
	comando provee mas información detallada sobre las expresiones
	regulares soportadas o tradicionales. Es recomendable aprender
	las regexps tradicionales, pero usar las regexps POSIX para
	sus propios scripts.
      </para>

      <sect3 xml:id="chap-textproc-regexps-traditional-characters">
        <title>Igualando caracteres</title>

        <para>
	  Los caracteres son igualados por su cuenta. Si un caracter
	  en específico es usado como un caracter sintáctico para
	  regexps, puede igualar ese caracter agregando una barra
	  inversa. Por ejemplo, <emphasis>\+</emphasis> iguala el
	  caracter del signo mas. </para>

        <para>
	  Un período (<emphasis>.</emphasis>) iguala cualquier
	  caracter, por ejemplo, el regexp <emphasis>b.g</emphasis>
	  iguala <emphasis>bag</emphasis>, <emphasis>big</emphasis> y
	  <emphasis>blg</emphasis>, pero no
	  <emphasis>bit</emphasis>. </para>

        <para>
	  El caracter de periodo, a veces provee demasiada libertad.
	  Puede usar corchetes (<emphasis>[]</emphasis>) para
	  especificar caracteres que pueden ser igualados. Por
	  ejemplo, el regexp <emphasis>b[aei]g</emphasis> iguala
	  <emphasis>bag</emphasis>, <emphasis>beg</emphasis> y
	  <emphasis>big</emphasis>, pero nada mas. También puede
	  igualar cualquier caracter excluyendo los de un conjunto
	  usando corchetes y usando el signo de intercalación
	  (<emphasis>^</emphasis>) como el primer caracter.  Por
	  ejemplo, <emphasis>b[^aei]g</emphasis> iguala cualquier
	  cadena de tres caracteres que inicia con
	  <emphasis>b</emphasis> y termina con <emphasis>g</emphasis>,
	  con excepción de <emphasis>bag</emphasis>,
	  <emphasis>beg</emphasis> y <emphasis>big</emphasis>. También
	  es posible igualar un rango de caracteres usando un guión
	  (<emphasis>-</emphasis>). Por ejemplo,
	  <emphasis>a[0-9]</emphasis> iguala una cadena seguida por un
	  solo caracter numérico. </para>

        <para>
	  Dos caracteres especiales, el signo de intercalación
	  (<emphasis>^</emphasis>) y el signo de dolar
	  (<emphasis>$</emphasis>), respectivamente igualan el inico y
	  fin de una línea. Esto es muy útil para el parseo de
	  archivos. Por ejemplo, puede igualar todas las líneas que
	  empiezan con un numeral (<emphasis>#</emphasis>) con el
	  regexp <emphasis>^#</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-quantification">
        <title>Cuantificación</title>

        <para>
	  El signo de cuantificación mas simple que las expresiones
	  regulares soportan es el asterisco (Kleene)
	  (<emphasis>*</emphasis>). Esto iguala cero o instancias
	  arbitrarias del caracter precedente. Por ejemplo,
	  <emphasis>ba*</emphasis> iguala <emphasis>b</emphasis>,
	  <emphasis>ba</emphasis><emphasis>baa</emphasis>, etc.
	  Debería estar consciente de que un solo caracter seguido de
	  un asterisco sin contexto alguno iguala toda cadena, porque
	  <emphasis>c*</emphasis> también iguala una cadena que tiene
	  cero <emphasis>c</emphasis> caracteres. </para>

        <para>
	  Se pueden especificar repeticiones mas específicas con
	  llaves acompañadas de caracteres de escape.
	  <emphasis>\{x,y\}</emphasis> iguala el caracter precedente
	  al menos <emphasis>x</emphasis> veces, pero no mas de
	  <emphasis>y</emphasis> veces. Entonces,
	  <emphasis>ba\{1,3\}</emphasis> iguala
	  <emphasis>ba</emphasis>, <emphasis>baa</emphasis> y
	  <emphasis>baaa</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-grouping">
        <title>Agrupar</title>

        <para>
	  Paréntesis acompañados de caracteres de escape agrupan
	  varios caracteres juntos, entonces usted puede aplicar
	  cuantificación o alternación a un grupo de caracteres. Por
	  ejemplo, <emphasis>\(ab\)\{1,3\}</emphasis> iguala
	  <emphasis>ab</emphasis>, <emphasis>abab</emphasis> y
	  <emphasis>ababab</emphasis>. </para>
      </sect3>

      <sect3 xml:id="chap-textproc-regexps-traditional-alternation">
        <title>Alternación</title>

        <para>
	  Una barra vertical acompañada del caracter de escape
	  (<emphasis>\|</emphasis>) le permite igualar cualquiera de
	  dos expresiones. Esto no es útil para caracteres solos,
	  porque <emphasis>a\|b</emphasis> es equivalente a
	  <emphasis>[ab]</emphasis>, pero es útil en conjunción o
	  agrupación. Suponga que quisiera una expresión que iguala
	  <emphasis>apple</emphasis> y <emphasis>pear</emphasis>, pero
	  nada mas. Esto peude hacerse fácilmente con la barra
	  vertical <emphasis>(apple)|(pear)</emphasis>. </para>
      </sect3>
    </sect2>

      <sect2 xml:id="chap-textproc-regexps-posix">
	<title>Expresiones regulares extendidas POSIX</title>

	<para>
	  Las expresiones regulares POSIX construídas sobre
	  expresiones regulares tradicionales, agregando algunas otras
	  primitivas útiles. Otra diferencia confortante es que los
	  parentesis de agrupación, símbolo de cualificación y el
	  símbolo de alternación (<emphasis>|</emphasis>) no estan
	  acompañados de caracteres de escape. Si los acompaña alguno,
	  igualarán los caracteres literales en su cuenta, así
	  resultando en el comportamiento opuesto a las expresiones
	  regulares tradicionales. La mayoría de las personas
	  encuentran las expresiones regulares extendidas POSIX mucho
	  mas cómodas, haciéndolas ampliamente usadas.
	</para>

	<sect3 xml:id="chap-textproc-regexps-posix-characters">
	  <title>Igualando caracteres</title>

	  <para>
	    La igualación normal de caracteres no cambia comparada con
	    las expresiones regulares descritas en <xref
	    linkend="chap-textproc-regexps-traditional-characters" />.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-quantification">
	  <title>Cuantificación</title>

	  <para>
	    Además del asterisco Kleene (<emphasis>*</emphasis>), que
	    iguala el caracter precedente o agrupa cero o mas veces,
	    las expresione regulares extendidas POSIX agregan dos
	    nuevos primitivos simples de cuantificación.  El símbolo
	    mas (<emphasis>+</emphasis>) iguala el caracter precedente
	    o agrupa una o mas veces. Por ejemplo,
	    <emphasis>a+</emphasis>, iguala <emphasis>a</emphasis> (o
	    cualquier cadena con mas <emphasis>a</emphasis>s
	    consecutivas), pero no iguala cero
	    <emphasis>a</emphasis>s. El caracter de símbolo de
	    pregunta (<emphasis>?</emphasis>) iguala el caracter
	    precedente cero o mas veces. Entonces
	    <emphasis>ba?d</emphasis> iguala <emphasis>bd</emphasis> y
	    <emphasis>bad</emphasis>, pero no
	    <emphasis>baad</emphasis> o <emphasis>bed</emphasis>.
	  </para>

	  <para>
	    Las llaves son usadas para repetición, como las
	    expresiones regulares tradicionales. Sin embargo, la barra
	    inversa debería ser omitida. Para igualar
	    <emphasis>ba</emphasis> y <emphasis>baa</emphasis>, uno
	    debería usar <emphasis>ba{1,2}</emphasis> en vez de
	    <emphasis>ba\{1,2\}</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-grouping">
	  <title>Agrupar</title>

	  <para>
	    Agrupar se hace de la misma forma que en las expresiones
	    regulares tradicionales, dejando fuera los caracteres de escape
	    antes de los paréntesis. Por ejemplo,
	    <emphasis>(ab){1,3}</emphasis> iguala
	    <emphasis>ab</emphasis>, <emphasis>abab</emphasis> y
	    <emphasis>ababab</emphasis>.
	  </para>
	</sect3>

	<sect3 xml:id="chap-textproc-regexps-posix-alternation">
	  <title>Alternación</title>

	  <para>
	    La alternación se hace en la misma forma que en las
	    expresiones regulares tradicionales, dejando fuera los
	    caracteres de escape antes de la barra vertical. Entonces,
	    <emphasis>(apple)|(pear)</emphasis> iguala
	    <emphasis>apple</emphasis> y <emphasis>pear</emphasis>.
	  </para>
	</sect3>
      </sect2>

      <!--      
      <sect2 xml:id="chap-textproc-regexps-perl"> <title>Perl</title>
      </sect2>
    -->

  </sect1>

  <sect1 xml:id="chap-textproc-grep">
    <title>grep</title>

    <!-- XXX - document -c, -l, -x, -n, -q parameters -->

    <sect2 xml:id="chap-textproc-grep-basic">
      <title>Uso básico de grep</title>

      <para>
	Hemos arribado a una de las mas importantes utilidades de el
	sistema UNIX y a la primera ocasión de probar y usar
	expresiones regulares. El comando <command>grep</command> es
	usado para buscar patrones en un archivo o flujo de texto.
	Este patrón es una expresión regular y puede ser una expresión
	regular básica o una expresion extendida POSIX (cuando el
	parámetro <parameter class="command">-E</parameter> es
	usado). Por defecto, <command>grep</command> escribirá las
	líneas que fueron igualadas en la salida estándar. En la
	sintaxis mas básica, puede especificar una expresión regular
	como un argumento y <command>grep</command> buscará igualdades
	en el texto desde la entrada estándar. Esta es una buena forma
	de practicar un poco con expresiones regulares.
      </para>

      <screen>
$ <userinput>grep '^\(ab\)\{2,3\}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	El ejemplo previo muestra una expresión regular básica en
	acción, que iguala una línea que consiste en la cadena
	<emphasis>ab</emphasis> repetida dos o tres veces. Puede hacer
	lo mismo con las expresiones regulares extendidas POSIX,
	agregando el parámetro <parameter
	class="command">-E</parameter> (por extendido):
      </para>

      <screen>
$ <userinput>grep -E '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
<userinput>abab</userinput>
abab
<userinput>ababab</userinput>
ababab
<userinput>abababab</userinput>
      </screen>

      <para>
	Ya que el comportamiento por defecto de
	<command>grep</command> es leer desde la entrada estándar,
	usted puede agregarla a una tubería para obtener partes
	interesantes de la salida de los comandos precedentes en la
	misma. Por ejemplo, si quisiera buscar la cadena
	<emphasis>2006</emphasis> en la tercera columna de un archivo,
	podría combinar los comandos <command>cut</command> y
	<command>grep</command>:
      </para>

      <screen>
$ <userinput>cut -f 3 | grep '2006'</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-files">
      <title>Usando grep con archivos</title>

      <para>
	Naturalmente, <command>grep</command> también puede leer
	directamente un archivo, en vez de la entrada estándar. Como
	es usual, esto se realiza agregando lo archivos a ser leídos
	como los últimos argumentos. El siguiente ejemplo imprimirá
	todas las líneas del archivo <filename>/etc/passwd</filename>
	que empiezan con la cadena <emphasis>daniel:</emphasis>.
      </para>

      <screen>
$ <userinput>grep "^daniel" /etc/passwd</userinput>
daniel:*:1001:1001:Daniel de Kok:/home/daniel:/bin/sh
      </screen>

      <!-- XXX - filename notation when multiple files are specified -->

      <para>
	Con la opción <parameter class="command">-r</parameter>,
	<command>grep</command> atravesará recursivamente una
	estructura de directorio, tratando de hallar igualdades en
	cada archivo encontrado durante el procesamiento. Sin embargo,
	es mejor combinar <command>grep</command> con
	<command>find</command> y el operando
	<emphasis>-exec</emphasis> en scripts que tienen que ser
	portables.
      </para>

      <screen>
$ <userinput>grep -r 'somepattern' somedir</userinput>
      </screen>

      <para>
	es el no-portable equivalente funcional de 
      </para>

      <screen>
$ <userinput>find /somedir -type f -exec grep 'somepattern' {} \; -print</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-pattern">
      <title>Comportamiento de patrón</title>

      <para>
	<command>grep</command> también puede imprimir todas las
	líneas que no igualan el patrón que fué usado. Esto se realiza
	agregando el parámetro <parameter
	class="command">-v</parameter>:
      </para>

      <screen>
$ <userinput>grep -Ev '^(ab){2,3}$'</userinput>
<userinput>ab</userinput>
ab
<userinput>abab</userinput>
<userinput>ababab</userinput>
<userinput>abababab</userinput>
abababab
      </screen>

      <para>
	Si quiere usar el patrón sin importar mayúsculas o minúsculas,
	puede agregarel parámetro <parameter
	class="command">-i</parameter>. Por ejemplo:
      </para>

      <screen>
$ <userinput>grep -i "a"</userinput>
<userinput>a</userinput>
a
<userinput>A</userinput>
A
      </screen>

      <para>
	También puede igualar una cadena literalmente con el parámetro
	<parameter class="command">-F</parameter>:
      </para>

      <screen>
$ <userinput>grep -F 'aa*'</userinput>
<userinput>a</userinput>
<userinput>aa*</userinput>
aa*
      </screen>
    </sect2>

    <sect2 xml:id="chap-textproc-grep-multiplepatterns">
      <title>Usando patrones múltiples</title>

      <para>
	Como hemos visto, puede usar el caracter de alternación
	(<emphasis>|</emphasis>) para igualar dos o mas
	sub-patrones. Si dos patrones que quisiera igualar difieren
	mucho, es mas cómodo crear dos patrones diferentes.
	<command>grep</command> le permite usar mas de un patrón
	separando patrones con un caracter de línea nueva. Entonces,
	por ejemplo, si quisiera imprimir líneas que igualan los
	patrones <emphasis>a</emphasis> o <emphasis>b</emphasis>,
	puede hacerlo fácilmente iniciando una nueva línea:
      </para>

      <screen>
$ <userinput>grep 'a
b'</userinput>
<userinput>a</userinput>
a
<userinput>b</userinput>
b
c
      </screen>

      <para>
	Esto funciona, porque se usan comillas y la consola pasa lo
	parámetros entre comillas literalmente. Sin embargo, debe
	admitirse que no es muy amigable. <command>grep</command>
	acepta uno mas parámetros <parameter class="command">-e
	pattern</parameter>, dando la oportunidad de especificar mas
	de un parámetro en una línea.  La invocación de
	<command>grep</command> en el ejemplo previo puede ser
	reescrita como:
      </para>

      <screen>
$ <userinput>grep -e 'a' -e 'b'</userinput>
      </screen>
    </sect2>
  </sect1>
</chapter>
