<?xml version="1.0" encoding="UTF-8"?>

<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
	 xml:id="chap-shell">
  <title>La consola</title>

  <sect1 xml:id="chap-shell-intro">
    <title>Introducción</title>

    <para>
      En este capítulo veremos el ambiente de trabajo tradicional
      para entornos UNIX: la consola. La consola es un intérprete 
      que puede ser usado intera y no interactivamente. Cuando la
      consola es usada de forma no interactiva, trabaja como un simple 
      pero potente lenguaje script.
    </para>

    <para>
      El procedimiento para iniciar la consola depende del modo de inicio
      de sesión, sea en modo texto o gráfico. Si esta iniciando sesión
      en modo texto la consola es inmediatamente iniciada despues de 
      ingresar su contraseña (correcta). Si utiliza un administrador 
      gráfico de sesiones como KDM, inicie sesión de forma normal, y 
      busque en su gestor de ventanas o el menú del entorno de escritorio
      por una entrada llamada <quote>XTerm</quote>, <quote>Terminal</quote> 
      o <quote>Konsole</quote>. XTerm es un emulador de terminal, despues
      de que el emulador de terminal es iniciado la consola se inicia.
    </para>
		
    <para>
      Antes de ir mas lejos, tenemos que advertir que Slackware Linux
      provee mas de una consola. Existen dos consolas que ganaron 
      popularidad a través del tiempo, la consola Bourne y la consola
      C. En este capítulo describiremos consolas Bourne que cumplan 
      los estandares IEEE 1003.1. Bash (Bourne Again Shell) y Ksh (Korn Shell)
      cumplen con estos estandares. Entonces, es una buena idea utilizar
      una de estas consolas. Usted puede ver facilmente cual consola 
      esta siendo ejecutada en el sistema, a traves de la ejecución 
      del comando <command>echo $SHELL</command>. Esto es lo que una 
      consola Bash reportaría:
    </para>

    <screen>
$ <userinput>echo $SHELL</userinput>
/bin/bash
    </screen>
		
    <para>
      Si esta utilizando una consola diferente, puede cambiar su consola
      por defecto. Antes asignar una consola diferente, debe establecer la
      ruta completa de la misma. Puede hacer esto con el comando <command>which</command>. 
      Por ejemplo: 
    </para>

    <screen>
$ <userinput>which bash</userinput>
/bin/bash
$ <userinput>which ksh</userinput>
/bin/ksh
    </screen>

    <para>
      En este sistema Slackware, la ruta completa a la consola bash es 
      <filename>/bin/bash</filename>, y para la consola ksh <filename>/bin/ksh</filename>. 
      Con esta información, y el comando <command>chsh</command> puede 
      cambiar la consola por defecto. El siguiente ejemplo asignará 
      a bash como la consola por defecto:
    </para>

    <screen>
$ <userinput>chsh -s /bin/bash</userinput>
Changing shell for daniel.
Password:
Shell changed.
    </screen>

    <para>
      La nueva consola será activada despues de cerrar la sesión 
      de la consola actual (con el comando <command>logout</command> 
      o <command>exit</command>), o abriendo una nueva ventana
      X terminal si esta ejecutando X11.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-executing">
    <title>Ejecutando comandos</title>

    <para>
      Una consola interactiva es utilizada para iniciar programas 
      ejecutando comandos. Existen dos tipos de comandos que una 
      consola puede iniciar:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Comandos built-in:</emphasis> los comnandos built-in 
	  estan integrados en la consola. Comandos built-in comúnmente
	  usados son: <command>cd</command>, <command>fg</command>,
	  <command>bg</command>, and <command>jobs</command>.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Comandos externos:</emphasis> los comandos externos 
	  son programas que no son parte del shell, y estan almacenados 
	  de forma separada en el sistema de archivos. Comandos externos 
	  comúnmente usados son:<command>ls</command>, <command>cat</command>,
	  <command>rm</command>, and <command>mkdir</command>.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Todos los comandos del consola se ejecutan con la misma sintaxis:
    </para>
		
    <screen>
<command>commandname [argument1 argument2 ... argumentn]</command>
    </screen>

    <para>
      El número de argumentos es arbitrario, y siempre son pasados 
      al comando. El comando puede decidir que hacer con estos 
      argumentos.
    </para>

    <para>
      Todos los comandos built-in pueden ser ejecutados siempre, ya que 
      son parte de la consola. Los comandos externos pueden ser ejecutados 
      por su nombre cuando el programa esta en la ruta de busqueda de la 
      consola. De lo contrario, se debe especificar la ruta al programa. 
      La ruta de busqueda de la consola se almacena en una variable llamada  
      <emphasis>PATH</emphasis>. Una variable es una pieza nombrada de 
      memoria, de la cual el contenido puede ser cambiado. Podemos ver el 
      contenido de la variable PATH de la siguiente forma:
    </para>

    <screen>
$ <userinput>echo $PATH</userinput>
/usr/kerberos/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/daniel/bin
    </screen>

    <para>
      Las rutas de directorio en la variable <emphasis>PATH</emphasis> estan 
      separadas con el caracter (<emphasis>:</emphasis>). Usted puede usar 
      el comando <command>which</command> para verificar si un comando dado 
      se encuentra en la ruta actual de la consola. Puede realizar esto proveyendo 
      el comando como argumento a <command>which</command>. Por ejemplo:
    </para>

    <screen>
$ <userinput>which pwd</userinput>
/bin/pwd
$ <userinput>which sysstat</userinput>
/usr/bin/which: no sysstat in (/usr/kerberos/bin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/daniel/bin)
    </screen>

    <para>
      Si un programa no esta en la ruta, todavía puede ejecutarlo 
      ingresando su ruta absoluta o relativa.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-moving">
    <title>Navegando</title>

    <para>
      Es a veces necesario saltar a través de varias partes de una linea, 
      y alterarla, cuando esta editando comandos extensos. Ambas consolas 
      <command>bash</command> y <command>ksh</command> tienen atajos 
      de teclado para realizar tareas comunes. Existen dos modos consola, 
      en donde los atajos difieren. Estos modos corresponden en su 
      comportamiento con dos editores populares para UNIX. Estos editores 
      son <command>vi</command> y <command>emacs</command>. En este libro 
      solamente cubriremos los atajos EMACS-like. Puede revisar en que 
      modo se ejecuta una consola imprimiendo la variable 
      <emphasis>SHELLOPTS</emphasis>. En el primer ejemplo la consola es 
      usada en modo <emphasis>emacs</emphasis>, en el segundo ejemplo el 
      modo <emphasis>vi</emphasis> es usado. Identifique el modo buscando 
      las cadenas <emphasis>emacs</emphasis> o <emphasis>vi</emphasis> 
      en el contenido de la variable.
    </para>

    <screen>
$ <userinput>echo $SHELLOPTS</userinput>
braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
    </screen>

    <screen>
$ <userinput>echo $SHELLOPTS</userinput>
braceexpand:hashall:histexpand:history:interactive-comments:monitor:vi
    </screen>

    <para>
      Si su consola esta actualmente usando el modo <emphasis>vi</emphasis>, 
      puede cambiarla a modo <emphasis>emacs</emphasis> asignado la 
      opcion <emphasis>emacs</emphasis>:
    </para>

    <screen>
$ <userinput>set -o emacs</userinput>
    </screen>

    <para>
      Con el modo <emphasis>emacs</emphasis> activado, puede empezar 
      a utilizar los atajos de teclado. Tomaremos en cuenta tres 
      tipos de atajos: atajos de edicion de caracteres, atajos de 
      edicion de palabras y atajos de edicion de linea. Luego en 
      este capitulo, daremos un vistazo a algunos atajos que son 
      usados para obtener entradas del historial de comandos.
    </para>

    <sect2 xml:id="chap-shell-moving-char">
      <title>Editando caracteres</title>

      <para>
      El primer grupo de atajos tiene caracteres como su unidad lógica, 
      esto quiere decir que permiten operaciones de edicion sobre caracteres
      de linea de comando. <xref linkend="chap-shell-moving-char-shortcuts-move" /> 
      provee una introducción de los atajos que son usados para desplazarse 
      a través de una linea por caracter.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-move">
	<title>Desplazándose por caracter</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-b</entry>
	      <entry>Desplaza un caracter hacia atras.</entry>
	    </row>
	    <row>
	      <entry>Ctrl-f</entry>
	      <entry>Desplaza un caracter hacia adelante.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
    Estos atajos son sencillos, y no hacen nada inesperado. Suponga 
    que ha tipeado la siguiente linea:
      </para>

      <screen>
find ~/music -name '*.ogg' - -print<emphasis role="cursor">&#32;</emphasis>
      </screen>

      <para>
    El cursor estará al final. Ahora usted puede moverse al inicio 
    de la linea mantieniendo <emphasis>Ctrl-b</emphasis> presionado:
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music - -name '*.ogg' -print
      </screen>

      <para>
    De la misma forma, puede puede volver al final de la linea manteniendo  
    <emphasis>Ctrl-f</emphasis> presionado. Existe un error en esta linea, 
    porque hay un guion erróneo. Para remover este guion, puede utilizar el 
    atajo de borrado de caracter.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-delete">
	<title>Borrando caracteres</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-h</entry>
	      <entry>Borra un caracter antes del cursor. Tiene 
	      el mismo efecto que utilizar la tecla Retroceso en 
	      la mayoría de los ordenadores personales.</entry>
	    </row>
	    <row>
	      <entry>Ctrl-d</entry>
	      <entry>Borra el caracter sobre el que esta el cursor.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
    Puede eliminar el guion de dos formas. La primera es mover el  
    cursor hasta el guion:
      </para>

      <screen>
find ~/music <emphasis role="cursor">-</emphasis> -name '*.ogg' -print
      </screen>

      <para>
    y presionar <emphasis>Ctrl-d</emphasis> dos veces. Esto eliminará 
    el guion y el espacio que le sigue:
      </para>

      <screen>
find ~/music <emphasis role="cursor">-</emphasis>name '*.ogg' -print
      </screen>

      <para>
    Observando el fragmento original, la otra opción es posicionar 
    el cursor en el espacio siguiente al guion: 
      </para>

      <screen>
find ~/music -<emphasis role="cursor">&#32;</emphasis> -name '*.ogg' -print
      </screen>

      <para>
    y presionar <emphasis>Ctrl-h</emphasis> dos veces para eliminar los 
    dos caracteres previos, el guion y el espacio anterior al guion. El 
    resultado será el mismo, excepto que el cursor se posicionará en: 
      </para>

      <screen>
find ~/music<emphasis role="cursor">&#32;</emphasis>-name '*.ogg' -print
      </screen>

      <para>
      Una de las mejores características de la mayoría de las consolas 
      modernas es que se pueden intercambiar caracteres. Esto es útil si 
      se produce un error de tipeo en el cual dos caracteres son 
      intercambiados. <xref linkend="chap-shell-moving-char-shortcuts-swap" />  
      lista los atajos para intercambiar caracteres.
      </para>

      <table xml:id="chap-shell-moving-char-shortcuts-swap">
	<title>Intercambiando caracteres</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry><entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-t</entry>
	      <entry> Intercambia los caracteres sobre el cual 
	      esta el cursor, y el caracter previo. Esto es útil para 
	      correciones de tipeo rápidas.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
      Suponga que usted ha tipeado el siguiente comando:
      </para>

      <screen>
cat myreport.ttx
      </screen>

      <para>
    La extensión contiene un error de tipeo si intentaba ejecutar  
    <command>cat</command> <filename>myreport.txt</filename>. Puede
    ser corregido con el atajo de intercambio de caracteres. Primero 
    desplácese hacia el segundo caracter del par de caracteres que  
    están tipeados en orden incorrecto:
      </para>

      <screen>
cat myreport.tt<emphasis role="cursor">x</emphasis>
      </screen>

      <para>
    Puede entonces presionar <emphasis>Ctrl-t</emphasis>. Los caracteres 
    serán intercambiados, y el cursor se ubicará detrás de los caracteres 
    intercambiados:
      </para>

      <screen>
cat myreport.txt<emphasis role="cursor">&#32;</emphasis>
      </screen>
    </sect2>

    <sect2 xml:id="chap-shell-moving-word">
      <title>Editando palabras</title>

      <para>
    Con frecuencia es tedioso moverse a nivel de caracteres. Afortunadamente 
    las consolas Korn y Bash pueden moverse a traves de lineas a 
    nivel de palabras. Las palabras son secuencias de caracteres 
    separadas por un caracter especial, como un espacio.  
    <xref linkend="chap-shell-moving-word-shortcuts-move" /> resume los  
    atajos que pueden ser utilizados para navegar a través de una 
    linea por palabra.
      </para>

      <table xml:id="chap-shell-moving-word-shortcuts-move">
	<title>Moviendose por palabra</title>

	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Esc b</entry>
	      <entry>
	    Moverse hacia atrás al inicio de la palabra actual o previa.
	      </entry>
	    </row>
	    <row>
	      <entry>Esc f</entry>
	      <entry>
	    Moverse hacia adelante al último caracter de la palabra actual 
	    o la siguiente.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
    Como puede ver las letras de estos atajos son iguales a 
    aquellas utilizadas para caracteres. La lógica de movimiento  
    es un poco curiosa. Moverse hacia adelante coloca el cursor 
    al final de la palabra actual, no en el primer caracter de 
    la siguiente palabra como usted debe haber predicho. Veamos un 
    ejemplo. En el inicio, el cursor esta en el primer caracter de 
    la linea.
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music -name '*.ogg' -print
      </screen>

      <para>
    Presionando <emphasis>Esc f</emphasis> moverá el cursor 
    detrás de el último caracter de la primera palabra, que es  
    en este case <emphasis>find</emphasis>:
      </para>

      <screen>
find<emphasis role="cursor">&#32;</emphasis>~/music -name '*.ogg' -print
      </screen>

      <para>
    Yendo hacia adelante una vez mas colocará el cursor detrás de 	
	<emphasis>~/music</emphasis>:
      </para>

      <screen>
find ~/music<emphasis role="cursor">&#32;</emphasis>-name '*.ogg' -print
      </screen>

      <para>
    El movimiento hacia atrás coloca el cursor en el primer caracter 
    de la palabra actual, o en el primer caracter de la palabra 
    previa si el cursor esta actualmente en el primer caracter de 
    una palabra. Entonces, moverse hacia atrás una palabra en el 
    ejemplo previo colocará el cursor en la primera letra de 
    <quote>music</quote>:
      </para>

      <screen>
find ~/<emphasis role="cursor">m</emphasis>usic -name '*.ogg' -print
      </screen>

      <para>
        El borrado de palabras funciona igual al movimiento entre palabras, 
	pero los caracteres intermedios son eliminados. <xref
	linkend="chap-shell-moving-word-shortcuts-delete" /> enlista 
	los atajos usados para borrar palabras.
      </para>

      <table  xml:id="chap-shell-moving-word-shortcuts-delete">
	<title>Borrando palabras</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		Alt-d
	      </entry>
	      <entry>
		Elimina la palabra, iniciando en la posicion actual del cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>
		Alt-Backspace
	      </entry>
	      <entry>
		Elimina cada caracter desde la posicion actual del cursor 
		hasta el primer caracter de la palabra identificada.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	Finalmente, existen atajos útiles para manipular palabras. 
	Estos atajos estan listados en <xref
	linkend="chap-shell-moving-word-shortcuts-modify" />.
      </para>

      <table  xml:id="chap-shell-moving-word-shortcuts-modify">
	<title>Modificando palabras</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Teclas</entry>
	      <entry>Descripcion</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Alt-t</entry>
	      <entry>
		Intercambia la palabra actual con la palabra previa.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-u</entry>
	      <entry>
		Convierte los caracteres de la palabra a mayúscula, 
		iniciando en la posicion del cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-l</entry>
	      <entry>
		Convierte los caracteres de la palabra a minúscula, 
		iniciando en la posicion del cursor.
	      </entry>
	    </row>
	    <row>
	      <entry>Alt-c</entry>
	      <entry>
		Capitaliza el primer caracter de la palabra actual o 
		de la siguiente palabra.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	En el intercambio de palabras, si las palabras usadas son normales, 
	el comportamiento es predecible. Por ejemplo, si se tiene la 
	siguiente linea con el cursor en <quote>two</quote>
      </para>

      <screen>
one <emphasis role="cursor">t</emphasis>wo three
      </screen>

      <para>
	El intercambio afectará a <quote>two</quote> y
	<quote>one</quote>:
      </para>

      <screen>
two one three
      </screen>

      <para>
	Pero si hay caracteres no comunes en palabras, la consola intercambiará 
	la palabra con la palabra previa preservando el orden de los caracteres 
	especiales. Esto es muy útil para la edicion de argumentos de comandos. 
	Suponga que comete un error, mezclando la extension de archivos que 
	desea buscar, y el parámetro <emphasis>print</emphasis>:
      </para>

      <screen>
find ~/music -name '*.print' -ogg
      </screen>

      <para>
	Puede arreglar esto colocando el cursor en la segunda palabra 
	errónea, en este caso <quote>ogg</quote>, e intercambiando las 
	dos palabras. Esto le dará el resultado esperado:
      </para>

      <screen>
find ~/music -name '*.ogg' -print
      </screen>

      <para>
	Finalmente, existen atajos que cambian la capitalizacion de 
	las palabras. El atajo Alt-u convierte todos los caracteres 
	a mayúscula, iniciando en la posicion actual del cursor hasta 
	el final de la palabra. Entonces, si tenemos un nombre en 
	minúscula <quote>alice</quote>, capitalizando el nombre con 
	el cursor en <quote>i</quote> retorna <quote>alICE</quote>. Alt-l 
	tiene el mismo comportamiento, pero cambia las letras a minúscula. 
	Entonces, usando Alt-l en <quote>alICE</quote> con el cursor en 
	<quote>I</quote> cambiará la cadena a <quote>alice</quote>. Alt-c 
	cambia solamente el caracter sobre el cual el cursor esta, o el 
	caracter de la siguiente palabra que es encontrada, a mayúscula. 
	Por ejemplo, presionand Alt-c con el cursor sobre <quote>a</quote> 
	en <quote>alice</quote> producirá <quote>Alice</quote>.
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-moving-line">
      <title>Edición de lineas</title>

      <para>
	The highest level we can edit is the line itself.
	<xref linkend="chap-shell-moving-line-shortcuts-move" />
	lists the two movement shortcuts.
      </para>

      <table xml:id="chap-shell-moving-line-shortcuts-move">
	<title>Moving through lines</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Keys</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-a</entry>
	      <entry>
		Move to the beginning of the current line.
	      </entry>
	    </row>
	    <row>
	      <entry>Ctrl-e</entry>
	      <entry>
		Move to the end of the current line.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	Suppose that the cursor is somewhere halfway a line:
      </para>

      <screen>
find ~/music -name<emphasis role="cursor">&#32;</emphasis>'*.ogg' -print
      </screen>

      <para>
	Pressing Ctrl-e once will move the cursor to the end of the
	line:
      </para>

      <screen>
find ~/music -name '*.ogg' -print<emphasis role="cursor">&#32;</emphasis>
      </screen>

      <para>
	Pressing Ctrl-a will move the cursor to the beginning of the line:
      </para>

      <screen>
<emphasis role="cursor">f</emphasis>ind ~/music -name '*.ogg' -print
      </screen>

      <para>
	You can also delete characters by line level. The shortcuts
	are listed in <xref
	linkend="chap-shell-moving-line-shortcuts-delete" />.  These
	shortcuts work like movement, but deletes all characters that
	are encountered. Ctrl-k will delete the character the cursor
	is on, but Ctrl-x Backspace will not. Moving to the beginning
	of the line with Ctrl-a, followed by Ctrl-k, is a fast trick
	to remove a line completely.
      </para>

      <table xml:id="chap-shell-moving-line-shortcuts-delete">
	<title>Deleting lines</title>
	<tgroup cols="1" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>Keys</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>Ctrl-k</entry>
	      <entry>
		Delete all characters in the line, starting at the
		cursor position.
	      </entry>
	    </row>
	    <row>
	      <entry>Ctrl-x Backspace</entry>
	      <entry>
		Delete all characters in the line up till the current
		cursor position.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-shell-history">
    <title>Command history</title>

    <para>
      It often happens that you have to execute commands that you
      executed earlier. Fortunately, you do not have to type them all
      over again.  You can browse through the history of executed
      commands with the up and down arrows. Besides that it is also
      possible to search for a command. Press Control-r and start
      typing the command you want to execute. You will notice that
      bash will display the first match it can find. If this is not
      the match you were looking for you can continue typing the
      command (until it is unique and a match appears), or press
      Control-r once more to get the next match. When you have found
      the command you were looking for, you can execute it by pressing
      &lt;Enter&gt;.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-completion">
    <title>Completion</title>

    <para>
      Completion is one of the most useful functionalities of
      UNIX-like shells.  Suppose that you have a directory with two
      files named <filename>websites</filename> and
      <filename>recipe</filename>. And suppose you want to
      <command>cat</command> the file <filename>websites</filename>
      (<command>cat</command> shows the contents of a file), by
      specifying <filename>websites</filename> as a parameter to
      cat. Normally you would type <quote>cat websites</quote>, and
      execute the command. Try typing <quote>cat w</quote>, and hit
      the &lt;Tab&gt; key. Bash will automatically expand what you
      typed to <quote>cat websites</quote>.
    </para>

    <para>
      But what happens if you have files that start with the same
      letter? Suppose that you have the
      <filename>recipe1.txt</filename> and
      <filename>recipe2.txt</filename> files. Type <quote>cat
      r</quote> and hit &lt;Tab&gt;, Bash will complete the filename
      as far as it can. It would leave you with <quote>cat
      recipe</quote>. Try hitting &lt;Tab&gt; again, and Bash will
      show you a list of filenames that start with
      <quote>recipe</quote>, in this case both recipe files. At this
      point you have to help Bash by typing the next character of the
      file you need.  Suppose you want to <command>cat</command>
      <filename>recipe2.txt</filename>, you can push the &lt;2&gt;
      key. After that there are no problems completing the filename,
      and hitting &lt;Tab&gt; completes the command to <quote>cat
      recipe2.txt</quote>.
    </para>

    <para>
      It is worth noting that completion also works with
      commands. Most GNU/Linux commands are quite short, so it will
      not be of much use most of the time.
    </para>

    <para>
      It is a good idea to practice a bit with completion, it can save
      a lot of keystrokes if you can handle completion well. You can
      make some empty files to practice with using the
      <command>touch</command> command.  For example, to make a file
      named <filename>recipe3.txt</filename>, execute <command>touch
      recipe3.txt</command>.
    </para>
  </sect1>

  <sect1 xml:id="chap-shell-wildcards">
    <title>Wildcards</title>

    <para>
      Most shells, including Bash and ksh, support
      wildcards. Wildcards are special characters that can be used to
      do pattern matching. The table listed below displays some
      commonly used wildcards. We are going to look at several
      examples to give a general idea how wildcards work.
    </para>

    <table xml:id="chap-shell-wildcards-thewildcards">
      <title>Bash wildcards</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
	<thead>
	  <row>
	    <entry>Wildcard</entry> <entry>Matches</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>*</entry>
	    <entry>A string of characters</entry>
	  </row>
	  <row>
	    <entry>?</entry>
	    <entry>A single character</entry>
	  </row>
	  <row>
	    <entry>[]</entry>
	    <entry>A character in an array of characters</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <sect2 xml:id="chap-shell-wildcards-string">
      <title>Matching a string of characters</title>

      <para>
	As you can see in the table above the <quote>*</quote>
	character matches a string of characters. For example,
	<emphasis>*.html</emphasis> matches everything ending with
	<emphasis>.html</emphasis>, <emphasis>d*.html</emphasis>
	matches everything starting with a <emphasis>d</emphasis> and
	ending with <emphasis>.html</emphasis>.
      </para>

      <para>
	Suppose that you would like to list all files in the current
	directory with the <emphasis>.html</emphasis> extension, the
	following command will do the job:
      </para>

      <screen>
$ <userinput>ls *.html</userinput>
book.html        installation.html     pkgmgmt.html  usermgmt.html
filesystem.html  internet.html         printer.html  xfree86.html
gfdl.html        introduction.html     proc.html
help.html        slackware-basics.html shell.html
      </screen>

      <para>
	Likewise we could remove all files starting with an
	<emphasis>in</emphasis>:
      </para>

      <screen>
$ <userinput>rm in*</userinput>
      </screen>
    </sect2>

    <sect2 xml:id="chap-shell-wildcards-single">
      <title>Matching single characters</title>

      <para>
	The <quote>?</quote> wildcard works as the <quote>*</quote>
	wildcard, but matches single characters. Suppose that we have
	three files, <filename>file1.txt</filename>,
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>. The string
	<emphasis>file?.txt</emphasis> matches all three of these
	files, but it does not match <filename>file10.txt</filename>
	(<quote>10</quote> are two characters).
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-wildcards-set">
      <title>Matching characters from a set</title>

      <para>
	The <quote>[]</quote> wildcard matches every character between
	the brackets.  Suppose we have the files from the previous
	example, <filename>file1.txt</filename>,
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>. The string
	<emphasis>file[23].txt</emphasis> matches
	<filename>file2.txt</filename> and
	<filename>file3.txt</filename>, but not
	<filename>file1.txt</filename>.
      </para>
    </sect2>
  </sect1>

  <sect1 xml:id="chap-shell-inout">
    <title>Redirections and pipes</title>

    <para>
      One of the main features of UNIX-like shells are redirections
      and pipes.  Before we start to look at both techniques we have
      to look how most UNIX-like commands work. When a command is not
      getting data from a file, it will open a special pseudo-file
      named <emphasis>stdin</emphasis>, and wait for data to appear on
      it. The same principle can be applied for command output, when
      there is no explicit reason for saving output to a file, the
      pseudo-file <emphasis>stdout</emphasis> will be opened for
      output of data. This principle is shown schematically in <xref
      linkend="fig-shell-inout" />
    </para>

    <figure xml:id="fig-shell-inout">
      <title>Standard input and output</title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="../../images/shell-inout.png" format="PNG"/>
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      You can see <emphasis>stdin</emphasis> and
      <emphasis>stdout</emphasis> in action with the
      <command>cat</command> command. If cat is started without any
      parameters it will just wait for input on
      <emphasis>stdin</emphasis> and output the same data on
      <emphasis>stdout</emphasis>. If no redirection is used keyboard
      input will be used for <emphasis>stdin</emphasis>, and
      <emphasis>stdout</emphasis> output will be printed to the
      terminal:
    </para>

    <screen>
$ <userinput>cat</userinput>
<command>Hello world!</command>
Hello world!
    </screen>

    <para>
      As you can see cat will print data to
      <emphasis>stdout</emphasis> after inputting data to
      <emphasis>stdin</emphasis> using the keyboard.
    </para>

    <sect2 xml:id="chap-shell-inout-redir">
      <title>Redirection</title>

      <para>
	The shell allows you to take use of <emphasis>stdin</emphasis>
	and <emphasis>stdout</emphasis> using the <quote>&lt;</quote>
	and <quote>&gt;</quote>. Data is redirected in which way the
	sharp bracket points. In the following example we will
	redirect the md5 summaries calculated for a set of files to a
	file named <filename>md5sums</filename>:
      </para>

      <screen>
$ <userinput>md5sum * &gt; md5sums</userinput>
$ <userinput>cat md5sums</userinput> 
6be249ef5cacb10014740f61793734a8  test1
220d2cc4d5d5fed2aa52f0f48da38ebe  test2
631172a1cfca3c7cf9e8d0a16e6e8cfe  test3
      </screen>

      <para>
	As we can see in the <command>cat</command> output the output
	of the <command>md5sum *</command> output was redirected to
	the <filename>md5sums</filename> file. We can also use
	redirection to provide input to a command:
      </para>

      <screen>
$ <userinput>md5sum &lt; test1</userinput>
6be249ef5cacb10014740f61793734a8  -
      </screen>

      <para>
	This feeds the contents of the <filename>test1</filename> to
	<command>md5sum</command>.
      </para>
    </sect2>

    <sect2 xml:id="chap-shell-inout-pipes">
      <title>Pipes</title>

      <para>
	You can also connect the input and output of commands using
	so-called <emphasis>pipes</emphasis>. A pipe between commands
	can be made with the <quote>|</quote> character. Two or more
	combined commands are called a
	<emphasis>pipeline</emphasis>. <xref
	linkend="fig-shell-pipeline" /> shows a schematic overview of
	a pipeline consisting of two commands.
      </para>

      <figure xml:id="fig-shell-pipeline">
	<title>A pipeline</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="../../images/shell-pipeline.png" format="PNG"/>
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The <quote>syntax</quote> of a pipeline is: <command>command1
	| command2 ... | commandn</command>. If you know how the most
	basic UNIX-like commands work you can now let these commands
	work together. Let's look at a quick example:
      </para>

      <screen>
$ <userinput>cat /usr/share/dict/american-english | grep "aba" | wc -l</userinput>
123
      </screen>

      <para>
	The first command, <command>cat</command>, reads the
	dictionary file
	<filename>/usr/share/dict/american-english</filename>. The
	output of the <command>cat</command> command is piped to
	<command>grep</command>, which prints out all files containing
	the phrase <quote>aba</quote>.  In turn, the output of
	<quote>grep</quote> is piped to <command>wc -l</command>,
	which counts the number of lines it receives from
	<emphasis>stdin</emphasis>. Finally, when the stream is
	finished <command>wc</command> prints the number of lines it
	counted. So, combined three commands to count the number of
	lines containing the phrase <quote>aba</quote> in this
	particular dictionary.
      </para>

      <para>
	There are hundreds of small utilities that handle specific
	tasks. As you can imagine, together these commands provide a
	very powerful toolbox by making combinations using pipes.
      </para>
    </sect2>
  </sect1>
</chapter>
