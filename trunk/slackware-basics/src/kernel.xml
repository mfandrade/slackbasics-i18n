<!-- $Id: kernel.xml,v 1.1 2004/12/20 11:24:53 daniel Exp $ -->

<chapter id="kernel"> <?dbhtml filename="kernel.html"?>
  <title>Building a kernel</title>

  <sect1 id="kernel-introduction">
    <title>Introduction</title>

    <para>
      The &Kernel; kernel is shortly discussed in <xref
      linkend="whatis-linux" />. One of the advantages of &Kernel; is
      that the full sources are available (as most of the
      &Distribution; system). This means that you can recompile the
      kernel. There are many situations in which recompiling the kernel
      is useful. For example:
    </para> 

    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="bold">Making the kernel leaner</emphasis>:
          One can disable certain functionality of the kernel, to
          decrease its size. This is especially useful in environments
          where memory is scarce.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Optimizing the kernel</emphasis>:
          it is possible to optimize the kernel. For instance, by
          compiling it for a specific processor.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Hardware support</emphasis>: Support
          for some hardware is not enabled by default in the &Kernel;
          kernel provided by &Distribution;. A common example is
          support for SMP systems.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Using custom patches</emphasis>: There
          are many unofficial patches for the Linux kernel. Generally
          speaking it is a good idea to avoid unofficial patches. But
          some third party software, like 
          <ulink url="http://www.netraverse.com">Win4Lin</ulink>,
          require that you install an additional kernel patch.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      This chapter focuses on the default kernel series used in
      &Distribution; 10.0, &Kernel; 2.4, though most of these
      instructions also apply to &Kernel; 2.6. Compiling a kernel is
      not really difficult, just keep around a backup kernel that you
      can use when something goes wrong. Kernel compilation involves
      these steps:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Configuring the kernel.
        </para>
      </listitem>
      <listitem>
        <para>
          Making dependencies.
        </para>
      </listitem>
      <listitem>
        <para>
          Building the kernel.
        </para>
      </listitem>
      <listitem>
        <para>
          Building modules.
        </para>
      </listitem>
      <listitem>
        <para>
          Installing the kernel and modules.
        </para>
      </listitem>
      <listitem>
        <para>
          Updating the LILO configuration.
	</para>
      </listitem>
    </itemizedlist>
    
    <para>
      In this chapter, we suppose that the kernel sources are available
      in <filename>/usr/src/linux</filename>. If you have installed the
      kernel sources from the <quote>k</quote> disk set, the kernel
      sources are available in
      <filename>/usr/src/linux-kernelversion</filename>,
      and <filename>/usr/src/linux</filename> is a symbolic link to the
      real kernel source directory. So, if you use the standards &Distribution;
      kernel package you are set to go.
    </para>
  </sect1>

  <sect1 id="kernel-build">
    <title>Configuring the kernel</title>

    <para>
      As laid out above, the first step is to configure the kernel
      source. To ease the configuration of the kernel, it is a good
      idea to copy the default &Distribution; kernel configuration
      to the kernel sources. The &Distribution; kernel configuration
      files are stored on the distribution medium as
      <filename>kernels/&lt;Kernel&gt;/config</filename>. Suppose
      that you use the <filename>bare.i</filename> kernel (which
      is the default kernel), and that you have a &Distribution;
      CD-ROM mounted at <filename>/mnt/cdrom</filename>, you
      can copy the &Distribution; kernel configuration with:
    </para>
    
    <screen>
# <command>cp /mnt/cdrom/kernels/bare.i/config /usr/src/linux/.config</command>
    </screen>
    
    <para>
      At this point you can start to configure the kernel. There are
      three configuration front-ends to the kernel configuration. The
      first one is <parameter class="command">config</parameter>, which
      just asks you what you want to do for each kernel option. This
      takes a lot of time. So, normally this is not a good way to
      configure the kernel. A more user friendly approach is the
      <parameter class="command">menuconfig</parameter> front-end,
      which uses a menuing system that you can use to configure the
      kernel. There is also an X front-end, named
      <parameter class="command">xconfig</parameter>. You can start
      a configuration front-end by going to the kernel source directory,
      and executing <command>make &lt;front-end&gt;</command>. For
      example, to configure the kernel with the menu front-end you
      could use the following commands:
    </para>
    
    <screen>
# <command>cd /usr/src/linux</command>
# <command>make menuconfig</command>
    </screen>
    
    <para>
      In the kernel configuration there are basically three options for
      each choice: <quote>n</quote> disables functionality,
      <quote>y</quote> enables functionality, and <quote>m</quote>
      compiles the functionality as a module. The default &Distribution;
      kernel configuration is a very good configuration, it compiles
      only the bare functionality needed to boot the system in the
      kernel, the rest is compiled as a module. Whatever choices you
      make, you need to make sure that both the driver for your IDE/SCSI
      chip set is available in the kernel and the filesystem driver.
      If they are not, the kernel is not able to mount the root filesystem,
      and no further modules can be loaded.
    </para>
  </sect1>
  
  <sect1>
    <title>Compiling the kernel</title>
    
    <para>
      The first step of the kernel compilation is to let the kernel
      build infrastructure check the dependencies. This can be done
      with <command>make depend</command>:
    </para>

    <screen>
# <command>cd /usr/src/linux</command>
# <command>make depend</command>
    </screen>
    
    <para>
      If <command>make depend</command> quits because there are errors, 
      you have to recheck the kernel configuration. The output of this 
      command will usually give some clues where things went wrong. If
      everything went fine, you can start compiling the kernel with:
    </para>
    
    <para>
      This will compile the kernel and make a compressed kernel image 
      named <filename>bzImage</filename> in
      <filename>/usr/src/linux/arch/i386/boot</filename>. After compiling
      the kernel you have to compile the modules separately:
    </para>

    <screen>
# <command>make modules</command>
    </screen>
    
    <para>
      When the module compilation is done you are ready to install the
      kernel and the kernel modules.
    </para>
  </sect1>
  
  <sect1 id="kernel-install">
    <title>Installing the kernel</title>
    
    <sect2>
      <title>Installation</title>
      
      <para>
        The next step is to install the kernel and the kernel modules.
	We will start with installing the kernel modules, because this
	can be done with one command within the kernel source tree:
      </para>
      
      <screen>
# <command>make modules_install</command>
      </screen>
      
      <para>
        This will install the modules in 
	<filename>/lib/modules/&gt;kernelversion&lt;</filename>. If
	you are replacing a kernel with the same version number, it is
	a good idea to remove the old modules before installing the
	new ones. E.g.:
      </para>
	
      <screen>
# <command>rm -rf /lib/modules/2.4.26</command>
      </screen>
      
      <para>
        You can <quote>install</quote> the kernel by copying it to
	the <filename>/boot</filename> directory. You can give it
	any name you want, but it is a good idea to use some
	naming convention. E.g. 
	<filename>vmlinuz-somename-version</filename>. For instance,
	if we would name it <filename>vmlinuz-custom-2.4.28</filename>,
	we can copy it from within the kernel source tree with:
      </para>
      
      <screen>
# <command>cp arch/i386/boot/bzImage /boot/vmlinuz-custom-2.4.28</command>
      </screen>
      
      <para>
        At this point you are almost finished. The last step is to
	add the new kernel to the Linux boot loader.
      </para>
    </sect2>
    
    <sect2>
      <title>Configuring LILO</title>
      
      <para>
        <acronym>LILO</acronym> (Linux Loader) is the default boot loader
	that &Distribution; uses. The configuration of LILO works in two
	steps; the first step is to alter the LILO configuration in
	<filename>/etc/lilo.conf</filename>. The second step is to run
	the <command>lilo</command>, which will write the LILO configuration
	to the boot loader. The LILO configuration already has an entry
	for the current kernel you are running. It is a good idea to
	keep this entry, as a fall-back option if your new kernel does
	not work. If you scroll down to the bottom of
	<filename>/etc/lilo.conf</filename> you will see this entry,
	it looks comparable to this:
      </para>
      
      <screen>
# Linux bootable partition config begins
image = /boot/vmlinuz
  root = /dev/hda5
  label = Slack
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
# Linux bootable partition config ends
      </screen>
      
      <para>
        The easiest way to add the new kernel is to duplicate the existing
	entry, and then editing the first entry, changing the
	<parameter>image</parameter>, and <parameter>label</parameter>
	options. After changing the example above it would look like
	this:
      </para>
      
      <screen>
# Linux bootable partition config begins
image = /boot/vmlinuz-custom-2.4.28
  root = /dev/hda5
  label = Slack
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking

image = /boot/vmlinuz
  root = /dev/hda5
  label = SlackOld
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
# Linux bootable partition config ends
      </screen>
      
      <para>
        As you can see the <parameter>image</parameter> points to the
	new kernel in the first entry, and we changed the label of the
	second entry to <quote>SlackOld</quote>. LILO will automatically
	boot the first image. You can now install this new LILO
        configuration with the <command>lilo</command> command:
      </para>

      <screen>
# <command>lilo</command>
Added Slack *
Added SlackOld
      </screen>

      <para>
        The next time you boot both entries will be available, and the
        <quote>Slack</quote> entry will be booted by default.
      </para>
    </sect2>
  </sect1>

</chapter>