<!-- $Id: filesystem.xml,v 1.11 2005/05/04 09:57:21 daniel Exp $ -->

<chapter> <?dbhtml filename="filesystem.html"?>
<title>Files and directories</title>

<sect1>
<title>Introduction</title>

<para>
Unix-like operating systems use a hierarchical filesystem to store files and 
directories. Directories can contain files and other directories, the top
directory (<filename>/</filename>) is named the root directory (not to be 
confused with the <filename>/root</filename> directory). Most filesystems
also support file links (which provide alternative names for a file) and soft 
links. Other filesystems can be <quote>connected</quote> to an arbitrary
directory. This process is named <quote>mounting</quote>, and the directory
in which the filesystem is mounted is named the <quote>mount point</quote>.
</para>

<para>
This chapter covers the basic navigation of the filesystem, commands which
are used to remove and create directories, filesystem permissions, links
and mounting.
</para>
</sect1>

<sect1>
<title>The basics</title>

<bridgehead>pwd</bridgehead>

<para>
<command>pwd</command>(1) is a simple utility which shows the directory
you are currently working in. The <command>pwd</command> does not require
any parameters. This is an example output of <command>pwd</command>:
</para>

<screen>
$ <command>pwd</command>
/home/danieldk
</screen>

<bridgehead>ls</bridgehead>

<para>
<command>ls</command> is similar to the <command>dir</command> command in
DOS and Windows. <command>ls</command> can be used to display files and
directories located in specific directories. Running the 
<command>ls</command> command without any parameters shows the
contents of the current directory: 
</para>

<screen>
$ <command>ls</command>
COPYING  CVS  Makefile  README  html  images  pdf  src  tex
</screen>

<para>
Naturally it is also possible to show the contents of other directories.
You can do this by specifying the path as a parameter tot the
<command>ls</command> command:
</para>

<screen>
$ <command>ls /</command>
bin   cdrom   dev  floppy  initrd  lost+found  opt   root  sys  usr  windows
boot  cdrom1  etc  home    lib     mnt         proc  sbin  tmp  var
</screen>

<para>
A disadvantage of the default output is that it provides little information
about files and directories. For example, it is not possible to see whether
some entry is a file or directory, what size a file is, or who the owner
of the file is. The <command>ls</command> has the 
<parameter class="command">-l</parameter> parameter to show more information: 
</para>

<screen>
$ <command>ls -l</command>
total 52
-rw-r--r--    1 daniel   daniel      20398 Jul 16 14:28 COPYING
drwxr-xr-x    2 daniel   daniel       4096 Jul 16 14:28 CVS
-rw-r--r--    1 daniel   daniel        768 Jul 16 14:28 Makefile
-rw-r--r--    1 daniel   daniel        408 Jul 16 14:28 README
drwxr-xr-x    3 daniel   daniel       4096 Jul 16 14:28 html
drwxr-xr-x    3 daniel   daniel       4096 Jul 16 14:28 images
drwxr-xr-x    3 daniel   daniel       4096 Jul 16 14:28 pdf
drwxr-xr-x    3 daniel   daniel       4096 Jul 20 00:11 src
drwxr-xr-x    3 daniel   daniel       4096 Jul 16 14:28 tex
</screen>

<bridgehead>cd</bridgehead>

<para>
Another important command is the <command>cd</command> command.
It can be used to change the current working directory:
</para>

<screen>
$ <command>cd /home/danieldk/</command>
</screen>

<para>
With the <command>pwd</command> command you can see it worked:
</para>

<screen>
$ <command>pwd</command>
/home/danieldk
</screen>

<bridgehead>mkdir</bridgehead>

<para>
As you might have guessed, the <command>mkdir</command>(1) command
can be used to create directories. For example: 
</para>

<screen>
$ <command>pwd</command>
/home/danieldk
$ <command>mkdir test</command>
$ <command>cd test</command>
$ <command>pwd</command>
/home/danieldk/test
</screen>

<para>
It might happen that you want to create a directory in a
parent directory which does not exist yet. For example,
if you want to create the <filename>test2/hello/</filename> directory,
but the <filename>test2</filename> directory does not yet exist.
In this case you can make both directories with only one 
<command>mkdir</command> command:
</para>

<screen>
$ <command>mkdir -p test2/hello</command>
</screen>

<bridgehead>cp</bridgehead>

<para>
Files can be copied with the <command>cp</command>(1) command, the basic syntax
is <command>cp source destination</command>. For example, suppose that we have 
a file named <filename>memo</filename> which we would like to copy to the 
<filename>writings</filename> directory. You can do this with the following
command:
</para>

<screen>
$ <command>cp memo writings/</command>
</screen>

<para>
It is also possible to copy a file in the same directory. For example, if
we would like to make a new memo based on <filename>memo</filename>, named
<filename>memo2</filename>, we could execute the following command:
</para>

<screen>
$ <command>cp memo memo2</command>
</screen>

<para>
It is also possible to copy directories recursively, this can be done by
adding the <parameter class="command">-r</parameter> parameter. The following 
command copies the
<filename>memos</filename> directory, and all subdirectories, and (sub)files 
to the <filename>writings</filename> directory:
</para>

<screen>
$ <command>cp -r memos writings/</command>
</screen>

<bridgehead>mv</bridgehead>

<para>
The <command>mv</command>(1) command is comparable to <command>cp</command>, 
but it is used to move files. Suppose that we have the same situation as in
the first <command>cp</command> example, but you would rather like to move
<filename>memo</filename> to the <filename>writings</filename> directory.
The following command would do that:
</para>

<screen>
$ <command>mv memo writings/</command>
</screen>

<para>
It is also possible to move directories. But, <command>mv</command> always
works recursively. For example, the following command will move the
<filename>memos</filename> directory to the <filename>writings</filename>
directory:
</para>

<screen>
$ <command>mv memos writings/</command>
</screen>

<bridgehead>rm</bridgehead>

<para>
The <command>rm</command>(1) command is used to remove files and directories.
Let's look at a simple example:
</para>

<screen>
$ <command>rm hello.c</command>
</screen>

<para>
This commands removes the file <filename>hello.c</filename>. Sometimes
the <command>rm</command> asks for a confirmation. You can ignore this
with the <parameter class="command">-f</parameter> parameter:
</para>

<screen>
$ <command>rm -f *</command>
</screen>

<para>
This command removes all files in the current directory without asking
for confirmation. It is also possible to delete directories or even
whole directory trees. <command>rm</command> provides the
<parameter class="command">-r</parameter> parameter to do this. Suppose that
we want to delete the <filename>ogle</filename> directory and all 
subdirectories and files in that directory, this can be done in the 
following way:
</para>

<screen>
$ <command>rm -r -f ogle/</command>
</screen>

<para>
Many commands allow you to combine parameters. The following example
is equivalent to the last one:
</para>

<screen>
$ <command>rm -rf ogle/</command>
</screen>

</sect1>

<sect1>
<title>Permissions</title>

<bridgehead>A short introduction</bridgehead>
<para>
Every file in &OS; has permissions. As you might have noticed,
file permissions can be shown with the <command>ls -l</command> command:
</para>

<screen>
$ <command>ls -l logo.jpg</command>
-rw-r--r--    1 danieldk users        9253 Dec 23 19:12 logo.jpg
</screen>

<para>
The permissions are shown in the first column. Permissions that
can be set are read(r), write(w) and execute(x). These permissions
can we set for three classes: owner(u), group(g) and others(o).
The permissions are visible in the second to ninth character
in the first column. These nine characters are divided in three
groups. The first three characters represent the permissions
for the owner, the next three characters represent the permissions
for the group, finally the last three characters represent the
permissions for other users. Thus, the example file shown above
can be written to by the owner and can be read by all three
classes of users (owner, group and others). 
</para>

<para>
Each &OS; system has many distinct users (a list of users
can be found in <filename>/etc/passwd</filename>), and a user
can be a member of certain groups. This kind of user management
provides makes it possible to manage detailed permissions for
each file. In the example shown above <emphasis>danieldk</emphasis>
is the owner of the file and group permissions apply to the
group <emphasis>users</emphasis>. In this example groups rights
do not differ from the rights of other users. 
</para>

<bridgehead>chown</bridgehead>

<para>
The <command>chown</command>(1) command is used to set the file
owner and to which group group permissions should apply to.
Suppose we want to make <emphasis>danieldk</emphasis> the owner
of the file <filename>logo2.jpg</filename>, this can be done with
the <command>chown</command>:
</para>

<screen>
# <command>chown danieldk logo2.jpg</command>
</screen>

<para>
Using the <command>ls</command> we can see that the owner
is now <emphasis>danieldk</emphasis>:
</para>

<screen>
# <command>ls -l logo2.jpg</command> 
-rw-r--r--    1 root     root        9253 Dec 29 11:35 logo2.jpg
# <command>chown danieldk logo2.jpg</command>
# <command>ls -l logo2.jpg</command> 
-rw-r--r--    1 danieldk root        9253 Dec 29 11:35 logo2.jpg
</screen>

<para>
But group permissions still apply for the <emphasis>root</emphasis>
group. This group can be changed by adding a colon after the owner,
followed by the name of the group (in this example the group
is nedslackers):
</para>

<screen>
# <command>chown danieldk:nedslackers logo2.jpg</command>
# <command>ls -l logo2.jpg</command>
-rw-r--r--    1 danieldk nedslackers        9253 Dec 29 11:35 logo2.jpg
</screen>

<para>
It is also possible to change ownership recursively, this can be
done with the recursive (<parameter class="command">-R</parameter>) 
parameter:
</para>

<screen>
# <command>chown -R danieldk:users oggs/</command>
</screen>

<bridgehead>chmod</bridgehead>

<para>
File permissions can be manipulated using the <command>chmod</command>(1)
command. The most basic syntax of chmod is <command>chmod [u,g,o][+/-][r,w,x]
filename</command>. The first parameter consists of the following elements:
1. which classes this manipulation permission applies to, 2. if the permissions
should be added (+) or removed (-), and 3. which permissions should be
manipulated. Suppose we want to make the file <filename>memo</filename>
writable for the owner of the file and the groups for which the group
permissions apply. This can be done with the following command:
</para>

<screen>
$ <command>chmod ug+w memo</command>
</screen>

<para>
As you can see below the <filename>memo</filename> is now writable
for the file owner and group:
</para>

<screen>
$ <command>ls -l memo</command> 
-r--r--r--    1 daniel   users          12 Mar  9 16:28 memo 
bash-2.05b$ <command>chmod ug+w memo</command>
bash-2.05b$ <command>ls -l notes</command> 
-rw-rw-r--    1 daniel   users          12 Mar  9 16:28 memo 
</screen>

<para>
Just like the <command>chown</command> command it is also possible
to do recursive (<parameter class="command">-R</parameter>) operations. 
In the following example the
<filename>secret/</filename>, including subdirectories and files in this
directory, is made unreadable for the group set for
this directory and other users:
</para>

<screen>
$ <command>chmod -R go-r secret/</command>
</screen>
</sect1>

<sect1>
<title>Archives</title>

<sect2>
<title>Introduction</title>

<para>
Sooner or later a &OS; user will encounter <acronym>tar</acronym>
archives, tar is the standard format for archiving files on &OS;.
It is often used in conjunction with <command>gzip</command> or
<command>bzip2</command>. Both commands can compress files and archives.
<xref linkend="archive-extentions" /> lists frequently used archive 
extensions, and what they mean.
</para>

<table id="archive-extentions">
<title>Archive file extensions</title>
<tgroup cols="2" align="left" colsep="1" rowsep="1">
<thead>
<row>
<entry>Extension</entry>
<entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry>.tar</entry>
<entry>An uncompressed tar archive</entry>
</row>
<row>
<entry>.tar.gz</entry>
<entry>A tar archive compressed with gzip</entry>
</row>
<row>
<entry>.tgz</entry>
<entry>A tar archive compressed with gzip</entry>
</row>
<row>
<entry>.tar.bz2</entry>
<entry>A tar archive compressed with bzip2</entry>
</row>
<row>
<entry>.tbz</entry>
<entry>A tar archive compressed with bzip2</entry>
</row>
</tbody>
</tgroup>
</table>

<para>
The difference between <command>bzip2</command> and <command>gzip</command>
is that <command>bzip2</command> can find repeating information in larger
blocks, resulting in better compression. But <command>bzip2</command> is
also a lot slower, because it does more data analysis.
</para>
</sect2>

<sect2>
<title>Extracting archives</title>

<para>
Since many software and data in the &OS; world is archived with
<command>tar</command> it is important to get used to extracting tar
archives. The first thing you will often want to do when you receive
a tar archive is to list its contents. This can be achieved by using
the <parameter class="command">t</parameter> parameter. However, if we just 
execute <command>tar</command> with this parameter and the name of the archive
it will just sit and wait until you enter something to the standard
input:
</para>

<screen>
$ <command>tar t test.tar</command>

</screen>

<para>
This happens because <command>tar</command> reads data from its standard
input. If you forgot how redirection works, it is a good idea to reread
<xref linkend="redirection-and-pipes" />. Let's see what happens if we
redirect our tar archive to tar:
</para>

<screen>
$ <command>tar t &lt; test.tar</command>
test/
test/test2
test/test1
</screen>

<para>
That looks more like the output you probably expected. This archive
seems to contain a directory <filename>test</filename>, which contains
the files <filename>test2</filename> and <filename>test2</filename>.
It is also possible to specify the archive file name as an parameter
to <command>tar</command>, by using the 
<parameter class="command">f</parameter> parameter:
</para>

<screen>
$ <command>tar tf test.tar</command> 
test/
test/test2
test/test1
</screen>

<para>
This looks like an archive that contains useful files ;). We can now go
ahead, and extract this archive by using the 
<parameter class="command">x</parameter> parameter:
</para>

<screen>
$ <command>tar xf test.tar</command>
</screen>

<para>
We can now verify that tar really extracted the archive by listing the
contents of the directory with <command>ls</command>:
</para>

<screen>
$ <command>ls test/</command>
test1  test2
</screen>

<para>
Extracting or listing files from a gzipped or bzipped archive is not
much more difficult. This can be done by adding a 
<parameter class="command">z</parameter> or 
<parameter class="command">b</parameter> for respectively archives
compressed with <command>gzip</command> or <command>bzip2</command>.
For example, we can list the contents of a gzipped archive with:
</para>

<screen>
$ <command>tar ztf archive2.tar.gz</command>
</screen>

<para>
And a bzipped archive can be extracted with:
</para>

<screen>
$ <command>tar bxf archive3.tar.bz2</command>
</screen>
</sect2>

<sect2>
<title>Creating archives</title>

<para>
You can create archives with the <parameter class="command">c</parameter> 
parameter. Suppose that
we have the directory <filename>test</filename> shown in the previous
example. We can make an archive with the <filename>test</filename> directory
and the files in this directory with:
</para>

<screen>
$ <command>tar cf important-files.tar test</command>
</screen>

<para>
This will create the <filename>important-files.tar</filename> archive
(which is specified with the <parameter class="command">f</parameter> 
parameter). We can now verify the archive:
</para>

<screen>
$ <command>tar tf important-files.tar</command>
test/
test/test2
test/test1
</screen>

<para>
Creating a gzipped or bzipped archive goes along the same lines as
extracting compressed archives: add a 
<parameter class="command">z</parameter> for gzipping
an archive, or <parameter class="command">b</parameter> for bzipping 
an archive. Suppose
that we wanted to create a <command>gzip</command> compressed
version of the archive created above. We can do this with:
</para>

<screen>
<command>tar zcf important-files.tar.gz test</command>
</screen>
</sect2>
</sect1>

<sect1><title>Extended attributes</title>

<sect2>
<title>Introduction</title>

<para>
Extended attributes (EAs) are relatively new on &OS;.  Extended
attributes are a special kind of values that are associated with a
file or directory. EAs provide the means to add extra attributes
besides the common attributes (modification time, traditional file
permissions, etc.). For example, one could add the attribute
<quote>Photographer</quote> to a collection of JPEG files. Extended attributes 
are not physically stored in the file, but as meta-data in the filesystem.
</para>

<para>
Extended attributes are only supported by 2.6.x and newer 2.4.x kernels. 
Besides that they are not supported on all filesystems, the commonly used
Ext2, Ext3 and XFS filesystems do support extended attributes.
</para>
</sect2>

<sect2>
<title>Installing the necessary utilities</title>

<para>
The extended attribute software is available in &Distribution; through
the <emphasis>xfsprogs</emphasis> package, which can be found in
the <quote>a</quote> disk set. Don't be misled by the name of the
package, the extended attribute tools also work with other filesystems,
like Ext3. 
</para>
</sect2>

<sect2>
<title>Showing extended attributes</title>

<para>
Extended attributes can be queried using the <command>getfattr</command>
command. Just using getfattr with a file as a parameter will show the 
attributes that are known for that particular file, without the values 
set for the attributes. For example:
</para>

<screen>
$ <command>getfattr note.txt</command> 
# file: note.txt
user.Author
</screen>

<para>
This file has one extended attribute, <quote>user.Author</quote>. An attribute 
has the following form: <quote>namespace.attribute</quote>. There are four 
defined namespaces: <quote>security</quote>, <quote>system</quote>, 
<quote>trusted</quote>, and <quote>user</quote>. The role of these namespaces 
are described in the attr(5) manual page. The <quote>user</quote> namespace is of 
particular interest to us, because this namespace is used to assign arbitrary 
attributes to files.
</para>

<para>
The values associated with an attribute can be shown using the 
<parameter class="command">-d</parameter> (dump) parameter. For example:
</para>

<screen>
$ <command>getfattr -d note.txt</command> 
# file: note.txt
user.Author="Daniel"
</screen>

<para>
In this example the attribute <quote>user.Author</quote> has the value 
<quote>Daniel</quote> for the file <filename>note.txt</filename>.
</para>
</sect2>

<sect2>
<title>Setting extended attributes</title>

<para>
Attributes are set with the <command>setfattr</command> command. An attribute 
can be added to a file using the <parameter class="command">-n</parameter> 
(name) parameter, be sure 
to specify the namespace and the attribute name, for example:
</para>

<screen>
$ <command>setfattr -n user.Author note2.txt</command>
</screen>

<para>
The value of the attribute can be set using the 
<parameter class="command">-v</parameter> (value) parameter: 
</para>

<screen>
$ <command>setfattr -n user.Author -v Mike note2.txt</command>
</screen>

<para>
But it is also possible to add an attribute and setting its value in one run, 
by specifying both the <parameter class="command">-n</parameter> and 
<parameter class="command">-v</parameter> parameters. For 
example, the following command adds the MD5 sum of the file as an extended 
attribute:
</para>

<screen>
$ <command>setfattr -n user.MD5 -v `md5sum note2.txt` note2.txt</command>
$ <command>getfattr -d note2.txt</command>
# file: note2.txt
user.Author="Mike"
user.MD5="78be7a3148027ae7a897aad95e7d9c58"
</screen>
</sect2>

</sect1>

<sect1 id="mounting"><title>Mounting filesystems</title>

<sect2>
<title>Introduction</title>

<para>
Like most Unices &Kernel; uses a technique named <quote>mounting</quote> to
access filesystems. Mounting means that a filesystem is connected to a
directory in the root filesystem. One could for example mount a CD-ROM
drive to the <filename>/mnt/cdrom</filename> directory. &Kernel; supports
many kinds of filesystems, like Ext2, Ext3, ReiserFS, JFS, XFS, ISO9660
(used for CD-ROMs), UDF (used on some DVDs) and DOS/Windows filesystems,
like FAT, FAT32 and NTFS. These filesystems can reside on many kinds of
media, for example hard drives, CD-ROMs and Flash drives. This section
explains how filesystems can be mounted and unmounted.
</para>
</sect2>

<sect2>
<title>mount</title>

<para>
The <command>mount</command>(8) is used to mount filesystems. The basic
syntax is: <quote>mount /dev/devname /mountpoint</quote>. The device name
can be any block device, like hard disks or CD-ROM drives. The mount point
can be an arbitrary point in the root filesystem. Let's look at an example:
</para>

<screen>
# <command>mount /dev/cdrom /mnt/cdrom</command>
</screen>

<para>
This mounts the <filename>/dev/cdrom</filename> on the 
<filename>/mnt/cdrom</filename> mountpoint. The <filename>/dev/cdrom</filename>
device name is normally a link to the real CD-ROM device name (for example,
<filename>/dev/hdc</filename>). As you can see, the concept is actually
very simple, it just takes some time to learn the device names ;). Sometimes
it is necessary to specify which kind of filesystem you are trying to mount. 
The filesystem type can be specified by adding the 
<parameter class="command">-t</parameter> parameter:
</para>

<screen>
# <command>mount -t vfat /dev/sda1 /mnt/flash</command>
</screen>

<para>
This mounts the vfat filesystem on <filename>/dev/sda1</filename> to
<filename>/mnt/flash</filename>.
</para>
</sect2>

<sect2>
<title>umount</title>

<para>
The <command>umount</command>(1) command is used to unmount filesystems.
<command>umount</command> accepts two kinds of parameters, mount points
or devices. For example:
</para>

<screen>
# <command>umount /mnt/cdrom</command>
# <command>umount /dev/sda1</command>
</screen>

<para>
The first command unmounts the filesystem that was mounted on
<filename>/mnt/cdrom</filename>, the second commands unmounts the
filesystem on <filename>/dev/sda1</filename>.
</para>
</sect2>

<sect2>
<title>The fstab file</title>

<para>
The &OS; system has a special file, <filename>/etc/fstab</filename>,
that specifies which filesystems should be mounted during the system boot.
Let's look at an example:
</para>

<screen>
/dev/hda10       swap             swap        defaults         0   0
/dev/hda5        /                xfs         defaults         1   1
/dev/hda6        /var             xfs         defaults         1   2
/dev/hda7        /tmp             xfs         defaults         1   2
/dev/hda8        /home            xfs         defaults         1   2
/dev/hda9        /usr             xfs         defaults         1   2
/dev/cdrom       /mnt/cdrom       iso9660     noauto,owner,ro  0   0
/dev/fd0         /mnt/floppy      auto        noauto,owner     0   0
devpts           /dev/pts         devpts      gid=5,mode=620   0   0
proc             /proc            proc        defaults         0   0
</screen>

<para>
As you can see each entry in the <filename>fstab</filename> file has five
entries: fs_spec, fs_file, fs_vfstype, fs_mntops, fs_freq, and fs_passno.
We are now going to look at each entry. 
</para>

<sect3>
<title>fs_spec</title>

<para>
The fs_spec option specifies the block device, or remote filesystem that
should be mounted. As you can see in the example several /dev/hda partitions
are specified, as well as the CD-ROM drive and floppy drive. When NFS
volumes are mounted an IP address and directory can be specified, for
example: <filename>192.168.1.10:/exports/data</filename>.
</para>
</sect3>

<sect3>
<title>fs_file</title>

<para>
fs_file specifies the mount point. This can be an arbitrary directory in
the filesystem.
</para>
</sect3>

<sect3>
<title>fs_vfstype</title>

<para>
This option specifies what kind of filesystem the entry represents. For
example this can be: ext2, ext3, reiserfs, xfs, nfs, vfat, or ntfs.
</para>
</sect3>

<sect3>
<title>fs_mntops</title>

<para>
The fs_mntops option specifies which parameters should be used for mounting
the filesystem. The <command>mount</command>(8) manual page has an extensive
description of the available options. These are the most interesting
options:
</para>

<itemizedlist>
<listitem>
<para>
<emphasis>noauto</emphasis>: filesystems that are listed in
<filename>/etc/fstab</filename> are normally mounted automatically. When
the <quote>noauto</quote> option is specified, the filesystem will not
be mounted during the system boot, but only after issuing a 
<command>mount</command> command. When mounting such filesystem, only
the mount point or device name has to be specified, for example:
<command>mount /mnt/cdrom</command>
</para>
</listitem>
<listitem>
<para>
<emphasis>user</emphasis>: adding the <quote>user</quote> option will
allow normal users to mount the filesystem (normally only the superuser
is allowed to mount filesystems).
</para>
</listitem>
<listitem>
<para>
<emphasis>owner</emphasis>: the <quote>owner</quote> option will allow
the owner of the specified device to mount the specified device. You can
see the owner of a device using <command>ls</command>, e.g. 
<command>ls -l /dev/cdrom</command>.
</para>
</listitem>
<listitem>
<para>
<emphasis>noexec</emphasis>: with this option enabled users can not
run files from the mounted filesystem. This can be used to provide
more security.
</para>
</listitem>
<listitem>
<para>
<emphasis>nosuid</emphasis>: this option is comparable to the 
<quote>noexec</quote> option. With <quote>nosuid</quote> enabled SUID
bits on files on the filesystem will not be allowed. SUID is used
for certain binaries to provide a normal user to do something privileged.
This is certainly a security threat, so this option should really be
used for removable media, etc. A normal user mount will force the
nosuid option, but a mount by the superuser will not!
</para>
</listitem>
<listitem>
<para>
<emphasis>unhide</emphasis>: this option is only relevant for normal
CD-ROMs with the ISO9660 filesystem. If <quote>unhide</quote> is specified
hidden files will also be visible.
</para>
</listitem>
</itemizedlist>

</sect3>

<sect3>
<title>fs_freq</title>

<para>
If the <quote>fs_freq</quote> is set to 1 or higher, it specifies after
how many days a filesystem dump (backup) has to be made. This option is
only used when <command>dump</command>(8) is set up correctly to handle this.
</para>
</sect3>

<sect3>
<title>fs_passno</title>

<para>
This field us used by <command>fsck</command>(8) to determine the order
in which filesystems are checked during the system boot.
</para>
</sect3>
</sect2>

</sect1>

<sect1>

<title>Encrypting and signing files</title>

<sect2>
<title>Introduction</title>

<para>
There are two security mechanisms for securing files: signing files 
and encrypting files. Signing a file means that a special digital
signature is generated for a file. You, or other persons can use the
signature to verify the integrity of the file. File encryption encodes
a file in a way that only a person for which the file was intended to
read can read the file.
</para>

<para>
This system relies on two keys: the private and the public key. Public
keys are used to encrypt files, and files can only be decrypted with
the private key. This means that one can sent his public key out to
other persons. Others can use this key to send encrypted files, that
only the person with the private key can decode. Of course, this means
that the security of this system depends on how well the private is
kept secret.
</para>

<para>
Slackware Linux provides an excellent tool for signing and encrypting
files, named GnuPG. GnuPG can be installed from the <quote>n</quote>
disk set.
</para>
</sect2>

<sect2>
<title>Generating your private and public keys</title>

<para>
Generating public and private keys is a bit complicated, because GnuPG
uses DSA keys by default. DSA is an encryption algorithm, the problem is
that the maximum key length of DSA is 1024 bits, this is considered too
short for the longer term. That is why it is a good idea to use 2048 bit
RSA keys. This section describers how this can be done.
</para>

<note>
<para>
1024-bit keys were believed to be secure for a long time. But Bernstein's
paper <emphasis>Circuits for Integer Factorization: a Proposal</emphasis> contests this, the
bottom line is that it is quite feasible for national security agencies to
produce hardware that can break keys in a relatively short amount of time.
Besides that it has be shown that 512-bit RSA keys can be broken in a 
relatively short time using common hardware. More information about these
issues can by found in this e-mail to the cypherpunks list:
<ulink url="http://lists.saigon.com/vault/security/encryption/rsa1024.html" />
</para>
</note>

<para>
We can generate a key by executing:
</para>

<screen>
$ <command>gpg --gen-key</command>
</screen>

<para>
The first question is what kind of key you would like to make. We will
choose <emphasis>(4) RSA (sign only)</emphasis>:
</para>

<screen>
Please select what kind of key you want:
   (1) DSA and ElGamal (default)
   (2) DSA (sign only)
   (4) RSA (sign only)
Your selection? <command>4</command>
</screen>

<para>
You will then be asked what the size of the key you want to generate has
to be. Type in <emphasis>2048</emphasis> to generate a 2048 bit key, and
press enter to continue.
</para>

<screen>
What keysize do you want? (1024) <command>2048</command>
</screen>

<para>
The next question is simple to answer, just choose what you like. Generally
speaking it is not a bad idea to let the key be valid infinitely. You can
always deactivate the key with a special revocation certificate.
</para>

<screen>
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <command>0</command>
</screen>

<para>
GnuPG will then ask for confirmation. After confirming your name and e-mail
address will be requested. GnuPG will also ask for a comment, you can leave
this blank, or you could fill in something like <quote>Work</quote> or
<quote>Private</quote>, to indicate what the key is used for. For example:
</para>

<screen>
Real name: <command>John Doe</command>
Email address: <command>john@doe.com</command>
Comment: <command>Work</command>              
You selected this USER-ID:
    "John Doe (Work) &lt;john@doe.com&gt;"
</screen>

<para>
GnuPG will the ask you to confirm your user ID. After confirming it GnuPG
will ask you to enter a password. Be sure to use a good password:
</para>

<screen>
You need a Passphrase to protect your secret key.    

Enter passphrase:
</screen>

<para>
After entering the password twice GnuPG will generate the keys. But we are
not done yet. GnuPG has only generated a key for signing information, not
for encryption of information. To continue, have a look at the output,
and look for the key ID. In the information about the key you will see
<emphasis>pub  2048R/</emphasis>. The key ID is printed after this fragment.
In this example:
</para>

<screen>
public and secret key created and signed.
key marked as ultimately trusted.

pub  2048R/8D080768 2004-07-16 John Doe (Work) &lt;john@doe.com&gt;
     Key fingerprint = 625A 269A 16B9 C652 B953  8B64 389A E0C9 8D08 0768
</screen>

<para>
the key ID is <emphasis>8D080768</emphasis>. If you lost the output of the
key generation you can still find the key ID in the output of the
<command>gpg --list-keys</command> command. Use the key ID to tell GnuPG
that you want to edit your key:
</para>

<screen>
$ <command>gpg --edit-key &lt;Key ID&gt;</command>
</screen>

<para>
With the example key above the command would be:
</para>

<screen>
$ <command>gpg --edit-key 8D080768</command>
</screen>

<para>
GnuPG will now display a command prompt. Execute the <command>addkey</command>
command on this command prompt:
</para>

<screen>
Command&gt; <command>addkey</command>
</screen>

<para>
GnuPG will now ask the password you used for your key:
</para>

<screen>
Key is protected.

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
</screen>

<para>
After entering the password GnuPG will ask you what kind of key you
would like to create. Choose <emphasis>RSA (encrypt only)</emphasis>, and fill
in the information like you did earlier (be sure to use a 2048 bit key). 
For example:
</para>

<screen>
Please select what kind of key you want:
   (2) DSA (sign only)
   (3) ElGamal (encrypt only)
   (4) RSA (sign only)
   (5) RSA (encrypt only)
Your selection? <command>5</command>
What keysize do you want? (1024) <command>2048</command>
Requested keysize is 2048 bits       
Please specify how long the key should be valid.
         0 = key does not expire
      &lt;n&gt;  = key expires in n days
      &lt;n&gt;w = key expires in n weeks
      &lt;n&gt;m = key expires in n months
      &lt;n&gt;y = key expires in n years
Key is valid for? (0) <command>0</command>
</screen>

<para>
And confirm that the information is correct. After the key is generated
you can leave the GnuPG command prompt, and save the new key with the
<command>save</command> command:
</para>

<screen>
Command&gt; <command>save</command>
</screen>

<para>
Congratulations! You have now generated the necessary keys to encrypt
and decrypt e-mails and files. You can now configure your e-mail client
to use GnuPG. It is a good idea to store the contents of the
<filename>.gnupg</filename> directory on some reliable medium, and store that
in a safe place! If your private key is lost you can't decrypt files and 
messages that were encrypted with your public key. If the private key, and your
password are stolen, the security of this system is completely compromised.
</para>
</sect2>

<sect2>
<title>Exporting your public key</title>

<para>
To make GnuPG useful, you have to give your public key to people who send
you files or e-mails. They can use your public key to encrypt files, or use
it to verify whether a file has a correct signature or not. The key can
be exported using the <parameter class="command">--export</parameter> 
parameter. It is also
a good idea to specify the <parameter class="command">--output</parameter> 
parameter, this
will save the key in a file. The following command would save the public
key of <emphasis>John Doe</emphasis>, used in earlier examples, to
the file <filename>key.gpg</filename>:
</para>

<screen>
$ <command>gpg --output key.gpg --export john@doe.com</command>
</screen>

<para>
This saves the key in binary format. Often it is more convenient to
use the so-called <quote>ASCII armored output</quote>, which fits better 
for adding the key to e-mails, or websites. You export an ASCII armored
version of the key by adding the <parameter class="command">--armor</parameter> parameter:
</para>

<screen>
$ <command>gpg --armor --output key.gpg --export john@doe.com</command>
</screen>

<para>
If you look at the <filename>key.gpg</filename> file you will notice that
the ASCII armored key is a much more comfortable format.
</para>
</sect2>

<sect2>
<title>Signatures</title>

<para>
With GPG you can make a signature for a file. This signature is unique,
because your signature can only be made with your private key. This means
that other people can check whether the file was really sent by you, and
whether it was in any way altered or not. Files can be signed with the
<parameter class="command">--detach-sign</parameter> parameter. Let us look 
at an example. This 
command will make a signature for the <filename>memo.txt</filename> file. The 
signature will be stored in <filename>memo.txt.sig</filename>.
</para>

<screen>
$ <command>gpg --output memo.txt.sig --detach-sign memo.txt</command>

You need a passphrase to unlock the secret key for
user: "John Doe (Work) &lt;john@doe.com&gt;"
2048-bit RSA key, ID 8D080768, created 2004-07-16

Enter passphrase:
</screen>

<para>
As you can see, GnuPG will ask you to enter the password for your
private key. After you have entered the right key the signature file
(<filename>memo.txt.sig</filename>) will be created.
</para>

<para>
You can verify a file with its signature using the 
<parameter class="command">--verify</parameter> parameter. Specify 
the signature file
as a parameter to the <parameter class="command">--verify</parameter> 
parameter. The
file that needs to be verified can be specified as the final parameter:
</para>

<screen>
$ <command> gpg --verify memo.txt.sig memo.txt</command>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: Good signature from "John Doe (Work) &lt;john@doe.com&gt;"
</screen>

<para>
This will confirm that the file was indeed signed by <emphasis>John Doe (Work) 
&lt;john@doe.com&gt;</emphasis>, with the key <emphasis>8D080768</emphasis>,
and that the file is unchanged. Suppose the file was changed, GnuPG would
have complained about it loudly:
</para>

<screen>
$ <command>gpg --verify memo.txt.sig memo.txt</command>
gpg: Signature made Tue Jul 20 23:47:45 2004 CEST using RSA key ID 8D080768
gpg: BAD signature from "John Doe (Work) &lt;john@doe.com&gt;"
</screen>
</sect2>

</sect1>

</chapter>
